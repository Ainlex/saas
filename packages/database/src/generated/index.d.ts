
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Modulo
 * 
 */
export type Modulo = $Result.DefaultSelection<Prisma.$ModuloPayload>
/**
 * Model EmpresaModulo
 * 
 */
export type EmpresaModulo = $Result.DefaultSelection<Prisma.$EmpresaModuloPayload>
/**
 * Model ModuloDependencia
 * 
 */
export type ModuloDependencia = $Result.DefaultSelection<Prisma.$ModuloDependenciaPayload>
/**
 * Model ModuloRuta
 * 
 */
export type ModuloRuta = $Result.DefaultSelection<Prisma.$ModuloRutaPayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model ModuloPermiso
 * 
 */
export type ModuloPermiso = $Result.DefaultSelection<Prisma.$ModuloPermisoPayload>
/**
 * Model RolPermiso
 * 
 */
export type RolPermiso = $Result.DefaultSelection<Prisma.$RolPermisoPayload>
/**
 * Model EmpresaConfiguracion
 * 
 */
export type EmpresaConfiguracion = $Result.DefaultSelection<Prisma.$EmpresaConfiguracionPayload>
/**
 * Model Factura
 * 
 */
export type Factura = $Result.DefaultSelection<Prisma.$FacturaPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model MovimientoCaja
 * 
 */
export type MovimientoCaja = $Result.DefaultSelection<Prisma.$MovimientoCajaPayload>
/**
 * Model ModuloHistorico
 * 
 */
export type ModuloHistorico = $Result.DefaultSelection<Prisma.$ModuloHistoricoPayload>
/**
 * Model PlanCuentas
 * 
 */
export type PlanCuentas = $Result.DefaultSelection<Prisma.$PlanCuentasPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlanType: {
  STARTER: 'STARTER',
  PROFESIONAL: 'PROFESIONAL',
  EMPRESARIAL: 'EMPRESARIAL'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]

}

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Empresas
 * const empresas = await prisma.empresa.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Empresas
   * const empresas = await prisma.empresa.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **Modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulo.findMany()
    * ```
    */
  get modulo(): Prisma.ModuloDelegate<ExtArgs>;

  /**
   * `prisma.empresaModulo`: Exposes CRUD operations for the **EmpresaModulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmpresaModulos
    * const empresaModulos = await prisma.empresaModulo.findMany()
    * ```
    */
  get empresaModulo(): Prisma.EmpresaModuloDelegate<ExtArgs>;

  /**
   * `prisma.moduloDependencia`: Exposes CRUD operations for the **ModuloDependencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuloDependencias
    * const moduloDependencias = await prisma.moduloDependencia.findMany()
    * ```
    */
  get moduloDependencia(): Prisma.ModuloDependenciaDelegate<ExtArgs>;

  /**
   * `prisma.moduloRuta`: Exposes CRUD operations for the **ModuloRuta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuloRutas
    * const moduloRutas = await prisma.moduloRuta.findMany()
    * ```
    */
  get moduloRuta(): Prisma.ModuloRutaDelegate<ExtArgs>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs>;

  /**
   * `prisma.moduloPermiso`: Exposes CRUD operations for the **ModuloPermiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuloPermisos
    * const moduloPermisos = await prisma.moduloPermiso.findMany()
    * ```
    */
  get moduloPermiso(): Prisma.ModuloPermisoDelegate<ExtArgs>;

  /**
   * `prisma.rolPermiso`: Exposes CRUD operations for the **RolPermiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolPermisos
    * const rolPermisos = await prisma.rolPermiso.findMany()
    * ```
    */
  get rolPermiso(): Prisma.RolPermisoDelegate<ExtArgs>;

  /**
   * `prisma.empresaConfiguracion`: Exposes CRUD operations for the **EmpresaConfiguracion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmpresaConfiguracions
    * const empresaConfiguracions = await prisma.empresaConfiguracion.findMany()
    * ```
    */
  get empresaConfiguracion(): Prisma.EmpresaConfiguracionDelegate<ExtArgs>;

  /**
   * `prisma.factura`: Exposes CRUD operations for the **Factura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facturas
    * const facturas = await prisma.factura.findMany()
    * ```
    */
  get factura(): Prisma.FacturaDelegate<ExtArgs>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.movimientoCaja`: Exposes CRUD operations for the **MovimientoCaja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovimientoCajas
    * const movimientoCajas = await prisma.movimientoCaja.findMany()
    * ```
    */
  get movimientoCaja(): Prisma.MovimientoCajaDelegate<ExtArgs>;

  /**
   * `prisma.moduloHistorico`: Exposes CRUD operations for the **ModuloHistorico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuloHistoricos
    * const moduloHistoricos = await prisma.moduloHistorico.findMany()
    * ```
    */
  get moduloHistorico(): Prisma.ModuloHistoricoDelegate<ExtArgs>;

  /**
   * `prisma.planCuentas`: Exposes CRUD operations for the **PlanCuentas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanCuentas
    * const planCuentas = await prisma.planCuentas.findMany()
    * ```
    */
  get planCuentas(): Prisma.PlanCuentasDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Empresa: 'Empresa',
    Usuario: 'Usuario',
    Modulo: 'Modulo',
    EmpresaModulo: 'EmpresaModulo',
    ModuloDependencia: 'ModuloDependencia',
    ModuloRuta: 'ModuloRuta',
    Rol: 'Rol',
    ModuloPermiso: 'ModuloPermiso',
    RolPermiso: 'RolPermiso',
    EmpresaConfiguracion: 'EmpresaConfiguracion',
    Factura: 'Factura',
    Producto: 'Producto',
    Cliente: 'Cliente',
    MovimientoCaja: 'MovimientoCaja',
    ModuloHistorico: 'ModuloHistorico',
    PlanCuentas: 'PlanCuentas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "empresa" | "usuario" | "modulo" | "empresaModulo" | "moduloDependencia" | "moduloRuta" | "rol" | "moduloPermiso" | "rolPermiso" | "empresaConfiguracion" | "factura" | "producto" | "cliente" | "movimientoCaja" | "moduloHistorico" | "planCuentas"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Modulo: {
        payload: Prisma.$ModuloPayload<ExtArgs>
        fields: Prisma.ModuloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findFirst: {
            args: Prisma.ModuloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findMany: {
            args: Prisma.ModuloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          create: {
            args: Prisma.ModuloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          createMany: {
            args: Prisma.ModuloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          delete: {
            args: Prisma.ModuloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          update: {
            args: Prisma.ModuloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          deleteMany: {
            args: Prisma.ModuloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulo>
          }
          groupBy: {
            args: Prisma.ModuloGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number
          }
        }
      }
      EmpresaModulo: {
        payload: Prisma.$EmpresaModuloPayload<ExtArgs>
        fields: Prisma.EmpresaModuloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaModuloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaModuloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          findFirst: {
            args: Prisma.EmpresaModuloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaModuloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          findMany: {
            args: Prisma.EmpresaModuloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>[]
          }
          create: {
            args: Prisma.EmpresaModuloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          createMany: {
            args: Prisma.EmpresaModuloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaModuloCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>[]
          }
          delete: {
            args: Prisma.EmpresaModuloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          update: {
            args: Prisma.EmpresaModuloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaModuloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaModuloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaModuloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaModuloPayload>
          }
          aggregate: {
            args: Prisma.EmpresaModuloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresaModulo>
          }
          groupBy: {
            args: Prisma.EmpresaModuloGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaModuloCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaModuloCountAggregateOutputType> | number
          }
        }
      }
      ModuloDependencia: {
        payload: Prisma.$ModuloDependenciaPayload<ExtArgs>
        fields: Prisma.ModuloDependenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloDependenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloDependenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          findFirst: {
            args: Prisma.ModuloDependenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloDependenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          findMany: {
            args: Prisma.ModuloDependenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>[]
          }
          create: {
            args: Prisma.ModuloDependenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          createMany: {
            args: Prisma.ModuloDependenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloDependenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>[]
          }
          delete: {
            args: Prisma.ModuloDependenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          update: {
            args: Prisma.ModuloDependenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          deleteMany: {
            args: Prisma.ModuloDependenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloDependenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloDependenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloDependenciaPayload>
          }
          aggregate: {
            args: Prisma.ModuloDependenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuloDependencia>
          }
          groupBy: {
            args: Prisma.ModuloDependenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloDependenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloDependenciaCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloDependenciaCountAggregateOutputType> | number
          }
        }
      }
      ModuloRuta: {
        payload: Prisma.$ModuloRutaPayload<ExtArgs>
        fields: Prisma.ModuloRutaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloRutaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloRutaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          findFirst: {
            args: Prisma.ModuloRutaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloRutaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          findMany: {
            args: Prisma.ModuloRutaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>[]
          }
          create: {
            args: Prisma.ModuloRutaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          createMany: {
            args: Prisma.ModuloRutaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloRutaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>[]
          }
          delete: {
            args: Prisma.ModuloRutaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          update: {
            args: Prisma.ModuloRutaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          deleteMany: {
            args: Prisma.ModuloRutaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloRutaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloRutaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloRutaPayload>
          }
          aggregate: {
            args: Prisma.ModuloRutaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuloRuta>
          }
          groupBy: {
            args: Prisma.ModuloRutaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloRutaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloRutaCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloRutaCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      ModuloPermiso: {
        payload: Prisma.$ModuloPermisoPayload<ExtArgs>
        fields: Prisma.ModuloPermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloPermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloPermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          findFirst: {
            args: Prisma.ModuloPermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloPermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          findMany: {
            args: Prisma.ModuloPermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>[]
          }
          create: {
            args: Prisma.ModuloPermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          createMany: {
            args: Prisma.ModuloPermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloPermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>[]
          }
          delete: {
            args: Prisma.ModuloPermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          update: {
            args: Prisma.ModuloPermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          deleteMany: {
            args: Prisma.ModuloPermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloPermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloPermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPermisoPayload>
          }
          aggregate: {
            args: Prisma.ModuloPermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuloPermiso>
          }
          groupBy: {
            args: Prisma.ModuloPermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloPermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloPermisoCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloPermisoCountAggregateOutputType> | number
          }
        }
      }
      RolPermiso: {
        payload: Prisma.$RolPermisoPayload<ExtArgs>
        fields: Prisma.RolPermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolPermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolPermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          findFirst: {
            args: Prisma.RolPermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolPermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          findMany: {
            args: Prisma.RolPermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>[]
          }
          create: {
            args: Prisma.RolPermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          createMany: {
            args: Prisma.RolPermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolPermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>[]
          }
          delete: {
            args: Prisma.RolPermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          update: {
            args: Prisma.RolPermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          deleteMany: {
            args: Prisma.RolPermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolPermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolPermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          aggregate: {
            args: Prisma.RolPermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolPermiso>
          }
          groupBy: {
            args: Prisma.RolPermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolPermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolPermisoCountArgs<ExtArgs>
            result: $Utils.Optional<RolPermisoCountAggregateOutputType> | number
          }
        }
      }
      EmpresaConfiguracion: {
        payload: Prisma.$EmpresaConfiguracionPayload<ExtArgs>
        fields: Prisma.EmpresaConfiguracionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaConfiguracionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaConfiguracionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          findFirst: {
            args: Prisma.EmpresaConfiguracionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaConfiguracionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          findMany: {
            args: Prisma.EmpresaConfiguracionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>[]
          }
          create: {
            args: Prisma.EmpresaConfiguracionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          createMany: {
            args: Prisma.EmpresaConfiguracionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaConfiguracionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>[]
          }
          delete: {
            args: Prisma.EmpresaConfiguracionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          update: {
            args: Prisma.EmpresaConfiguracionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaConfiguracionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaConfiguracionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaConfiguracionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaConfiguracionPayload>
          }
          aggregate: {
            args: Prisma.EmpresaConfiguracionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresaConfiguracion>
          }
          groupBy: {
            args: Prisma.EmpresaConfiguracionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaConfiguracionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaConfiguracionCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaConfiguracionCountAggregateOutputType> | number
          }
        }
      }
      Factura: {
        payload: Prisma.$FacturaPayload<ExtArgs>
        fields: Prisma.FacturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          findFirst: {
            args: Prisma.FacturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          findMany: {
            args: Prisma.FacturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>[]
          }
          create: {
            args: Prisma.FacturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          createMany: {
            args: Prisma.FacturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacturaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>[]
          }
          delete: {
            args: Prisma.FacturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          update: {
            args: Prisma.FacturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          deleteMany: {
            args: Prisma.FacturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturaPayload>
          }
          aggregate: {
            args: Prisma.FacturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactura>
          }
          groupBy: {
            args: Prisma.FacturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacturaCountArgs<ExtArgs>
            result: $Utils.Optional<FacturaCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      MovimientoCaja: {
        payload: Prisma.$MovimientoCajaPayload<ExtArgs>
        fields: Prisma.MovimientoCajaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovimientoCajaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovimientoCajaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          findFirst: {
            args: Prisma.MovimientoCajaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovimientoCajaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          findMany: {
            args: Prisma.MovimientoCajaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>[]
          }
          create: {
            args: Prisma.MovimientoCajaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          createMany: {
            args: Prisma.MovimientoCajaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovimientoCajaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>[]
          }
          delete: {
            args: Prisma.MovimientoCajaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          update: {
            args: Prisma.MovimientoCajaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          deleteMany: {
            args: Prisma.MovimientoCajaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovimientoCajaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovimientoCajaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoCajaPayload>
          }
          aggregate: {
            args: Prisma.MovimientoCajaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovimientoCaja>
          }
          groupBy: {
            args: Prisma.MovimientoCajaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovimientoCajaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovimientoCajaCountArgs<ExtArgs>
            result: $Utils.Optional<MovimientoCajaCountAggregateOutputType> | number
          }
        }
      }
      ModuloHistorico: {
        payload: Prisma.$ModuloHistoricoPayload<ExtArgs>
        fields: Prisma.ModuloHistoricoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloHistoricoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloHistoricoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          findFirst: {
            args: Prisma.ModuloHistoricoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloHistoricoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          findMany: {
            args: Prisma.ModuloHistoricoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>[]
          }
          create: {
            args: Prisma.ModuloHistoricoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          createMany: {
            args: Prisma.ModuloHistoricoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloHistoricoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>[]
          }
          delete: {
            args: Prisma.ModuloHistoricoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          update: {
            args: Prisma.ModuloHistoricoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          deleteMany: {
            args: Prisma.ModuloHistoricoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloHistoricoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloHistoricoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloHistoricoPayload>
          }
          aggregate: {
            args: Prisma.ModuloHistoricoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuloHistorico>
          }
          groupBy: {
            args: Prisma.ModuloHistoricoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloHistoricoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloHistoricoCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloHistoricoCountAggregateOutputType> | number
          }
        }
      }
      PlanCuentas: {
        payload: Prisma.$PlanCuentasPayload<ExtArgs>
        fields: Prisma.PlanCuentasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanCuentasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanCuentasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          findFirst: {
            args: Prisma.PlanCuentasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanCuentasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          findMany: {
            args: Prisma.PlanCuentasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>[]
          }
          create: {
            args: Prisma.PlanCuentasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          createMany: {
            args: Prisma.PlanCuentasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCuentasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>[]
          }
          delete: {
            args: Prisma.PlanCuentasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          update: {
            args: Prisma.PlanCuentasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          deleteMany: {
            args: Prisma.PlanCuentasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanCuentasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanCuentasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanCuentasPayload>
          }
          aggregate: {
            args: Prisma.PlanCuentasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanCuentas>
          }
          groupBy: {
            args: Prisma.PlanCuentasGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanCuentasGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCuentasCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCuentasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    clientes: number
    configuraciones: number
    modulosActivos: number
    moduloHistorico: number
    facturas: number
    movimientosCaja: number
    productos: number
    usuarios: number
    planCuentas: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientes?: boolean | EmpresaCountOutputTypeCountClientesArgs
    configuraciones?: boolean | EmpresaCountOutputTypeCountConfiguracionesArgs
    modulosActivos?: boolean | EmpresaCountOutputTypeCountModulosActivosArgs
    moduloHistorico?: boolean | EmpresaCountOutputTypeCountModuloHistoricoArgs
    facturas?: boolean | EmpresaCountOutputTypeCountFacturasArgs
    movimientosCaja?: boolean | EmpresaCountOutputTypeCountMovimientosCajaArgs
    productos?: boolean | EmpresaCountOutputTypeCountProductosArgs
    usuarios?: boolean | EmpresaCountOutputTypeCountUsuariosArgs
    planCuentas?: boolean | EmpresaCountOutputTypeCountPlanCuentasArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountConfiguracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaConfiguracionWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountModulosActivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaModuloWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountModuloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloHistoricoWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountFacturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacturaWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountMovimientosCajaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoCajaWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountPlanCuentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanCuentasWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    moduloHistorico: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moduloHistorico?: boolean | UsuarioCountOutputTypeCountModuloHistoricoArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountModuloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloHistoricoWhereInput
  }


  /**
   * Count Type ModuloCountOutputType
   */

  export type ModuloCountOutputType = {
    empresasConModulo: number
    moduloHistorico: number
    esDependenciaDe: number
    dependeDe: number
    permisos: number
    rutas: number
  }

  export type ModuloCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresasConModulo?: boolean | ModuloCountOutputTypeCountEmpresasConModuloArgs
    moduloHistorico?: boolean | ModuloCountOutputTypeCountModuloHistoricoArgs
    esDependenciaDe?: boolean | ModuloCountOutputTypeCountEsDependenciaDeArgs
    dependeDe?: boolean | ModuloCountOutputTypeCountDependeDeArgs
    permisos?: boolean | ModuloCountOutputTypeCountPermisosArgs
    rutas?: boolean | ModuloCountOutputTypeCountRutasArgs
  }

  // Custom InputTypes
  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloCountOutputType
     */
    select?: ModuloCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountEmpresasConModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaModuloWhereInput
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountModuloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloHistoricoWhereInput
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountEsDependenciaDeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloDependenciaWhereInput
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountDependeDeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloDependenciaWhereInput
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloPermisoWhereInput
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountRutasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloRutaWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    permisos: number
    usuarios: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permisos?: boolean | RolCountOutputTypeCountPermisosArgs
    usuarios?: boolean | RolCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type ModuloPermisoCountOutputType
   */

  export type ModuloPermisoCountOutputType = {
    roles: number
  }

  export type ModuloPermisoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | ModuloPermisoCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * ModuloPermisoCountOutputType without action
   */
  export type ModuloPermisoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermisoCountOutputType
     */
    select?: ModuloPermisoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuloPermisoCountOutputType without action
   */
  export type ModuloPermisoCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    ruc: string | null
    activo: boolean | null
    direccion: string | null
    email: string | null
    fechaActualizacion: Date | null
    fechaCreacion: Date | null
    telefono: string | null
    plan: $Enums.PlanType | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    ruc: string | null
    activo: boolean | null
    direccion: string | null
    email: string | null
    fechaActualizacion: Date | null
    fechaCreacion: Date | null
    telefono: string | null
    plan: $Enums.PlanType | null
  }

  export type EmpresaCountAggregateOutputType = {
    id: number
    nombre: number
    ruc: number
    activo: number
    direccion: number
    email: number
    fechaActualizacion: number
    fechaCreacion: number
    telefono: number
    plan: number
    _all: number
  }


  export type EmpresaMinAggregateInputType = {
    id?: true
    nombre?: true
    ruc?: true
    activo?: true
    direccion?: true
    email?: true
    fechaActualizacion?: true
    fechaCreacion?: true
    telefono?: true
    plan?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id?: true
    nombre?: true
    ruc?: true
    activo?: true
    direccion?: true
    email?: true
    fechaActualizacion?: true
    fechaCreacion?: true
    telefono?: true
    plan?: true
  }

  export type EmpresaCountAggregateInputType = {
    id?: true
    nombre?: true
    ruc?: true
    activo?: true
    direccion?: true
    email?: true
    fechaActualizacion?: true
    fechaCreacion?: true
    telefono?: true
    plan?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id: string
    nombre: string
    ruc: string
    activo: boolean
    direccion: string | null
    email: string | null
    fechaActualizacion: Date
    fechaCreacion: Date
    telefono: string | null
    plan: $Enums.PlanType
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ruc?: boolean
    activo?: boolean
    direccion?: boolean
    email?: boolean
    fechaActualizacion?: boolean
    fechaCreacion?: boolean
    telefono?: boolean
    plan?: boolean
    clientes?: boolean | Empresa$clientesArgs<ExtArgs>
    configuraciones?: boolean | Empresa$configuracionesArgs<ExtArgs>
    modulosActivos?: boolean | Empresa$modulosActivosArgs<ExtArgs>
    moduloHistorico?: boolean | Empresa$moduloHistoricoArgs<ExtArgs>
    facturas?: boolean | Empresa$facturasArgs<ExtArgs>
    movimientosCaja?: boolean | Empresa$movimientosCajaArgs<ExtArgs>
    productos?: boolean | Empresa$productosArgs<ExtArgs>
    usuarios?: boolean | Empresa$usuariosArgs<ExtArgs>
    planCuentas?: boolean | Empresa$planCuentasArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ruc?: boolean
    activo?: boolean
    direccion?: boolean
    email?: boolean
    fechaActualizacion?: boolean
    fechaCreacion?: boolean
    telefono?: boolean
    plan?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectScalar = {
    id?: boolean
    nombre?: boolean
    ruc?: boolean
    activo?: boolean
    direccion?: boolean
    email?: boolean
    fechaActualizacion?: boolean
    fechaCreacion?: boolean
    telefono?: boolean
    plan?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientes?: boolean | Empresa$clientesArgs<ExtArgs>
    configuraciones?: boolean | Empresa$configuracionesArgs<ExtArgs>
    modulosActivos?: boolean | Empresa$modulosActivosArgs<ExtArgs>
    moduloHistorico?: boolean | Empresa$moduloHistoricoArgs<ExtArgs>
    facturas?: boolean | Empresa$facturasArgs<ExtArgs>
    movimientosCaja?: boolean | Empresa$movimientosCajaArgs<ExtArgs>
    productos?: boolean | Empresa$productosArgs<ExtArgs>
    usuarios?: boolean | Empresa$usuariosArgs<ExtArgs>
    planCuentas?: boolean | Empresa$planCuentasArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmpresaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      clientes: Prisma.$ClientePayload<ExtArgs>[]
      configuraciones: Prisma.$EmpresaConfiguracionPayload<ExtArgs>[]
      modulosActivos: Prisma.$EmpresaModuloPayload<ExtArgs>[]
      moduloHistorico: Prisma.$ModuloHistoricoPayload<ExtArgs>[]
      facturas: Prisma.$FacturaPayload<ExtArgs>[]
      movimientosCaja: Prisma.$MovimientoCajaPayload<ExtArgs>[]
      productos: Prisma.$ProductoPayload<ExtArgs>[]
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
      planCuentas: Prisma.$PlanCuentasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      ruc: string
      activo: boolean
      direccion: string | null
      email: string | null
      fechaActualizacion: Date
      fechaCreacion: Date
      telefono: string | null
      plan: $Enums.PlanType
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaWithIdOnly = await prisma.empresa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {EmpresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empresas and only return the `id`
     * const empresaWithIdOnly = await prisma.empresa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientes<T extends Empresa$clientesArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$clientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany"> | Null>
    configuraciones<T extends Empresa$configuracionesArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$configuracionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findMany"> | Null>
    modulosActivos<T extends Empresa$modulosActivosArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$modulosActivosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findMany"> | Null>
    moduloHistorico<T extends Empresa$moduloHistoricoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$moduloHistoricoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findMany"> | Null>
    facturas<T extends Empresa$facturasArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$facturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findMany"> | Null>
    movimientosCaja<T extends Empresa$movimientosCajaArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$movimientosCajaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findMany"> | Null>
    productos<T extends Empresa$productosArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends Empresa$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    planCuentas<T extends Empresa$planCuentasArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$planCuentasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id: FieldRef<"Empresa", 'String'>
    readonly nombre: FieldRef<"Empresa", 'String'>
    readonly ruc: FieldRef<"Empresa", 'String'>
    readonly activo: FieldRef<"Empresa", 'Boolean'>
    readonly direccion: FieldRef<"Empresa", 'String'>
    readonly email: FieldRef<"Empresa", 'String'>
    readonly fechaActualizacion: FieldRef<"Empresa", 'DateTime'>
    readonly fechaCreacion: FieldRef<"Empresa", 'DateTime'>
    readonly telefono: FieldRef<"Empresa", 'String'>
    readonly plan: FieldRef<"Empresa", 'PlanType'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa createManyAndReturn
   */
  export type EmpresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.clientes
   */
  export type Empresa$clientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    cursor?: ClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Empresa.configuraciones
   */
  export type Empresa$configuracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    where?: EmpresaConfiguracionWhereInput
    orderBy?: EmpresaConfiguracionOrderByWithRelationInput | EmpresaConfiguracionOrderByWithRelationInput[]
    cursor?: EmpresaConfiguracionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaConfiguracionScalarFieldEnum | EmpresaConfiguracionScalarFieldEnum[]
  }

  /**
   * Empresa.modulosActivos
   */
  export type Empresa$modulosActivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    where?: EmpresaModuloWhereInput
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    cursor?: EmpresaModuloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaModuloScalarFieldEnum | EmpresaModuloScalarFieldEnum[]
  }

  /**
   * Empresa.moduloHistorico
   */
  export type Empresa$moduloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    where?: ModuloHistoricoWhereInput
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    cursor?: ModuloHistoricoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * Empresa.facturas
   */
  export type Empresa$facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    where?: FacturaWhereInput
    orderBy?: FacturaOrderByWithRelationInput | FacturaOrderByWithRelationInput[]
    cursor?: FacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * Empresa.movimientosCaja
   */
  export type Empresa$movimientosCajaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    where?: MovimientoCajaWhereInput
    orderBy?: MovimientoCajaOrderByWithRelationInput | MovimientoCajaOrderByWithRelationInput[]
    cursor?: MovimientoCajaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovimientoCajaScalarFieldEnum | MovimientoCajaScalarFieldEnum[]
  }

  /**
   * Empresa.productos
   */
  export type Empresa$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Empresa.usuarios
   */
  export type Empresa$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Empresa.planCuentas
   */
  export type Empresa$planCuentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    where?: PlanCuentasWhereInput
    orderBy?: PlanCuentasOrderByWithRelationInput | PlanCuentasOrderByWithRelationInput[]
    cursor?: PlanCuentasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanCuentasScalarFieldEnum | PlanCuentasScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    email: string | null
    nombre: string | null
    apellido: string | null
    password: string | null
    empresaId: string | null
    rolId: string | null
    activo: boolean | null
    resetToken: string | null
    resetTokenExpires: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    email: string | null
    nombre: string | null
    apellido: string | null
    password: string | null
    empresaId: string | null
    rolId: string | null
    activo: boolean | null
    resetToken: string | null
    resetTokenExpires: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    email: number
    nombre: number
    apellido: number
    password: number
    empresaId: number
    rolId: number
    activo: number
    resetToken: number
    resetTokenExpires: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    email?: true
    nombre?: true
    apellido?: true
    password?: true
    empresaId?: true
    rolId?: true
    activo?: true
    resetToken?: true
    resetTokenExpires?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    email?: true
    nombre?: true
    apellido?: true
    password?: true
    empresaId?: true
    rolId?: true
    activo?: true
    resetToken?: true
    resetTokenExpires?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    email?: true
    nombre?: true
    apellido?: true
    password?: true
    empresaId?: true
    rolId?: true
    activo?: true
    resetToken?: true
    resetTokenExpires?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    email: string
    nombre: string
    apellido: string | null
    password: string
    empresaId: string
    rolId: string
    activo: boolean
    resetToken: string | null
    resetTokenExpires: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nombre?: boolean
    apellido?: boolean
    password?: boolean
    empresaId?: boolean
    rolId?: boolean
    activo?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
    moduloHistorico?: boolean | Usuario$moduloHistoricoArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nombre?: boolean
    apellido?: boolean
    password?: boolean
    empresaId?: boolean
    rolId?: boolean
    activo?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    email?: boolean
    nombre?: boolean
    apellido?: boolean
    password?: boolean
    empresaId?: boolean
    rolId?: boolean
    activo?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
    moduloHistorico?: boolean | Usuario$moduloHistoricoArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      rol: Prisma.$RolPayload<ExtArgs>
      moduloHistorico: Prisma.$ModuloHistoricoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      nombre: string
      apellido: string | null
      password: string
      empresaId: string
      rolId: string
      activo: boolean
      resetToken: string | null
      resetTokenExpires: Date | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    moduloHistorico<T extends Usuario$moduloHistoricoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$moduloHistoricoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellido: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly empresaId: FieldRef<"Usuario", 'String'>
    readonly rolId: FieldRef<"Usuario", 'String'>
    readonly activo: FieldRef<"Usuario", 'Boolean'>
    readonly resetToken: FieldRef<"Usuario", 'String'>
    readonly resetTokenExpires: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.moduloHistorico
   */
  export type Usuario$moduloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    where?: ModuloHistoricoWhereInput
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    cursor?: ModuloHistoricoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  export type ModuloAvgAggregateOutputType = {
    orden: number | null
  }

  export type ModuloSumAggregateOutputType = {
    orden: number | null
  }

  export type ModuloMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    displayName: string | null
    version: string | null
    activo: boolean | null
    color: string | null
    descripcion: string | null
    icono: string | null
    orden: number | null
  }

  export type ModuloMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    displayName: string | null
    version: string | null
    activo: boolean | null
    color: string | null
    descripcion: string | null
    icono: string | null
    orden: number | null
  }

  export type ModuloCountAggregateOutputType = {
    id: number
    nombre: number
    displayName: number
    version: number
    activo: number
    color: number
    descripcion: number
    icono: number
    orden: number
    _all: number
  }


  export type ModuloAvgAggregateInputType = {
    orden?: true
  }

  export type ModuloSumAggregateInputType = {
    orden?: true
  }

  export type ModuloMinAggregateInputType = {
    id?: true
    nombre?: true
    displayName?: true
    version?: true
    activo?: true
    color?: true
    descripcion?: true
    icono?: true
    orden?: true
  }

  export type ModuloMaxAggregateInputType = {
    id?: true
    nombre?: true
    displayName?: true
    version?: true
    activo?: true
    color?: true
    descripcion?: true
    icono?: true
    orden?: true
  }

  export type ModuloCountAggregateInputType = {
    id?: true
    nombre?: true
    displayName?: true
    version?: true
    activo?: true
    color?: true
    descripcion?: true
    icono?: true
    orden?: true
    _all?: true
  }

  export type ModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulo to aggregate.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modulos
    **/
    _count?: true | ModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloMaxAggregateInputType
  }

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>
  }




  export type ModuloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloWhereInput
    orderBy?: ModuloOrderByWithAggregationInput | ModuloOrderByWithAggregationInput[]
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum
    having?: ModuloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloCountAggregateInputType | true
    _avg?: ModuloAvgAggregateInputType
    _sum?: ModuloSumAggregateInputType
    _min?: ModuloMinAggregateInputType
    _max?: ModuloMaxAggregateInputType
  }

  export type ModuloGroupByOutputType = {
    id: string
    nombre: string
    displayName: string
    version: string
    activo: boolean
    color: string | null
    descripcion: string | null
    icono: string | null
    orden: number
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  type GetModuloGroupByPayload<T extends ModuloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>
        }
      >
    >


  export type ModuloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    displayName?: boolean
    version?: boolean
    activo?: boolean
    color?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
    empresasConModulo?: boolean | Modulo$empresasConModuloArgs<ExtArgs>
    moduloHistorico?: boolean | Modulo$moduloHistoricoArgs<ExtArgs>
    esDependenciaDe?: boolean | Modulo$esDependenciaDeArgs<ExtArgs>
    dependeDe?: boolean | Modulo$dependeDeArgs<ExtArgs>
    permisos?: boolean | Modulo$permisosArgs<ExtArgs>
    rutas?: boolean | Modulo$rutasArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    displayName?: boolean
    version?: boolean
    activo?: boolean
    color?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectScalar = {
    id?: boolean
    nombre?: boolean
    displayName?: boolean
    version?: boolean
    activo?: boolean
    color?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
  }

  export type ModuloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresasConModulo?: boolean | Modulo$empresasConModuloArgs<ExtArgs>
    moduloHistorico?: boolean | Modulo$moduloHistoricoArgs<ExtArgs>
    esDependenciaDe?: boolean | Modulo$esDependenciaDeArgs<ExtArgs>
    dependeDe?: boolean | Modulo$dependeDeArgs<ExtArgs>
    permisos?: boolean | Modulo$permisosArgs<ExtArgs>
    rutas?: boolean | Modulo$rutasArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuloIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModuloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Modulo"
    objects: {
      empresasConModulo: Prisma.$EmpresaModuloPayload<ExtArgs>[]
      moduloHistorico: Prisma.$ModuloHistoricoPayload<ExtArgs>[]
      esDependenciaDe: Prisma.$ModuloDependenciaPayload<ExtArgs>[]
      dependeDe: Prisma.$ModuloDependenciaPayload<ExtArgs>[]
      permisos: Prisma.$ModuloPermisoPayload<ExtArgs>[]
      rutas: Prisma.$ModuloRutaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      displayName: string
      version: string
      activo: boolean
      color: string | null
      descripcion: string | null
      icono: string | null
      orden: number
    }, ExtArgs["result"]["modulo"]>
    composites: {}
  }

  type ModuloGetPayload<S extends boolean | null | undefined | ModuloDefaultArgs> = $Result.GetResult<Prisma.$ModuloPayload, S>

  type ModuloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloCountAggregateInputType | true
    }

  export interface ModuloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Modulo'], meta: { name: 'Modulo' } }
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {ModuloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloFindUniqueArgs>(args: SelectSubset<T, ModuloFindUniqueArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Modulo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloFindFirstArgs>(args?: SelectSubset<T, ModuloFindFirstArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloWithIdOnly = await prisma.modulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloFindManyArgs>(args?: SelectSubset<T, ModuloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Modulo.
     * @param {ModuloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     * 
     */
    create<T extends ModuloCreateArgs>(args: SelectSubset<T, ModuloCreateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modulos.
     * @param {ModuloCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloCreateManyArgs>(args?: SelectSubset<T, ModuloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modulos and returns the data saved in the database.
     * @param {ModuloCreateManyAndReturnArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modulos and only return the `id`
     * const moduloWithIdOnly = await prisma.modulo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Modulo.
     * @param {ModuloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     * 
     */
    delete<T extends ModuloDeleteArgs>(args: SelectSubset<T, ModuloDeleteArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Modulo.
     * @param {ModuloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloUpdateArgs>(args: SelectSubset<T, ModuloUpdateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modulos.
     * @param {ModuloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloDeleteManyArgs>(args?: SelectSubset<T, ModuloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloUpdateManyArgs>(args: SelectSubset<T, ModuloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulo.
     * @param {ModuloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
     */
    upsert<T extends ModuloUpsertArgs>(args: SelectSubset<T, ModuloUpsertArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends ModuloCountArgs>(
      args?: Subset<T, ModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloAggregateArgs>(args: Subset<T, ModuloAggregateArgs>): Prisma.PrismaPromise<GetModuloAggregateType<T>>

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloGroupByArgs['orderBy'] }
        : { orderBy?: ModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Modulo model
   */
  readonly fields: ModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresasConModulo<T extends Modulo$empresasConModuloArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$empresasConModuloArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findMany"> | Null>
    moduloHistorico<T extends Modulo$moduloHistoricoArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$moduloHistoricoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findMany"> | Null>
    esDependenciaDe<T extends Modulo$esDependenciaDeArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$esDependenciaDeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findMany"> | Null>
    dependeDe<T extends Modulo$dependeDeArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$dependeDeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findMany"> | Null>
    permisos<T extends Modulo$permisosArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$permisosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findMany"> | Null>
    rutas<T extends Modulo$rutasArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$rutasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Modulo model
   */ 
  interface ModuloFieldRefs {
    readonly id: FieldRef<"Modulo", 'String'>
    readonly nombre: FieldRef<"Modulo", 'String'>
    readonly displayName: FieldRef<"Modulo", 'String'>
    readonly version: FieldRef<"Modulo", 'String'>
    readonly activo: FieldRef<"Modulo", 'Boolean'>
    readonly color: FieldRef<"Modulo", 'String'>
    readonly descripcion: FieldRef<"Modulo", 'String'>
    readonly icono: FieldRef<"Modulo", 'String'>
    readonly orden: FieldRef<"Modulo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Modulo findUnique
   */
  export type ModuloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findUniqueOrThrow
   */
  export type ModuloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findFirst
   */
  export type ModuloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findFirstOrThrow
   */
  export type ModuloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findMany
   */
  export type ModuloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulos to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo create
   */
  export type ModuloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The data needed to create a Modulo.
     */
    data: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
  }

  /**
   * Modulo createMany
   */
  export type ModuloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modulo createManyAndReturn
   */
  export type ModuloCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modulo update
   */
  export type ModuloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The data needed to update a Modulo.
     */
    data: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
    /**
     * Choose, which Modulo to update.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo updateMany
   */
  export type ModuloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modulos.
     */
    data: XOR<ModuloUpdateManyMutationInput, ModuloUncheckedUpdateManyInput>
    /**
     * Filter which Modulos to update
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo upsert
   */
  export type ModuloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The filter to search for the Modulo to update in case it exists.
     */
    where: ModuloWhereUniqueInput
    /**
     * In case the Modulo found by the `where` argument doesn't exist, create a new Modulo with this data.
     */
    create: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
    /**
     * In case the Modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
  }

  /**
   * Modulo delete
   */
  export type ModuloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter which Modulo to delete.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo deleteMany
   */
  export type ModuloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulos to delete
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo.empresasConModulo
   */
  export type Modulo$empresasConModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    where?: EmpresaModuloWhereInput
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    cursor?: EmpresaModuloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaModuloScalarFieldEnum | EmpresaModuloScalarFieldEnum[]
  }

  /**
   * Modulo.moduloHistorico
   */
  export type Modulo$moduloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    where?: ModuloHistoricoWhereInput
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    cursor?: ModuloHistoricoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * Modulo.esDependenciaDe
   */
  export type Modulo$esDependenciaDeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    where?: ModuloDependenciaWhereInput
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    cursor?: ModuloDependenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloDependenciaScalarFieldEnum | ModuloDependenciaScalarFieldEnum[]
  }

  /**
   * Modulo.dependeDe
   */
  export type Modulo$dependeDeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    where?: ModuloDependenciaWhereInput
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    cursor?: ModuloDependenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloDependenciaScalarFieldEnum | ModuloDependenciaScalarFieldEnum[]
  }

  /**
   * Modulo.permisos
   */
  export type Modulo$permisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    where?: ModuloPermisoWhereInput
    orderBy?: ModuloPermisoOrderByWithRelationInput | ModuloPermisoOrderByWithRelationInput[]
    cursor?: ModuloPermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloPermisoScalarFieldEnum | ModuloPermisoScalarFieldEnum[]
  }

  /**
   * Modulo.rutas
   */
  export type Modulo$rutasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    where?: ModuloRutaWhereInput
    orderBy?: ModuloRutaOrderByWithRelationInput | ModuloRutaOrderByWithRelationInput[]
    cursor?: ModuloRutaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuloRutaScalarFieldEnum | ModuloRutaScalarFieldEnum[]
  }

  /**
   * Modulo without action
   */
  export type ModuloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
  }


  /**
   * Model EmpresaModulo
   */

  export type AggregateEmpresaModulo = {
    _count: EmpresaModuloCountAggregateOutputType | null
    _min: EmpresaModuloMinAggregateOutputType | null
    _max: EmpresaModuloMaxAggregateOutputType | null
  }

  export type EmpresaModuloMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    moduloId: string | null
    activo: boolean | null
    fechaActivacion: Date | null
    fechaDesactivacion: Date | null
  }

  export type EmpresaModuloMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    moduloId: string | null
    activo: boolean | null
    fechaActivacion: Date | null
    fechaDesactivacion: Date | null
  }

  export type EmpresaModuloCountAggregateOutputType = {
    id: number
    empresaId: number
    moduloId: number
    activo: number
    configuracion: number
    fechaActivacion: number
    fechaDesactivacion: number
    _all: number
  }


  export type EmpresaModuloMinAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    activo?: true
    fechaActivacion?: true
    fechaDesactivacion?: true
  }

  export type EmpresaModuloMaxAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    activo?: true
    fechaActivacion?: true
    fechaDesactivacion?: true
  }

  export type EmpresaModuloCountAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    activo?: true
    configuracion?: true
    fechaActivacion?: true
    fechaDesactivacion?: true
    _all?: true
  }

  export type EmpresaModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpresaModulo to aggregate.
     */
    where?: EmpresaModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaModulos to fetch.
     */
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaModulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaModulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmpresaModulos
    **/
    _count?: true | EmpresaModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaModuloMaxAggregateInputType
  }

  export type GetEmpresaModuloAggregateType<T extends EmpresaModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresaModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresaModulo[P]>
      : GetScalarType<T[P], AggregateEmpresaModulo[P]>
  }




  export type EmpresaModuloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaModuloWhereInput
    orderBy?: EmpresaModuloOrderByWithAggregationInput | EmpresaModuloOrderByWithAggregationInput[]
    by: EmpresaModuloScalarFieldEnum[] | EmpresaModuloScalarFieldEnum
    having?: EmpresaModuloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaModuloCountAggregateInputType | true
    _min?: EmpresaModuloMinAggregateInputType
    _max?: EmpresaModuloMaxAggregateInputType
  }

  export type EmpresaModuloGroupByOutputType = {
    id: string
    empresaId: string
    moduloId: string
    activo: boolean
    configuracion: JsonValue | null
    fechaActivacion: Date
    fechaDesactivacion: Date | null
    _count: EmpresaModuloCountAggregateOutputType | null
    _min: EmpresaModuloMinAggregateOutputType | null
    _max: EmpresaModuloMaxAggregateOutputType | null
  }

  type GetEmpresaModuloGroupByPayload<T extends EmpresaModuloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaModuloGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaModuloGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaModuloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    activo?: boolean
    configuracion?: boolean
    fechaActivacion?: boolean
    fechaDesactivacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresaModulo"]>

  export type EmpresaModuloSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    activo?: boolean
    configuracion?: boolean
    fechaActivacion?: boolean
    fechaDesactivacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresaModulo"]>

  export type EmpresaModuloSelectScalar = {
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    activo?: boolean
    configuracion?: boolean
    fechaActivacion?: boolean
    fechaDesactivacion?: boolean
  }

  export type EmpresaModuloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }
  export type EmpresaModuloIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }

  export type $EmpresaModuloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmpresaModulo"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      modulo: Prisma.$ModuloPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      moduloId: string
      activo: boolean
      configuracion: Prisma.JsonValue | null
      fechaActivacion: Date
      fechaDesactivacion: Date | null
    }, ExtArgs["result"]["empresaModulo"]>
    composites: {}
  }

  type EmpresaModuloGetPayload<S extends boolean | null | undefined | EmpresaModuloDefaultArgs> = $Result.GetResult<Prisma.$EmpresaModuloPayload, S>

  type EmpresaModuloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaModuloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaModuloCountAggregateInputType | true
    }

  export interface EmpresaModuloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmpresaModulo'], meta: { name: 'EmpresaModulo' } }
    /**
     * Find zero or one EmpresaModulo that matches the filter.
     * @param {EmpresaModuloFindUniqueArgs} args - Arguments to find a EmpresaModulo
     * @example
     * // Get one EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaModuloFindUniqueArgs>(args: SelectSubset<T, EmpresaModuloFindUniqueArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmpresaModulo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaModuloFindUniqueOrThrowArgs} args - Arguments to find a EmpresaModulo
     * @example
     * // Get one EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaModuloFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaModuloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmpresaModulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloFindFirstArgs} args - Arguments to find a EmpresaModulo
     * @example
     * // Get one EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaModuloFindFirstArgs>(args?: SelectSubset<T, EmpresaModuloFindFirstArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmpresaModulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloFindFirstOrThrowArgs} args - Arguments to find a EmpresaModulo
     * @example
     * // Get one EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaModuloFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaModuloFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmpresaModulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmpresaModulos
     * const empresaModulos = await prisma.empresaModulo.findMany()
     * 
     * // Get first 10 EmpresaModulos
     * const empresaModulos = await prisma.empresaModulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaModuloWithIdOnly = await prisma.empresaModulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaModuloFindManyArgs>(args?: SelectSubset<T, EmpresaModuloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmpresaModulo.
     * @param {EmpresaModuloCreateArgs} args - Arguments to create a EmpresaModulo.
     * @example
     * // Create one EmpresaModulo
     * const EmpresaModulo = await prisma.empresaModulo.create({
     *   data: {
     *     // ... data to create a EmpresaModulo
     *   }
     * })
     * 
     */
    create<T extends EmpresaModuloCreateArgs>(args: SelectSubset<T, EmpresaModuloCreateArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmpresaModulos.
     * @param {EmpresaModuloCreateManyArgs} args - Arguments to create many EmpresaModulos.
     * @example
     * // Create many EmpresaModulos
     * const empresaModulo = await prisma.empresaModulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaModuloCreateManyArgs>(args?: SelectSubset<T, EmpresaModuloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmpresaModulos and returns the data saved in the database.
     * @param {EmpresaModuloCreateManyAndReturnArgs} args - Arguments to create many EmpresaModulos.
     * @example
     * // Create many EmpresaModulos
     * const empresaModulo = await prisma.empresaModulo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmpresaModulos and only return the `id`
     * const empresaModuloWithIdOnly = await prisma.empresaModulo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaModuloCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaModuloCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmpresaModulo.
     * @param {EmpresaModuloDeleteArgs} args - Arguments to delete one EmpresaModulo.
     * @example
     * // Delete one EmpresaModulo
     * const EmpresaModulo = await prisma.empresaModulo.delete({
     *   where: {
     *     // ... filter to delete one EmpresaModulo
     *   }
     * })
     * 
     */
    delete<T extends EmpresaModuloDeleteArgs>(args: SelectSubset<T, EmpresaModuloDeleteArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmpresaModulo.
     * @param {EmpresaModuloUpdateArgs} args - Arguments to update one EmpresaModulo.
     * @example
     * // Update one EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaModuloUpdateArgs>(args: SelectSubset<T, EmpresaModuloUpdateArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmpresaModulos.
     * @param {EmpresaModuloDeleteManyArgs} args - Arguments to filter EmpresaModulos to delete.
     * @example
     * // Delete a few EmpresaModulos
     * const { count } = await prisma.empresaModulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaModuloDeleteManyArgs>(args?: SelectSubset<T, EmpresaModuloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmpresaModulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmpresaModulos
     * const empresaModulo = await prisma.empresaModulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaModuloUpdateManyArgs>(args: SelectSubset<T, EmpresaModuloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmpresaModulo.
     * @param {EmpresaModuloUpsertArgs} args - Arguments to update or create a EmpresaModulo.
     * @example
     * // Update or create a EmpresaModulo
     * const empresaModulo = await prisma.empresaModulo.upsert({
     *   create: {
     *     // ... data to create a EmpresaModulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmpresaModulo we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaModuloUpsertArgs>(args: SelectSubset<T, EmpresaModuloUpsertArgs<ExtArgs>>): Prisma__EmpresaModuloClient<$Result.GetResult<Prisma.$EmpresaModuloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmpresaModulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloCountArgs} args - Arguments to filter EmpresaModulos to count.
     * @example
     * // Count the number of EmpresaModulos
     * const count = await prisma.empresaModulo.count({
     *   where: {
     *     // ... the filter for the EmpresaModulos we want to count
     *   }
     * })
    **/
    count<T extends EmpresaModuloCountArgs>(
      args?: Subset<T, EmpresaModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmpresaModulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaModuloAggregateArgs>(args: Subset<T, EmpresaModuloAggregateArgs>): Prisma.PrismaPromise<GetEmpresaModuloAggregateType<T>>

    /**
     * Group by EmpresaModulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaModuloGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaModuloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmpresaModulo model
   */
  readonly fields: EmpresaModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmpresaModulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaModuloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmpresaModulo model
   */ 
  interface EmpresaModuloFieldRefs {
    readonly id: FieldRef<"EmpresaModulo", 'String'>
    readonly empresaId: FieldRef<"EmpresaModulo", 'String'>
    readonly moduloId: FieldRef<"EmpresaModulo", 'String'>
    readonly activo: FieldRef<"EmpresaModulo", 'Boolean'>
    readonly configuracion: FieldRef<"EmpresaModulo", 'Json'>
    readonly fechaActivacion: FieldRef<"EmpresaModulo", 'DateTime'>
    readonly fechaDesactivacion: FieldRef<"EmpresaModulo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmpresaModulo findUnique
   */
  export type EmpresaModuloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaModulo to fetch.
     */
    where: EmpresaModuloWhereUniqueInput
  }

  /**
   * EmpresaModulo findUniqueOrThrow
   */
  export type EmpresaModuloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaModulo to fetch.
     */
    where: EmpresaModuloWhereUniqueInput
  }

  /**
   * EmpresaModulo findFirst
   */
  export type EmpresaModuloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaModulo to fetch.
     */
    where?: EmpresaModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaModulos to fetch.
     */
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpresaModulos.
     */
    cursor?: EmpresaModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaModulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaModulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpresaModulos.
     */
    distinct?: EmpresaModuloScalarFieldEnum | EmpresaModuloScalarFieldEnum[]
  }

  /**
   * EmpresaModulo findFirstOrThrow
   */
  export type EmpresaModuloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaModulo to fetch.
     */
    where?: EmpresaModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaModulos to fetch.
     */
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpresaModulos.
     */
    cursor?: EmpresaModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaModulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaModulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpresaModulos.
     */
    distinct?: EmpresaModuloScalarFieldEnum | EmpresaModuloScalarFieldEnum[]
  }

  /**
   * EmpresaModulo findMany
   */
  export type EmpresaModuloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaModulos to fetch.
     */
    where?: EmpresaModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaModulos to fetch.
     */
    orderBy?: EmpresaModuloOrderByWithRelationInput | EmpresaModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmpresaModulos.
     */
    cursor?: EmpresaModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaModulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaModulos.
     */
    skip?: number
    distinct?: EmpresaModuloScalarFieldEnum | EmpresaModuloScalarFieldEnum[]
  }

  /**
   * EmpresaModulo create
   */
  export type EmpresaModuloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * The data needed to create a EmpresaModulo.
     */
    data: XOR<EmpresaModuloCreateInput, EmpresaModuloUncheckedCreateInput>
  }

  /**
   * EmpresaModulo createMany
   */
  export type EmpresaModuloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmpresaModulos.
     */
    data: EmpresaModuloCreateManyInput | EmpresaModuloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmpresaModulo createManyAndReturn
   */
  export type EmpresaModuloCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmpresaModulos.
     */
    data: EmpresaModuloCreateManyInput | EmpresaModuloCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmpresaModulo update
   */
  export type EmpresaModuloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * The data needed to update a EmpresaModulo.
     */
    data: XOR<EmpresaModuloUpdateInput, EmpresaModuloUncheckedUpdateInput>
    /**
     * Choose, which EmpresaModulo to update.
     */
    where: EmpresaModuloWhereUniqueInput
  }

  /**
   * EmpresaModulo updateMany
   */
  export type EmpresaModuloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmpresaModulos.
     */
    data: XOR<EmpresaModuloUpdateManyMutationInput, EmpresaModuloUncheckedUpdateManyInput>
    /**
     * Filter which EmpresaModulos to update
     */
    where?: EmpresaModuloWhereInput
  }

  /**
   * EmpresaModulo upsert
   */
  export type EmpresaModuloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * The filter to search for the EmpresaModulo to update in case it exists.
     */
    where: EmpresaModuloWhereUniqueInput
    /**
     * In case the EmpresaModulo found by the `where` argument doesn't exist, create a new EmpresaModulo with this data.
     */
    create: XOR<EmpresaModuloCreateInput, EmpresaModuloUncheckedCreateInput>
    /**
     * In case the EmpresaModulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaModuloUpdateInput, EmpresaModuloUncheckedUpdateInput>
  }

  /**
   * EmpresaModulo delete
   */
  export type EmpresaModuloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
    /**
     * Filter which EmpresaModulo to delete.
     */
    where: EmpresaModuloWhereUniqueInput
  }

  /**
   * EmpresaModulo deleteMany
   */
  export type EmpresaModuloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpresaModulos to delete
     */
    where?: EmpresaModuloWhereInput
  }

  /**
   * EmpresaModulo without action
   */
  export type EmpresaModuloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaModulo
     */
    select?: EmpresaModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaModuloInclude<ExtArgs> | null
  }


  /**
   * Model ModuloDependencia
   */

  export type AggregateModuloDependencia = {
    _count: ModuloDependenciaCountAggregateOutputType | null
    _min: ModuloDependenciaMinAggregateOutputType | null
    _max: ModuloDependenciaMaxAggregateOutputType | null
  }

  export type ModuloDependenciaMinAggregateOutputType = {
    id: string | null
    moduloId: string | null
    dependeDeId: string | null
    requerido: boolean | null
  }

  export type ModuloDependenciaMaxAggregateOutputType = {
    id: string | null
    moduloId: string | null
    dependeDeId: string | null
    requerido: boolean | null
  }

  export type ModuloDependenciaCountAggregateOutputType = {
    id: number
    moduloId: number
    dependeDeId: number
    requerido: number
    _all: number
  }


  export type ModuloDependenciaMinAggregateInputType = {
    id?: true
    moduloId?: true
    dependeDeId?: true
    requerido?: true
  }

  export type ModuloDependenciaMaxAggregateInputType = {
    id?: true
    moduloId?: true
    dependeDeId?: true
    requerido?: true
  }

  export type ModuloDependenciaCountAggregateInputType = {
    id?: true
    moduloId?: true
    dependeDeId?: true
    requerido?: true
    _all?: true
  }

  export type ModuloDependenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloDependencia to aggregate.
     */
    where?: ModuloDependenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloDependencias to fetch.
     */
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloDependenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloDependencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloDependencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuloDependencias
    **/
    _count?: true | ModuloDependenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloDependenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloDependenciaMaxAggregateInputType
  }

  export type GetModuloDependenciaAggregateType<T extends ModuloDependenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateModuloDependencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuloDependencia[P]>
      : GetScalarType<T[P], AggregateModuloDependencia[P]>
  }




  export type ModuloDependenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloDependenciaWhereInput
    orderBy?: ModuloDependenciaOrderByWithAggregationInput | ModuloDependenciaOrderByWithAggregationInput[]
    by: ModuloDependenciaScalarFieldEnum[] | ModuloDependenciaScalarFieldEnum
    having?: ModuloDependenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloDependenciaCountAggregateInputType | true
    _min?: ModuloDependenciaMinAggregateInputType
    _max?: ModuloDependenciaMaxAggregateInputType
  }

  export type ModuloDependenciaGroupByOutputType = {
    id: string
    moduloId: string
    dependeDeId: string
    requerido: boolean
    _count: ModuloDependenciaCountAggregateOutputType | null
    _min: ModuloDependenciaMinAggregateOutputType | null
    _max: ModuloDependenciaMaxAggregateOutputType | null
  }

  type GetModuloDependenciaGroupByPayload<T extends ModuloDependenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloDependenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloDependenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloDependenciaGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloDependenciaGroupByOutputType[P]>
        }
      >
    >


  export type ModuloDependenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    dependeDeId?: boolean
    requerido?: boolean
    dependeDe?: boolean | ModuloDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloDependencia"]>

  export type ModuloDependenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    dependeDeId?: boolean
    requerido?: boolean
    dependeDe?: boolean | ModuloDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloDependencia"]>

  export type ModuloDependenciaSelectScalar = {
    id?: boolean
    moduloId?: boolean
    dependeDeId?: boolean
    requerido?: boolean
  }

  export type ModuloDependenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependeDe?: boolean | ModuloDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }
  export type ModuloDependenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependeDe?: boolean | ModuloDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }

  export type $ModuloDependenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuloDependencia"
    objects: {
      dependeDe: Prisma.$ModuloPayload<ExtArgs>
      modulo: Prisma.$ModuloPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduloId: string
      dependeDeId: string
      requerido: boolean
    }, ExtArgs["result"]["moduloDependencia"]>
    composites: {}
  }

  type ModuloDependenciaGetPayload<S extends boolean | null | undefined | ModuloDependenciaDefaultArgs> = $Result.GetResult<Prisma.$ModuloDependenciaPayload, S>

  type ModuloDependenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloDependenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloDependenciaCountAggregateInputType | true
    }

  export interface ModuloDependenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuloDependencia'], meta: { name: 'ModuloDependencia' } }
    /**
     * Find zero or one ModuloDependencia that matches the filter.
     * @param {ModuloDependenciaFindUniqueArgs} args - Arguments to find a ModuloDependencia
     * @example
     * // Get one ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloDependenciaFindUniqueArgs>(args: SelectSubset<T, ModuloDependenciaFindUniqueArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuloDependencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloDependenciaFindUniqueOrThrowArgs} args - Arguments to find a ModuloDependencia
     * @example
     * // Get one ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloDependenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloDependenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuloDependencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaFindFirstArgs} args - Arguments to find a ModuloDependencia
     * @example
     * // Get one ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloDependenciaFindFirstArgs>(args?: SelectSubset<T, ModuloDependenciaFindFirstArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuloDependencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaFindFirstOrThrowArgs} args - Arguments to find a ModuloDependencia
     * @example
     * // Get one ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloDependenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloDependenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuloDependencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuloDependencias
     * const moduloDependencias = await prisma.moduloDependencia.findMany()
     * 
     * // Get first 10 ModuloDependencias
     * const moduloDependencias = await prisma.moduloDependencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloDependenciaWithIdOnly = await prisma.moduloDependencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloDependenciaFindManyArgs>(args?: SelectSubset<T, ModuloDependenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuloDependencia.
     * @param {ModuloDependenciaCreateArgs} args - Arguments to create a ModuloDependencia.
     * @example
     * // Create one ModuloDependencia
     * const ModuloDependencia = await prisma.moduloDependencia.create({
     *   data: {
     *     // ... data to create a ModuloDependencia
     *   }
     * })
     * 
     */
    create<T extends ModuloDependenciaCreateArgs>(args: SelectSubset<T, ModuloDependenciaCreateArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuloDependencias.
     * @param {ModuloDependenciaCreateManyArgs} args - Arguments to create many ModuloDependencias.
     * @example
     * // Create many ModuloDependencias
     * const moduloDependencia = await prisma.moduloDependencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloDependenciaCreateManyArgs>(args?: SelectSubset<T, ModuloDependenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuloDependencias and returns the data saved in the database.
     * @param {ModuloDependenciaCreateManyAndReturnArgs} args - Arguments to create many ModuloDependencias.
     * @example
     * // Create many ModuloDependencias
     * const moduloDependencia = await prisma.moduloDependencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuloDependencias and only return the `id`
     * const moduloDependenciaWithIdOnly = await prisma.moduloDependencia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloDependenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloDependenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuloDependencia.
     * @param {ModuloDependenciaDeleteArgs} args - Arguments to delete one ModuloDependencia.
     * @example
     * // Delete one ModuloDependencia
     * const ModuloDependencia = await prisma.moduloDependencia.delete({
     *   where: {
     *     // ... filter to delete one ModuloDependencia
     *   }
     * })
     * 
     */
    delete<T extends ModuloDependenciaDeleteArgs>(args: SelectSubset<T, ModuloDependenciaDeleteArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuloDependencia.
     * @param {ModuloDependenciaUpdateArgs} args - Arguments to update one ModuloDependencia.
     * @example
     * // Update one ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloDependenciaUpdateArgs>(args: SelectSubset<T, ModuloDependenciaUpdateArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuloDependencias.
     * @param {ModuloDependenciaDeleteManyArgs} args - Arguments to filter ModuloDependencias to delete.
     * @example
     * // Delete a few ModuloDependencias
     * const { count } = await prisma.moduloDependencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloDependenciaDeleteManyArgs>(args?: SelectSubset<T, ModuloDependenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuloDependencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuloDependencias
     * const moduloDependencia = await prisma.moduloDependencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloDependenciaUpdateManyArgs>(args: SelectSubset<T, ModuloDependenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuloDependencia.
     * @param {ModuloDependenciaUpsertArgs} args - Arguments to update or create a ModuloDependencia.
     * @example
     * // Update or create a ModuloDependencia
     * const moduloDependencia = await prisma.moduloDependencia.upsert({
     *   create: {
     *     // ... data to create a ModuloDependencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuloDependencia we want to update
     *   }
     * })
     */
    upsert<T extends ModuloDependenciaUpsertArgs>(args: SelectSubset<T, ModuloDependenciaUpsertArgs<ExtArgs>>): Prisma__ModuloDependenciaClient<$Result.GetResult<Prisma.$ModuloDependenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuloDependencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaCountArgs} args - Arguments to filter ModuloDependencias to count.
     * @example
     * // Count the number of ModuloDependencias
     * const count = await prisma.moduloDependencia.count({
     *   where: {
     *     // ... the filter for the ModuloDependencias we want to count
     *   }
     * })
    **/
    count<T extends ModuloDependenciaCountArgs>(
      args?: Subset<T, ModuloDependenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloDependenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuloDependencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloDependenciaAggregateArgs>(args: Subset<T, ModuloDependenciaAggregateArgs>): Prisma.PrismaPromise<GetModuloDependenciaAggregateType<T>>

    /**
     * Group by ModuloDependencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloDependenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloDependenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloDependenciaGroupByArgs['orderBy'] }
        : { orderBy?: ModuloDependenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloDependenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloDependenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuloDependencia model
   */
  readonly fields: ModuloDependenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuloDependencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloDependenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dependeDe<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuloDependencia model
   */ 
  interface ModuloDependenciaFieldRefs {
    readonly id: FieldRef<"ModuloDependencia", 'String'>
    readonly moduloId: FieldRef<"ModuloDependencia", 'String'>
    readonly dependeDeId: FieldRef<"ModuloDependencia", 'String'>
    readonly requerido: FieldRef<"ModuloDependencia", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ModuloDependencia findUnique
   */
  export type ModuloDependenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloDependencia to fetch.
     */
    where: ModuloDependenciaWhereUniqueInput
  }

  /**
   * ModuloDependencia findUniqueOrThrow
   */
  export type ModuloDependenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloDependencia to fetch.
     */
    where: ModuloDependenciaWhereUniqueInput
  }

  /**
   * ModuloDependencia findFirst
   */
  export type ModuloDependenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloDependencia to fetch.
     */
    where?: ModuloDependenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloDependencias to fetch.
     */
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloDependencias.
     */
    cursor?: ModuloDependenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloDependencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloDependencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloDependencias.
     */
    distinct?: ModuloDependenciaScalarFieldEnum | ModuloDependenciaScalarFieldEnum[]
  }

  /**
   * ModuloDependencia findFirstOrThrow
   */
  export type ModuloDependenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloDependencia to fetch.
     */
    where?: ModuloDependenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloDependencias to fetch.
     */
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloDependencias.
     */
    cursor?: ModuloDependenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloDependencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloDependencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloDependencias.
     */
    distinct?: ModuloDependenciaScalarFieldEnum | ModuloDependenciaScalarFieldEnum[]
  }

  /**
   * ModuloDependencia findMany
   */
  export type ModuloDependenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloDependencias to fetch.
     */
    where?: ModuloDependenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloDependencias to fetch.
     */
    orderBy?: ModuloDependenciaOrderByWithRelationInput | ModuloDependenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuloDependencias.
     */
    cursor?: ModuloDependenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloDependencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloDependencias.
     */
    skip?: number
    distinct?: ModuloDependenciaScalarFieldEnum | ModuloDependenciaScalarFieldEnum[]
  }

  /**
   * ModuloDependencia create
   */
  export type ModuloDependenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuloDependencia.
     */
    data: XOR<ModuloDependenciaCreateInput, ModuloDependenciaUncheckedCreateInput>
  }

  /**
   * ModuloDependencia createMany
   */
  export type ModuloDependenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuloDependencias.
     */
    data: ModuloDependenciaCreateManyInput | ModuloDependenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuloDependencia createManyAndReturn
   */
  export type ModuloDependenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuloDependencias.
     */
    data: ModuloDependenciaCreateManyInput | ModuloDependenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuloDependencia update
   */
  export type ModuloDependenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuloDependencia.
     */
    data: XOR<ModuloDependenciaUpdateInput, ModuloDependenciaUncheckedUpdateInput>
    /**
     * Choose, which ModuloDependencia to update.
     */
    where: ModuloDependenciaWhereUniqueInput
  }

  /**
   * ModuloDependencia updateMany
   */
  export type ModuloDependenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuloDependencias.
     */
    data: XOR<ModuloDependenciaUpdateManyMutationInput, ModuloDependenciaUncheckedUpdateManyInput>
    /**
     * Filter which ModuloDependencias to update
     */
    where?: ModuloDependenciaWhereInput
  }

  /**
   * ModuloDependencia upsert
   */
  export type ModuloDependenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuloDependencia to update in case it exists.
     */
    where: ModuloDependenciaWhereUniqueInput
    /**
     * In case the ModuloDependencia found by the `where` argument doesn't exist, create a new ModuloDependencia with this data.
     */
    create: XOR<ModuloDependenciaCreateInput, ModuloDependenciaUncheckedCreateInput>
    /**
     * In case the ModuloDependencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloDependenciaUpdateInput, ModuloDependenciaUncheckedUpdateInput>
  }

  /**
   * ModuloDependencia delete
   */
  export type ModuloDependenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
    /**
     * Filter which ModuloDependencia to delete.
     */
    where: ModuloDependenciaWhereUniqueInput
  }

  /**
   * ModuloDependencia deleteMany
   */
  export type ModuloDependenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloDependencias to delete
     */
    where?: ModuloDependenciaWhereInput
  }

  /**
   * ModuloDependencia without action
   */
  export type ModuloDependenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloDependencia
     */
    select?: ModuloDependenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloDependenciaInclude<ExtArgs> | null
  }


  /**
   * Model ModuloRuta
   */

  export type AggregateModuloRuta = {
    _count: ModuloRutaCountAggregateOutputType | null
    _min: ModuloRutaMinAggregateOutputType | null
    _max: ModuloRutaMaxAggregateOutputType | null
  }

  export type ModuloRutaMinAggregateOutputType = {
    id: string | null
    moduloId: string | null
    ruta: string | null
    activo: boolean | null
    descripcion: string | null
    nombre: string | null
  }

  export type ModuloRutaMaxAggregateOutputType = {
    id: string | null
    moduloId: string | null
    ruta: string | null
    activo: boolean | null
    descripcion: string | null
    nombre: string | null
  }

  export type ModuloRutaCountAggregateOutputType = {
    id: number
    moduloId: number
    ruta: number
    activo: number
    descripcion: number
    nombre: number
    _all: number
  }


  export type ModuloRutaMinAggregateInputType = {
    id?: true
    moduloId?: true
    ruta?: true
    activo?: true
    descripcion?: true
    nombre?: true
  }

  export type ModuloRutaMaxAggregateInputType = {
    id?: true
    moduloId?: true
    ruta?: true
    activo?: true
    descripcion?: true
    nombre?: true
  }

  export type ModuloRutaCountAggregateInputType = {
    id?: true
    moduloId?: true
    ruta?: true
    activo?: true
    descripcion?: true
    nombre?: true
    _all?: true
  }

  export type ModuloRutaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloRuta to aggregate.
     */
    where?: ModuloRutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloRutas to fetch.
     */
    orderBy?: ModuloRutaOrderByWithRelationInput | ModuloRutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloRutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloRutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloRutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuloRutas
    **/
    _count?: true | ModuloRutaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloRutaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloRutaMaxAggregateInputType
  }

  export type GetModuloRutaAggregateType<T extends ModuloRutaAggregateArgs> = {
        [P in keyof T & keyof AggregateModuloRuta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuloRuta[P]>
      : GetScalarType<T[P], AggregateModuloRuta[P]>
  }




  export type ModuloRutaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloRutaWhereInput
    orderBy?: ModuloRutaOrderByWithAggregationInput | ModuloRutaOrderByWithAggregationInput[]
    by: ModuloRutaScalarFieldEnum[] | ModuloRutaScalarFieldEnum
    having?: ModuloRutaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloRutaCountAggregateInputType | true
    _min?: ModuloRutaMinAggregateInputType
    _max?: ModuloRutaMaxAggregateInputType
  }

  export type ModuloRutaGroupByOutputType = {
    id: string
    moduloId: string
    ruta: string
    activo: boolean
    descripcion: string | null
    nombre: string
    _count: ModuloRutaCountAggregateOutputType | null
    _min: ModuloRutaMinAggregateOutputType | null
    _max: ModuloRutaMaxAggregateOutputType | null
  }

  type GetModuloRutaGroupByPayload<T extends ModuloRutaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloRutaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloRutaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloRutaGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloRutaGroupByOutputType[P]>
        }
      >
    >


  export type ModuloRutaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    ruta?: boolean
    activo?: boolean
    descripcion?: boolean
    nombre?: boolean
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloRuta"]>

  export type ModuloRutaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    ruta?: boolean
    activo?: boolean
    descripcion?: boolean
    nombre?: boolean
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloRuta"]>

  export type ModuloRutaSelectScalar = {
    id?: boolean
    moduloId?: boolean
    ruta?: boolean
    activo?: boolean
    descripcion?: boolean
    nombre?: boolean
  }

  export type ModuloRutaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }
  export type ModuloRutaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }

  export type $ModuloRutaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuloRuta"
    objects: {
      modulo: Prisma.$ModuloPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduloId: string
      ruta: string
      activo: boolean
      descripcion: string | null
      nombre: string
    }, ExtArgs["result"]["moduloRuta"]>
    composites: {}
  }

  type ModuloRutaGetPayload<S extends boolean | null | undefined | ModuloRutaDefaultArgs> = $Result.GetResult<Prisma.$ModuloRutaPayload, S>

  type ModuloRutaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloRutaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloRutaCountAggregateInputType | true
    }

  export interface ModuloRutaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuloRuta'], meta: { name: 'ModuloRuta' } }
    /**
     * Find zero or one ModuloRuta that matches the filter.
     * @param {ModuloRutaFindUniqueArgs} args - Arguments to find a ModuloRuta
     * @example
     * // Get one ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloRutaFindUniqueArgs>(args: SelectSubset<T, ModuloRutaFindUniqueArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuloRuta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloRutaFindUniqueOrThrowArgs} args - Arguments to find a ModuloRuta
     * @example
     * // Get one ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloRutaFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloRutaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuloRuta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaFindFirstArgs} args - Arguments to find a ModuloRuta
     * @example
     * // Get one ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloRutaFindFirstArgs>(args?: SelectSubset<T, ModuloRutaFindFirstArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuloRuta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaFindFirstOrThrowArgs} args - Arguments to find a ModuloRuta
     * @example
     * // Get one ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloRutaFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloRutaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuloRutas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuloRutas
     * const moduloRutas = await prisma.moduloRuta.findMany()
     * 
     * // Get first 10 ModuloRutas
     * const moduloRutas = await prisma.moduloRuta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloRutaWithIdOnly = await prisma.moduloRuta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloRutaFindManyArgs>(args?: SelectSubset<T, ModuloRutaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuloRuta.
     * @param {ModuloRutaCreateArgs} args - Arguments to create a ModuloRuta.
     * @example
     * // Create one ModuloRuta
     * const ModuloRuta = await prisma.moduloRuta.create({
     *   data: {
     *     // ... data to create a ModuloRuta
     *   }
     * })
     * 
     */
    create<T extends ModuloRutaCreateArgs>(args: SelectSubset<T, ModuloRutaCreateArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuloRutas.
     * @param {ModuloRutaCreateManyArgs} args - Arguments to create many ModuloRutas.
     * @example
     * // Create many ModuloRutas
     * const moduloRuta = await prisma.moduloRuta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloRutaCreateManyArgs>(args?: SelectSubset<T, ModuloRutaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuloRutas and returns the data saved in the database.
     * @param {ModuloRutaCreateManyAndReturnArgs} args - Arguments to create many ModuloRutas.
     * @example
     * // Create many ModuloRutas
     * const moduloRuta = await prisma.moduloRuta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuloRutas and only return the `id`
     * const moduloRutaWithIdOnly = await prisma.moduloRuta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloRutaCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloRutaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuloRuta.
     * @param {ModuloRutaDeleteArgs} args - Arguments to delete one ModuloRuta.
     * @example
     * // Delete one ModuloRuta
     * const ModuloRuta = await prisma.moduloRuta.delete({
     *   where: {
     *     // ... filter to delete one ModuloRuta
     *   }
     * })
     * 
     */
    delete<T extends ModuloRutaDeleteArgs>(args: SelectSubset<T, ModuloRutaDeleteArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuloRuta.
     * @param {ModuloRutaUpdateArgs} args - Arguments to update one ModuloRuta.
     * @example
     * // Update one ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloRutaUpdateArgs>(args: SelectSubset<T, ModuloRutaUpdateArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuloRutas.
     * @param {ModuloRutaDeleteManyArgs} args - Arguments to filter ModuloRutas to delete.
     * @example
     * // Delete a few ModuloRutas
     * const { count } = await prisma.moduloRuta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloRutaDeleteManyArgs>(args?: SelectSubset<T, ModuloRutaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuloRutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuloRutas
     * const moduloRuta = await prisma.moduloRuta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloRutaUpdateManyArgs>(args: SelectSubset<T, ModuloRutaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuloRuta.
     * @param {ModuloRutaUpsertArgs} args - Arguments to update or create a ModuloRuta.
     * @example
     * // Update or create a ModuloRuta
     * const moduloRuta = await prisma.moduloRuta.upsert({
     *   create: {
     *     // ... data to create a ModuloRuta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuloRuta we want to update
     *   }
     * })
     */
    upsert<T extends ModuloRutaUpsertArgs>(args: SelectSubset<T, ModuloRutaUpsertArgs<ExtArgs>>): Prisma__ModuloRutaClient<$Result.GetResult<Prisma.$ModuloRutaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuloRutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaCountArgs} args - Arguments to filter ModuloRutas to count.
     * @example
     * // Count the number of ModuloRutas
     * const count = await prisma.moduloRuta.count({
     *   where: {
     *     // ... the filter for the ModuloRutas we want to count
     *   }
     * })
    **/
    count<T extends ModuloRutaCountArgs>(
      args?: Subset<T, ModuloRutaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloRutaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuloRuta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloRutaAggregateArgs>(args: Subset<T, ModuloRutaAggregateArgs>): Prisma.PrismaPromise<GetModuloRutaAggregateType<T>>

    /**
     * Group by ModuloRuta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloRutaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloRutaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloRutaGroupByArgs['orderBy'] }
        : { orderBy?: ModuloRutaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloRutaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloRutaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuloRuta model
   */
  readonly fields: ModuloRutaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuloRuta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloRutaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuloRuta model
   */ 
  interface ModuloRutaFieldRefs {
    readonly id: FieldRef<"ModuloRuta", 'String'>
    readonly moduloId: FieldRef<"ModuloRuta", 'String'>
    readonly ruta: FieldRef<"ModuloRuta", 'String'>
    readonly activo: FieldRef<"ModuloRuta", 'Boolean'>
    readonly descripcion: FieldRef<"ModuloRuta", 'String'>
    readonly nombre: FieldRef<"ModuloRuta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuloRuta findUnique
   */
  export type ModuloRutaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloRuta to fetch.
     */
    where: ModuloRutaWhereUniqueInput
  }

  /**
   * ModuloRuta findUniqueOrThrow
   */
  export type ModuloRutaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloRuta to fetch.
     */
    where: ModuloRutaWhereUniqueInput
  }

  /**
   * ModuloRuta findFirst
   */
  export type ModuloRutaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloRuta to fetch.
     */
    where?: ModuloRutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloRutas to fetch.
     */
    orderBy?: ModuloRutaOrderByWithRelationInput | ModuloRutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloRutas.
     */
    cursor?: ModuloRutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloRutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloRutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloRutas.
     */
    distinct?: ModuloRutaScalarFieldEnum | ModuloRutaScalarFieldEnum[]
  }

  /**
   * ModuloRuta findFirstOrThrow
   */
  export type ModuloRutaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloRuta to fetch.
     */
    where?: ModuloRutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloRutas to fetch.
     */
    orderBy?: ModuloRutaOrderByWithRelationInput | ModuloRutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloRutas.
     */
    cursor?: ModuloRutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloRutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloRutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloRutas.
     */
    distinct?: ModuloRutaScalarFieldEnum | ModuloRutaScalarFieldEnum[]
  }

  /**
   * ModuloRuta findMany
   */
  export type ModuloRutaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter, which ModuloRutas to fetch.
     */
    where?: ModuloRutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloRutas to fetch.
     */
    orderBy?: ModuloRutaOrderByWithRelationInput | ModuloRutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuloRutas.
     */
    cursor?: ModuloRutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloRutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloRutas.
     */
    skip?: number
    distinct?: ModuloRutaScalarFieldEnum | ModuloRutaScalarFieldEnum[]
  }

  /**
   * ModuloRuta create
   */
  export type ModuloRutaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuloRuta.
     */
    data: XOR<ModuloRutaCreateInput, ModuloRutaUncheckedCreateInput>
  }

  /**
   * ModuloRuta createMany
   */
  export type ModuloRutaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuloRutas.
     */
    data: ModuloRutaCreateManyInput | ModuloRutaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuloRuta createManyAndReturn
   */
  export type ModuloRutaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuloRutas.
     */
    data: ModuloRutaCreateManyInput | ModuloRutaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuloRuta update
   */
  export type ModuloRutaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuloRuta.
     */
    data: XOR<ModuloRutaUpdateInput, ModuloRutaUncheckedUpdateInput>
    /**
     * Choose, which ModuloRuta to update.
     */
    where: ModuloRutaWhereUniqueInput
  }

  /**
   * ModuloRuta updateMany
   */
  export type ModuloRutaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuloRutas.
     */
    data: XOR<ModuloRutaUpdateManyMutationInput, ModuloRutaUncheckedUpdateManyInput>
    /**
     * Filter which ModuloRutas to update
     */
    where?: ModuloRutaWhereInput
  }

  /**
   * ModuloRuta upsert
   */
  export type ModuloRutaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuloRuta to update in case it exists.
     */
    where: ModuloRutaWhereUniqueInput
    /**
     * In case the ModuloRuta found by the `where` argument doesn't exist, create a new ModuloRuta with this data.
     */
    create: XOR<ModuloRutaCreateInput, ModuloRutaUncheckedCreateInput>
    /**
     * In case the ModuloRuta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloRutaUpdateInput, ModuloRutaUncheckedUpdateInput>
  }

  /**
   * ModuloRuta delete
   */
  export type ModuloRutaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
    /**
     * Filter which ModuloRuta to delete.
     */
    where: ModuloRutaWhereUniqueInput
  }

  /**
   * ModuloRuta deleteMany
   */
  export type ModuloRutaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloRutas to delete
     */
    where?: ModuloRutaWhereInput
  }

  /**
   * ModuloRuta without action
   */
  export type ModuloRutaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloRuta
     */
    select?: ModuloRutaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloRutaInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    activo: boolean | null
    descripcion: string | null
  }

  export type RolMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    activo: boolean | null
    descripcion: string | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    nombre: number
    activo: number
    descripcion: number
    _all: number
  }


  export type RolMinAggregateInputType = {
    id?: true
    nombre?: true
    activo?: true
    descripcion?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    nombre?: true
    activo?: true
    descripcion?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    nombre?: true
    activo?: true
    descripcion?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: string
    nombre: string
    activo: boolean
    descripcion: string | null
    _count: RolCountAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    activo?: boolean
    descripcion?: boolean
    permisos?: boolean | Rol$permisosArgs<ExtArgs>
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    activo?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id?: boolean
    nombre?: boolean
    activo?: boolean
    descripcion?: boolean
  }

  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permisos?: boolean | Rol$permisosArgs<ExtArgs>
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      permisos: Prisma.$RolPermisoPayload<ExtArgs>[]
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      activo: boolean
      descripcion: string | null
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rols and returns the data saved in the database.
     * @param {RolCreateManyAndReturnArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolCreateManyAndReturnArgs>(args?: SelectSubset<T, RolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permisos<T extends Rol$permisosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$permisosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends Rol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */ 
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'String'>
    readonly nombre: FieldRef<"Rol", 'String'>
    readonly activo: FieldRef<"Rol", 'Boolean'>
    readonly descripcion: FieldRef<"Rol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol createManyAndReturn
   */
  export type RolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
  }

  /**
   * Rol.permisos
   */
  export type Rol$permisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    cursor?: RolPermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * Rol.usuarios
   */
  export type Rol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model ModuloPermiso
   */

  export type AggregateModuloPermiso = {
    _count: ModuloPermisoCountAggregateOutputType | null
    _min: ModuloPermisoMinAggregateOutputType | null
    _max: ModuloPermisoMaxAggregateOutputType | null
  }

  export type ModuloPermisoMinAggregateOutputType = {
    id: string | null
    moduloId: string | null
    nombre: string | null
    codigo: string | null
    descripcion: string | null
  }

  export type ModuloPermisoMaxAggregateOutputType = {
    id: string | null
    moduloId: string | null
    nombre: string | null
    codigo: string | null
    descripcion: string | null
  }

  export type ModuloPermisoCountAggregateOutputType = {
    id: number
    moduloId: number
    nombre: number
    codigo: number
    descripcion: number
    _all: number
  }


  export type ModuloPermisoMinAggregateInputType = {
    id?: true
    moduloId?: true
    nombre?: true
    codigo?: true
    descripcion?: true
  }

  export type ModuloPermisoMaxAggregateInputType = {
    id?: true
    moduloId?: true
    nombre?: true
    codigo?: true
    descripcion?: true
  }

  export type ModuloPermisoCountAggregateInputType = {
    id?: true
    moduloId?: true
    nombre?: true
    codigo?: true
    descripcion?: true
    _all?: true
  }

  export type ModuloPermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloPermiso to aggregate.
     */
    where?: ModuloPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloPermisos to fetch.
     */
    orderBy?: ModuloPermisoOrderByWithRelationInput | ModuloPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuloPermisos
    **/
    _count?: true | ModuloPermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloPermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloPermisoMaxAggregateInputType
  }

  export type GetModuloPermisoAggregateType<T extends ModuloPermisoAggregateArgs> = {
        [P in keyof T & keyof AggregateModuloPermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuloPermiso[P]>
      : GetScalarType<T[P], AggregateModuloPermiso[P]>
  }




  export type ModuloPermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloPermisoWhereInput
    orderBy?: ModuloPermisoOrderByWithAggregationInput | ModuloPermisoOrderByWithAggregationInput[]
    by: ModuloPermisoScalarFieldEnum[] | ModuloPermisoScalarFieldEnum
    having?: ModuloPermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloPermisoCountAggregateInputType | true
    _min?: ModuloPermisoMinAggregateInputType
    _max?: ModuloPermisoMaxAggregateInputType
  }

  export type ModuloPermisoGroupByOutputType = {
    id: string
    moduloId: string
    nombre: string
    codigo: string
    descripcion: string | null
    _count: ModuloPermisoCountAggregateOutputType | null
    _min: ModuloPermisoMinAggregateOutputType | null
    _max: ModuloPermisoMaxAggregateOutputType | null
  }

  type GetModuloPermisoGroupByPayload<T extends ModuloPermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloPermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloPermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloPermisoGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloPermisoGroupByOutputType[P]>
        }
      >
    >


  export type ModuloPermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    nombre?: boolean
    codigo?: boolean
    descripcion?: boolean
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    roles?: boolean | ModuloPermiso$rolesArgs<ExtArgs>
    _count?: boolean | ModuloPermisoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloPermiso"]>

  export type ModuloPermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduloId?: boolean
    nombre?: boolean
    codigo?: boolean
    descripcion?: boolean
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloPermiso"]>

  export type ModuloPermisoSelectScalar = {
    id?: boolean
    moduloId?: boolean
    nombre?: boolean
    codigo?: boolean
    descripcion?: boolean
  }

  export type ModuloPermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    roles?: boolean | ModuloPermiso$rolesArgs<ExtArgs>
    _count?: boolean | ModuloPermisoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuloPermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }

  export type $ModuloPermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuloPermiso"
    objects: {
      modulo: Prisma.$ModuloPayload<ExtArgs>
      roles: Prisma.$RolPermisoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduloId: string
      nombre: string
      codigo: string
      descripcion: string | null
    }, ExtArgs["result"]["moduloPermiso"]>
    composites: {}
  }

  type ModuloPermisoGetPayload<S extends boolean | null | undefined | ModuloPermisoDefaultArgs> = $Result.GetResult<Prisma.$ModuloPermisoPayload, S>

  type ModuloPermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloPermisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloPermisoCountAggregateInputType | true
    }

  export interface ModuloPermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuloPermiso'], meta: { name: 'ModuloPermiso' } }
    /**
     * Find zero or one ModuloPermiso that matches the filter.
     * @param {ModuloPermisoFindUniqueArgs} args - Arguments to find a ModuloPermiso
     * @example
     * // Get one ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloPermisoFindUniqueArgs>(args: SelectSubset<T, ModuloPermisoFindUniqueArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuloPermiso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloPermisoFindUniqueOrThrowArgs} args - Arguments to find a ModuloPermiso
     * @example
     * // Get one ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloPermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloPermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuloPermiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoFindFirstArgs} args - Arguments to find a ModuloPermiso
     * @example
     * // Get one ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloPermisoFindFirstArgs>(args?: SelectSubset<T, ModuloPermisoFindFirstArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuloPermiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoFindFirstOrThrowArgs} args - Arguments to find a ModuloPermiso
     * @example
     * // Get one ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloPermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloPermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuloPermisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuloPermisos
     * const moduloPermisos = await prisma.moduloPermiso.findMany()
     * 
     * // Get first 10 ModuloPermisos
     * const moduloPermisos = await prisma.moduloPermiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloPermisoWithIdOnly = await prisma.moduloPermiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloPermisoFindManyArgs>(args?: SelectSubset<T, ModuloPermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuloPermiso.
     * @param {ModuloPermisoCreateArgs} args - Arguments to create a ModuloPermiso.
     * @example
     * // Create one ModuloPermiso
     * const ModuloPermiso = await prisma.moduloPermiso.create({
     *   data: {
     *     // ... data to create a ModuloPermiso
     *   }
     * })
     * 
     */
    create<T extends ModuloPermisoCreateArgs>(args: SelectSubset<T, ModuloPermisoCreateArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuloPermisos.
     * @param {ModuloPermisoCreateManyArgs} args - Arguments to create many ModuloPermisos.
     * @example
     * // Create many ModuloPermisos
     * const moduloPermiso = await prisma.moduloPermiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloPermisoCreateManyArgs>(args?: SelectSubset<T, ModuloPermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuloPermisos and returns the data saved in the database.
     * @param {ModuloPermisoCreateManyAndReturnArgs} args - Arguments to create many ModuloPermisos.
     * @example
     * // Create many ModuloPermisos
     * const moduloPermiso = await prisma.moduloPermiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuloPermisos and only return the `id`
     * const moduloPermisoWithIdOnly = await prisma.moduloPermiso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloPermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloPermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuloPermiso.
     * @param {ModuloPermisoDeleteArgs} args - Arguments to delete one ModuloPermiso.
     * @example
     * // Delete one ModuloPermiso
     * const ModuloPermiso = await prisma.moduloPermiso.delete({
     *   where: {
     *     // ... filter to delete one ModuloPermiso
     *   }
     * })
     * 
     */
    delete<T extends ModuloPermisoDeleteArgs>(args: SelectSubset<T, ModuloPermisoDeleteArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuloPermiso.
     * @param {ModuloPermisoUpdateArgs} args - Arguments to update one ModuloPermiso.
     * @example
     * // Update one ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloPermisoUpdateArgs>(args: SelectSubset<T, ModuloPermisoUpdateArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuloPermisos.
     * @param {ModuloPermisoDeleteManyArgs} args - Arguments to filter ModuloPermisos to delete.
     * @example
     * // Delete a few ModuloPermisos
     * const { count } = await prisma.moduloPermiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloPermisoDeleteManyArgs>(args?: SelectSubset<T, ModuloPermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuloPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuloPermisos
     * const moduloPermiso = await prisma.moduloPermiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloPermisoUpdateManyArgs>(args: SelectSubset<T, ModuloPermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuloPermiso.
     * @param {ModuloPermisoUpsertArgs} args - Arguments to update or create a ModuloPermiso.
     * @example
     * // Update or create a ModuloPermiso
     * const moduloPermiso = await prisma.moduloPermiso.upsert({
     *   create: {
     *     // ... data to create a ModuloPermiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuloPermiso we want to update
     *   }
     * })
     */
    upsert<T extends ModuloPermisoUpsertArgs>(args: SelectSubset<T, ModuloPermisoUpsertArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuloPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoCountArgs} args - Arguments to filter ModuloPermisos to count.
     * @example
     * // Count the number of ModuloPermisos
     * const count = await prisma.moduloPermiso.count({
     *   where: {
     *     // ... the filter for the ModuloPermisos we want to count
     *   }
     * })
    **/
    count<T extends ModuloPermisoCountArgs>(
      args?: Subset<T, ModuloPermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloPermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuloPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloPermisoAggregateArgs>(args: Subset<T, ModuloPermisoAggregateArgs>): Prisma.PrismaPromise<GetModuloPermisoAggregateType<T>>

    /**
     * Group by ModuloPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloPermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloPermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloPermisoGroupByArgs['orderBy'] }
        : { orderBy?: ModuloPermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloPermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuloPermiso model
   */
  readonly fields: ModuloPermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuloPermiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloPermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roles<T extends ModuloPermiso$rolesArgs<ExtArgs> = {}>(args?: Subset<T, ModuloPermiso$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuloPermiso model
   */ 
  interface ModuloPermisoFieldRefs {
    readonly id: FieldRef<"ModuloPermiso", 'String'>
    readonly moduloId: FieldRef<"ModuloPermiso", 'String'>
    readonly nombre: FieldRef<"ModuloPermiso", 'String'>
    readonly codigo: FieldRef<"ModuloPermiso", 'String'>
    readonly descripcion: FieldRef<"ModuloPermiso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuloPermiso findUnique
   */
  export type ModuloPermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloPermiso to fetch.
     */
    where: ModuloPermisoWhereUniqueInput
  }

  /**
   * ModuloPermiso findUniqueOrThrow
   */
  export type ModuloPermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloPermiso to fetch.
     */
    where: ModuloPermisoWhereUniqueInput
  }

  /**
   * ModuloPermiso findFirst
   */
  export type ModuloPermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloPermiso to fetch.
     */
    where?: ModuloPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloPermisos to fetch.
     */
    orderBy?: ModuloPermisoOrderByWithRelationInput | ModuloPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloPermisos.
     */
    cursor?: ModuloPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloPermisos.
     */
    distinct?: ModuloPermisoScalarFieldEnum | ModuloPermisoScalarFieldEnum[]
  }

  /**
   * ModuloPermiso findFirstOrThrow
   */
  export type ModuloPermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloPermiso to fetch.
     */
    where?: ModuloPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloPermisos to fetch.
     */
    orderBy?: ModuloPermisoOrderByWithRelationInput | ModuloPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloPermisos.
     */
    cursor?: ModuloPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloPermisos.
     */
    distinct?: ModuloPermisoScalarFieldEnum | ModuloPermisoScalarFieldEnum[]
  }

  /**
   * ModuloPermiso findMany
   */
  export type ModuloPermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloPermisos to fetch.
     */
    where?: ModuloPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloPermisos to fetch.
     */
    orderBy?: ModuloPermisoOrderByWithRelationInput | ModuloPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuloPermisos.
     */
    cursor?: ModuloPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloPermisos.
     */
    skip?: number
    distinct?: ModuloPermisoScalarFieldEnum | ModuloPermisoScalarFieldEnum[]
  }

  /**
   * ModuloPermiso create
   */
  export type ModuloPermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuloPermiso.
     */
    data: XOR<ModuloPermisoCreateInput, ModuloPermisoUncheckedCreateInput>
  }

  /**
   * ModuloPermiso createMany
   */
  export type ModuloPermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuloPermisos.
     */
    data: ModuloPermisoCreateManyInput | ModuloPermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuloPermiso createManyAndReturn
   */
  export type ModuloPermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuloPermisos.
     */
    data: ModuloPermisoCreateManyInput | ModuloPermisoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuloPermiso update
   */
  export type ModuloPermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuloPermiso.
     */
    data: XOR<ModuloPermisoUpdateInput, ModuloPermisoUncheckedUpdateInput>
    /**
     * Choose, which ModuloPermiso to update.
     */
    where: ModuloPermisoWhereUniqueInput
  }

  /**
   * ModuloPermiso updateMany
   */
  export type ModuloPermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuloPermisos.
     */
    data: XOR<ModuloPermisoUpdateManyMutationInput, ModuloPermisoUncheckedUpdateManyInput>
    /**
     * Filter which ModuloPermisos to update
     */
    where?: ModuloPermisoWhereInput
  }

  /**
   * ModuloPermiso upsert
   */
  export type ModuloPermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuloPermiso to update in case it exists.
     */
    where: ModuloPermisoWhereUniqueInput
    /**
     * In case the ModuloPermiso found by the `where` argument doesn't exist, create a new ModuloPermiso with this data.
     */
    create: XOR<ModuloPermisoCreateInput, ModuloPermisoUncheckedCreateInput>
    /**
     * In case the ModuloPermiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloPermisoUpdateInput, ModuloPermisoUncheckedUpdateInput>
  }

  /**
   * ModuloPermiso delete
   */
  export type ModuloPermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
    /**
     * Filter which ModuloPermiso to delete.
     */
    where: ModuloPermisoWhereUniqueInput
  }

  /**
   * ModuloPermiso deleteMany
   */
  export type ModuloPermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloPermisos to delete
     */
    where?: ModuloPermisoWhereInput
  }

  /**
   * ModuloPermiso.roles
   */
  export type ModuloPermiso$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    cursor?: RolPermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * ModuloPermiso without action
   */
  export type ModuloPermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloPermiso
     */
    select?: ModuloPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloPermisoInclude<ExtArgs> | null
  }


  /**
   * Model RolPermiso
   */

  export type AggregateRolPermiso = {
    _count: RolPermisoCountAggregateOutputType | null
    _min: RolPermisoMinAggregateOutputType | null
    _max: RolPermisoMaxAggregateOutputType | null
  }

  export type RolPermisoMinAggregateOutputType = {
    id: string | null
    rolId: string | null
    permisoId: string | null
  }

  export type RolPermisoMaxAggregateOutputType = {
    id: string | null
    rolId: string | null
    permisoId: string | null
  }

  export type RolPermisoCountAggregateOutputType = {
    id: number
    rolId: number
    permisoId: number
    _all: number
  }


  export type RolPermisoMinAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
  }

  export type RolPermisoMaxAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
  }

  export type RolPermisoCountAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
    _all?: true
  }

  export type RolPermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolPermiso to aggregate.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolPermisos
    **/
    _count?: true | RolPermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolPermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolPermisoMaxAggregateInputType
  }

  export type GetRolPermisoAggregateType<T extends RolPermisoAggregateArgs> = {
        [P in keyof T & keyof AggregateRolPermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolPermiso[P]>
      : GetScalarType<T[P], AggregateRolPermiso[P]>
  }




  export type RolPermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithAggregationInput | RolPermisoOrderByWithAggregationInput[]
    by: RolPermisoScalarFieldEnum[] | RolPermisoScalarFieldEnum
    having?: RolPermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolPermisoCountAggregateInputType | true
    _min?: RolPermisoMinAggregateInputType
    _max?: RolPermisoMaxAggregateInputType
  }

  export type RolPermisoGroupByOutputType = {
    id: string
    rolId: string
    permisoId: string
    _count: RolPermisoCountAggregateOutputType | null
    _min: RolPermisoMinAggregateOutputType | null
    _max: RolPermisoMaxAggregateOutputType | null
  }

  type GetRolPermisoGroupByPayload<T extends RolPermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolPermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolPermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolPermisoGroupByOutputType[P]>
            : GetScalarType<T[P], RolPermisoGroupByOutputType[P]>
        }
      >
    >


  export type RolPermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    permiso?: boolean | ModuloPermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolPermiso"]>

  export type RolPermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    permiso?: boolean | ModuloPermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolPermiso"]>

  export type RolPermisoSelectScalar = {
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
  }

  export type RolPermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | ModuloPermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type RolPermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | ModuloPermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $RolPermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolPermiso"
    objects: {
      permiso: Prisma.$ModuloPermisoPayload<ExtArgs>
      rol: Prisma.$RolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rolId: string
      permisoId: string
    }, ExtArgs["result"]["rolPermiso"]>
    composites: {}
  }

  type RolPermisoGetPayload<S extends boolean | null | undefined | RolPermisoDefaultArgs> = $Result.GetResult<Prisma.$RolPermisoPayload, S>

  type RolPermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolPermisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolPermisoCountAggregateInputType | true
    }

  export interface RolPermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolPermiso'], meta: { name: 'RolPermiso' } }
    /**
     * Find zero or one RolPermiso that matches the filter.
     * @param {RolPermisoFindUniqueArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolPermisoFindUniqueArgs>(args: SelectSubset<T, RolPermisoFindUniqueArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolPermiso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolPermisoFindUniqueOrThrowArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolPermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, RolPermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolPermiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindFirstArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolPermisoFindFirstArgs>(args?: SelectSubset<T, RolPermisoFindFirstArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolPermiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindFirstOrThrowArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolPermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, RolPermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolPermisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolPermisos
     * const rolPermisos = await prisma.rolPermiso.findMany()
     * 
     * // Get first 10 RolPermisos
     * const rolPermisos = await prisma.rolPermiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolPermisoWithIdOnly = await prisma.rolPermiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolPermisoFindManyArgs>(args?: SelectSubset<T, RolPermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolPermiso.
     * @param {RolPermisoCreateArgs} args - Arguments to create a RolPermiso.
     * @example
     * // Create one RolPermiso
     * const RolPermiso = await prisma.rolPermiso.create({
     *   data: {
     *     // ... data to create a RolPermiso
     *   }
     * })
     * 
     */
    create<T extends RolPermisoCreateArgs>(args: SelectSubset<T, RolPermisoCreateArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolPermisos.
     * @param {RolPermisoCreateManyArgs} args - Arguments to create many RolPermisos.
     * @example
     * // Create many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolPermisoCreateManyArgs>(args?: SelectSubset<T, RolPermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolPermisos and returns the data saved in the database.
     * @param {RolPermisoCreateManyAndReturnArgs} args - Arguments to create many RolPermisos.
     * @example
     * // Create many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolPermisos and only return the `id`
     * const rolPermisoWithIdOnly = await prisma.rolPermiso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolPermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, RolPermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolPermiso.
     * @param {RolPermisoDeleteArgs} args - Arguments to delete one RolPermiso.
     * @example
     * // Delete one RolPermiso
     * const RolPermiso = await prisma.rolPermiso.delete({
     *   where: {
     *     // ... filter to delete one RolPermiso
     *   }
     * })
     * 
     */
    delete<T extends RolPermisoDeleteArgs>(args: SelectSubset<T, RolPermisoDeleteArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolPermiso.
     * @param {RolPermisoUpdateArgs} args - Arguments to update one RolPermiso.
     * @example
     * // Update one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolPermisoUpdateArgs>(args: SelectSubset<T, RolPermisoUpdateArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolPermisos.
     * @param {RolPermisoDeleteManyArgs} args - Arguments to filter RolPermisos to delete.
     * @example
     * // Delete a few RolPermisos
     * const { count } = await prisma.rolPermiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolPermisoDeleteManyArgs>(args?: SelectSubset<T, RolPermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolPermisoUpdateManyArgs>(args: SelectSubset<T, RolPermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolPermiso.
     * @param {RolPermisoUpsertArgs} args - Arguments to update or create a RolPermiso.
     * @example
     * // Update or create a RolPermiso
     * const rolPermiso = await prisma.rolPermiso.upsert({
     *   create: {
     *     // ... data to create a RolPermiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolPermiso we want to update
     *   }
     * })
     */
    upsert<T extends RolPermisoUpsertArgs>(args: SelectSubset<T, RolPermisoUpsertArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoCountArgs} args - Arguments to filter RolPermisos to count.
     * @example
     * // Count the number of RolPermisos
     * const count = await prisma.rolPermiso.count({
     *   where: {
     *     // ... the filter for the RolPermisos we want to count
     *   }
     * })
    **/
    count<T extends RolPermisoCountArgs>(
      args?: Subset<T, RolPermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolPermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolPermisoAggregateArgs>(args: Subset<T, RolPermisoAggregateArgs>): Prisma.PrismaPromise<GetRolPermisoAggregateType<T>>

    /**
     * Group by RolPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolPermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolPermisoGroupByArgs['orderBy'] }
        : { orderBy?: RolPermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolPermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolPermiso model
   */
  readonly fields: RolPermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolPermiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolPermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permiso<T extends ModuloPermisoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloPermisoDefaultArgs<ExtArgs>>): Prisma__ModuloPermisoClient<$Result.GetResult<Prisma.$ModuloPermisoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolPermiso model
   */ 
  interface RolPermisoFieldRefs {
    readonly id: FieldRef<"RolPermiso", 'String'>
    readonly rolId: FieldRef<"RolPermiso", 'String'>
    readonly permisoId: FieldRef<"RolPermiso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolPermiso findUnique
   */
  export type RolPermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso findUniqueOrThrow
   */
  export type RolPermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso findFirst
   */
  export type RolPermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolPermisos.
     */
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso findFirstOrThrow
   */
  export type RolPermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolPermisos.
     */
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso findMany
   */
  export type RolPermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermisos to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso create
   */
  export type RolPermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a RolPermiso.
     */
    data: XOR<RolPermisoCreateInput, RolPermisoUncheckedCreateInput>
  }

  /**
   * RolPermiso createMany
   */
  export type RolPermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolPermisos.
     */
    data: RolPermisoCreateManyInput | RolPermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolPermiso createManyAndReturn
   */
  export type RolPermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolPermisos.
     */
    data: RolPermisoCreateManyInput | RolPermisoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolPermiso update
   */
  export type RolPermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a RolPermiso.
     */
    data: XOR<RolPermisoUpdateInput, RolPermisoUncheckedUpdateInput>
    /**
     * Choose, which RolPermiso to update.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso updateMany
   */
  export type RolPermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolPermisos.
     */
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyInput>
    /**
     * Filter which RolPermisos to update
     */
    where?: RolPermisoWhereInput
  }

  /**
   * RolPermiso upsert
   */
  export type RolPermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the RolPermiso to update in case it exists.
     */
    where: RolPermisoWhereUniqueInput
    /**
     * In case the RolPermiso found by the `where` argument doesn't exist, create a new RolPermiso with this data.
     */
    create: XOR<RolPermisoCreateInput, RolPermisoUncheckedCreateInput>
    /**
     * In case the RolPermiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolPermisoUpdateInput, RolPermisoUncheckedUpdateInput>
  }

  /**
   * RolPermiso delete
   */
  export type RolPermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter which RolPermiso to delete.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso deleteMany
   */
  export type RolPermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolPermisos to delete
     */
    where?: RolPermisoWhereInput
  }

  /**
   * RolPermiso without action
   */
  export type RolPermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
  }


  /**
   * Model EmpresaConfiguracion
   */

  export type AggregateEmpresaConfiguracion = {
    _count: EmpresaConfiguracionCountAggregateOutputType | null
    _min: EmpresaConfiguracionMinAggregateOutputType | null
    _max: EmpresaConfiguracionMaxAggregateOutputType | null
  }

  export type EmpresaConfiguracionMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    clave: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaConfiguracionMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    clave: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaConfiguracionCountAggregateOutputType = {
    id: number
    empresaId: number
    clave: number
    valor: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmpresaConfiguracionMinAggregateInputType = {
    id?: true
    empresaId?: true
    clave?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaConfiguracionMaxAggregateInputType = {
    id?: true
    empresaId?: true
    clave?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaConfiguracionCountAggregateInputType = {
    id?: true
    empresaId?: true
    clave?: true
    valor?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmpresaConfiguracionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpresaConfiguracion to aggregate.
     */
    where?: EmpresaConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaConfiguracions to fetch.
     */
    orderBy?: EmpresaConfiguracionOrderByWithRelationInput | EmpresaConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaConfiguracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaConfiguracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmpresaConfiguracions
    **/
    _count?: true | EmpresaConfiguracionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaConfiguracionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaConfiguracionMaxAggregateInputType
  }

  export type GetEmpresaConfiguracionAggregateType<T extends EmpresaConfiguracionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresaConfiguracion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresaConfiguracion[P]>
      : GetScalarType<T[P], AggregateEmpresaConfiguracion[P]>
  }




  export type EmpresaConfiguracionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaConfiguracionWhereInput
    orderBy?: EmpresaConfiguracionOrderByWithAggregationInput | EmpresaConfiguracionOrderByWithAggregationInput[]
    by: EmpresaConfiguracionScalarFieldEnum[] | EmpresaConfiguracionScalarFieldEnum
    having?: EmpresaConfiguracionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaConfiguracionCountAggregateInputType | true
    _min?: EmpresaConfiguracionMinAggregateInputType
    _max?: EmpresaConfiguracionMaxAggregateInputType
  }

  export type EmpresaConfiguracionGroupByOutputType = {
    id: string
    empresaId: string
    clave: string
    valor: JsonValue
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmpresaConfiguracionCountAggregateOutputType | null
    _min: EmpresaConfiguracionMinAggregateOutputType | null
    _max: EmpresaConfiguracionMaxAggregateOutputType | null
  }

  type GetEmpresaConfiguracionGroupByPayload<T extends EmpresaConfiguracionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaConfiguracionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaConfiguracionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaConfiguracionGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaConfiguracionGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaConfiguracionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    clave?: boolean
    valor?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresaConfiguracion"]>

  export type EmpresaConfiguracionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    clave?: boolean
    valor?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresaConfiguracion"]>

  export type EmpresaConfiguracionSelectScalar = {
    id?: boolean
    empresaId?: boolean
    clave?: boolean
    valor?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmpresaConfiguracionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type EmpresaConfiguracionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $EmpresaConfiguracionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmpresaConfiguracion"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      clave: string
      valor: Prisma.JsonValue
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["empresaConfiguracion"]>
    composites: {}
  }

  type EmpresaConfiguracionGetPayload<S extends boolean | null | undefined | EmpresaConfiguracionDefaultArgs> = $Result.GetResult<Prisma.$EmpresaConfiguracionPayload, S>

  type EmpresaConfiguracionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaConfiguracionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaConfiguracionCountAggregateInputType | true
    }

  export interface EmpresaConfiguracionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmpresaConfiguracion'], meta: { name: 'EmpresaConfiguracion' } }
    /**
     * Find zero or one EmpresaConfiguracion that matches the filter.
     * @param {EmpresaConfiguracionFindUniqueArgs} args - Arguments to find a EmpresaConfiguracion
     * @example
     * // Get one EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaConfiguracionFindUniqueArgs>(args: SelectSubset<T, EmpresaConfiguracionFindUniqueArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmpresaConfiguracion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaConfiguracionFindUniqueOrThrowArgs} args - Arguments to find a EmpresaConfiguracion
     * @example
     * // Get one EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaConfiguracionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaConfiguracionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmpresaConfiguracion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionFindFirstArgs} args - Arguments to find a EmpresaConfiguracion
     * @example
     * // Get one EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaConfiguracionFindFirstArgs>(args?: SelectSubset<T, EmpresaConfiguracionFindFirstArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmpresaConfiguracion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionFindFirstOrThrowArgs} args - Arguments to find a EmpresaConfiguracion
     * @example
     * // Get one EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaConfiguracionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaConfiguracionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmpresaConfiguracions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmpresaConfiguracions
     * const empresaConfiguracions = await prisma.empresaConfiguracion.findMany()
     * 
     * // Get first 10 EmpresaConfiguracions
     * const empresaConfiguracions = await prisma.empresaConfiguracion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaConfiguracionWithIdOnly = await prisma.empresaConfiguracion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaConfiguracionFindManyArgs>(args?: SelectSubset<T, EmpresaConfiguracionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmpresaConfiguracion.
     * @param {EmpresaConfiguracionCreateArgs} args - Arguments to create a EmpresaConfiguracion.
     * @example
     * // Create one EmpresaConfiguracion
     * const EmpresaConfiguracion = await prisma.empresaConfiguracion.create({
     *   data: {
     *     // ... data to create a EmpresaConfiguracion
     *   }
     * })
     * 
     */
    create<T extends EmpresaConfiguracionCreateArgs>(args: SelectSubset<T, EmpresaConfiguracionCreateArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmpresaConfiguracions.
     * @param {EmpresaConfiguracionCreateManyArgs} args - Arguments to create many EmpresaConfiguracions.
     * @example
     * // Create many EmpresaConfiguracions
     * const empresaConfiguracion = await prisma.empresaConfiguracion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaConfiguracionCreateManyArgs>(args?: SelectSubset<T, EmpresaConfiguracionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmpresaConfiguracions and returns the data saved in the database.
     * @param {EmpresaConfiguracionCreateManyAndReturnArgs} args - Arguments to create many EmpresaConfiguracions.
     * @example
     * // Create many EmpresaConfiguracions
     * const empresaConfiguracion = await prisma.empresaConfiguracion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmpresaConfiguracions and only return the `id`
     * const empresaConfiguracionWithIdOnly = await prisma.empresaConfiguracion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaConfiguracionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaConfiguracionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmpresaConfiguracion.
     * @param {EmpresaConfiguracionDeleteArgs} args - Arguments to delete one EmpresaConfiguracion.
     * @example
     * // Delete one EmpresaConfiguracion
     * const EmpresaConfiguracion = await prisma.empresaConfiguracion.delete({
     *   where: {
     *     // ... filter to delete one EmpresaConfiguracion
     *   }
     * })
     * 
     */
    delete<T extends EmpresaConfiguracionDeleteArgs>(args: SelectSubset<T, EmpresaConfiguracionDeleteArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmpresaConfiguracion.
     * @param {EmpresaConfiguracionUpdateArgs} args - Arguments to update one EmpresaConfiguracion.
     * @example
     * // Update one EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaConfiguracionUpdateArgs>(args: SelectSubset<T, EmpresaConfiguracionUpdateArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmpresaConfiguracions.
     * @param {EmpresaConfiguracionDeleteManyArgs} args - Arguments to filter EmpresaConfiguracions to delete.
     * @example
     * // Delete a few EmpresaConfiguracions
     * const { count } = await prisma.empresaConfiguracion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaConfiguracionDeleteManyArgs>(args?: SelectSubset<T, EmpresaConfiguracionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmpresaConfiguracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmpresaConfiguracions
     * const empresaConfiguracion = await prisma.empresaConfiguracion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaConfiguracionUpdateManyArgs>(args: SelectSubset<T, EmpresaConfiguracionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmpresaConfiguracion.
     * @param {EmpresaConfiguracionUpsertArgs} args - Arguments to update or create a EmpresaConfiguracion.
     * @example
     * // Update or create a EmpresaConfiguracion
     * const empresaConfiguracion = await prisma.empresaConfiguracion.upsert({
     *   create: {
     *     // ... data to create a EmpresaConfiguracion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmpresaConfiguracion we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaConfiguracionUpsertArgs>(args: SelectSubset<T, EmpresaConfiguracionUpsertArgs<ExtArgs>>): Prisma__EmpresaConfiguracionClient<$Result.GetResult<Prisma.$EmpresaConfiguracionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmpresaConfiguracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionCountArgs} args - Arguments to filter EmpresaConfiguracions to count.
     * @example
     * // Count the number of EmpresaConfiguracions
     * const count = await prisma.empresaConfiguracion.count({
     *   where: {
     *     // ... the filter for the EmpresaConfiguracions we want to count
     *   }
     * })
    **/
    count<T extends EmpresaConfiguracionCountArgs>(
      args?: Subset<T, EmpresaConfiguracionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaConfiguracionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmpresaConfiguracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaConfiguracionAggregateArgs>(args: Subset<T, EmpresaConfiguracionAggregateArgs>): Prisma.PrismaPromise<GetEmpresaConfiguracionAggregateType<T>>

    /**
     * Group by EmpresaConfiguracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaConfiguracionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaConfiguracionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaConfiguracionGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaConfiguracionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaConfiguracionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaConfiguracionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmpresaConfiguracion model
   */
  readonly fields: EmpresaConfiguracionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmpresaConfiguracion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaConfiguracionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmpresaConfiguracion model
   */ 
  interface EmpresaConfiguracionFieldRefs {
    readonly id: FieldRef<"EmpresaConfiguracion", 'String'>
    readonly empresaId: FieldRef<"EmpresaConfiguracion", 'String'>
    readonly clave: FieldRef<"EmpresaConfiguracion", 'String'>
    readonly valor: FieldRef<"EmpresaConfiguracion", 'Json'>
    readonly activo: FieldRef<"EmpresaConfiguracion", 'Boolean'>
    readonly createdAt: FieldRef<"EmpresaConfiguracion", 'DateTime'>
    readonly updatedAt: FieldRef<"EmpresaConfiguracion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmpresaConfiguracion findUnique
   */
  export type EmpresaConfiguracionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaConfiguracion to fetch.
     */
    where: EmpresaConfiguracionWhereUniqueInput
  }

  /**
   * EmpresaConfiguracion findUniqueOrThrow
   */
  export type EmpresaConfiguracionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaConfiguracion to fetch.
     */
    where: EmpresaConfiguracionWhereUniqueInput
  }

  /**
   * EmpresaConfiguracion findFirst
   */
  export type EmpresaConfiguracionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaConfiguracion to fetch.
     */
    where?: EmpresaConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaConfiguracions to fetch.
     */
    orderBy?: EmpresaConfiguracionOrderByWithRelationInput | EmpresaConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpresaConfiguracions.
     */
    cursor?: EmpresaConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaConfiguracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaConfiguracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpresaConfiguracions.
     */
    distinct?: EmpresaConfiguracionScalarFieldEnum | EmpresaConfiguracionScalarFieldEnum[]
  }

  /**
   * EmpresaConfiguracion findFirstOrThrow
   */
  export type EmpresaConfiguracionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaConfiguracion to fetch.
     */
    where?: EmpresaConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaConfiguracions to fetch.
     */
    orderBy?: EmpresaConfiguracionOrderByWithRelationInput | EmpresaConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpresaConfiguracions.
     */
    cursor?: EmpresaConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaConfiguracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaConfiguracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpresaConfiguracions.
     */
    distinct?: EmpresaConfiguracionScalarFieldEnum | EmpresaConfiguracionScalarFieldEnum[]
  }

  /**
   * EmpresaConfiguracion findMany
   */
  export type EmpresaConfiguracionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter, which EmpresaConfiguracions to fetch.
     */
    where?: EmpresaConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpresaConfiguracions to fetch.
     */
    orderBy?: EmpresaConfiguracionOrderByWithRelationInput | EmpresaConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmpresaConfiguracions.
     */
    cursor?: EmpresaConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpresaConfiguracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpresaConfiguracions.
     */
    skip?: number
    distinct?: EmpresaConfiguracionScalarFieldEnum | EmpresaConfiguracionScalarFieldEnum[]
  }

  /**
   * EmpresaConfiguracion create
   */
  export type EmpresaConfiguracionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * The data needed to create a EmpresaConfiguracion.
     */
    data: XOR<EmpresaConfiguracionCreateInput, EmpresaConfiguracionUncheckedCreateInput>
  }

  /**
   * EmpresaConfiguracion createMany
   */
  export type EmpresaConfiguracionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmpresaConfiguracions.
     */
    data: EmpresaConfiguracionCreateManyInput | EmpresaConfiguracionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmpresaConfiguracion createManyAndReturn
   */
  export type EmpresaConfiguracionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmpresaConfiguracions.
     */
    data: EmpresaConfiguracionCreateManyInput | EmpresaConfiguracionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmpresaConfiguracion update
   */
  export type EmpresaConfiguracionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * The data needed to update a EmpresaConfiguracion.
     */
    data: XOR<EmpresaConfiguracionUpdateInput, EmpresaConfiguracionUncheckedUpdateInput>
    /**
     * Choose, which EmpresaConfiguracion to update.
     */
    where: EmpresaConfiguracionWhereUniqueInput
  }

  /**
   * EmpresaConfiguracion updateMany
   */
  export type EmpresaConfiguracionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmpresaConfiguracions.
     */
    data: XOR<EmpresaConfiguracionUpdateManyMutationInput, EmpresaConfiguracionUncheckedUpdateManyInput>
    /**
     * Filter which EmpresaConfiguracions to update
     */
    where?: EmpresaConfiguracionWhereInput
  }

  /**
   * EmpresaConfiguracion upsert
   */
  export type EmpresaConfiguracionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * The filter to search for the EmpresaConfiguracion to update in case it exists.
     */
    where: EmpresaConfiguracionWhereUniqueInput
    /**
     * In case the EmpresaConfiguracion found by the `where` argument doesn't exist, create a new EmpresaConfiguracion with this data.
     */
    create: XOR<EmpresaConfiguracionCreateInput, EmpresaConfiguracionUncheckedCreateInput>
    /**
     * In case the EmpresaConfiguracion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaConfiguracionUpdateInput, EmpresaConfiguracionUncheckedUpdateInput>
  }

  /**
   * EmpresaConfiguracion delete
   */
  export type EmpresaConfiguracionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
    /**
     * Filter which EmpresaConfiguracion to delete.
     */
    where: EmpresaConfiguracionWhereUniqueInput
  }

  /**
   * EmpresaConfiguracion deleteMany
   */
  export type EmpresaConfiguracionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpresaConfiguracions to delete
     */
    where?: EmpresaConfiguracionWhereInput
  }

  /**
   * EmpresaConfiguracion without action
   */
  export type EmpresaConfiguracionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaConfiguracion
     */
    select?: EmpresaConfiguracionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaConfiguracionInclude<ExtArgs> | null
  }


  /**
   * Model Factura
   */

  export type AggregateFactura = {
    _count: FacturaCountAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  export type FacturaMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacturaMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacturaCountAggregateOutputType = {
    id: number
    empresaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacturaMinAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacturaMaxAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacturaCountAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Factura to aggregate.
     */
    where?: FacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facturas to fetch.
     */
    orderBy?: FacturaOrderByWithRelationInput | FacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facturas
    **/
    _count?: true | FacturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturaMaxAggregateInputType
  }

  export type GetFacturaAggregateType<T extends FacturaAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura[P]>
      : GetScalarType<T[P], AggregateFactura[P]>
  }




  export type FacturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacturaWhereInput
    orderBy?: FacturaOrderByWithAggregationInput | FacturaOrderByWithAggregationInput[]
    by: FacturaScalarFieldEnum[] | FacturaScalarFieldEnum
    having?: FacturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturaCountAggregateInputType | true
    _min?: FacturaMinAggregateInputType
    _max?: FacturaMaxAggregateInputType
  }

  export type FacturaGroupByOutputType = {
    id: string
    empresaId: string
    createdAt: Date
    updatedAt: Date
    _count: FacturaCountAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  type GetFacturaGroupByPayload<T extends FacturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturaGroupByOutputType[P]>
            : GetScalarType<T[P], FacturaGroupByOutputType[P]>
        }
      >
    >


  export type FacturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type FacturaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type FacturaSelectScalar = {
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type FacturaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $FacturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Factura"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["factura"]>
    composites: {}
  }

  type FacturaGetPayload<S extends boolean | null | undefined | FacturaDefaultArgs> = $Result.GetResult<Prisma.$FacturaPayload, S>

  type FacturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacturaCountAggregateInputType | true
    }

  export interface FacturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Factura'], meta: { name: 'Factura' } }
    /**
     * Find zero or one Factura that matches the filter.
     * @param {FacturaFindUniqueArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacturaFindUniqueArgs>(args: SelectSubset<T, FacturaFindUniqueArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Factura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacturaFindUniqueOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacturaFindUniqueOrThrowArgs>(args: SelectSubset<T, FacturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Factura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaFindFirstArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacturaFindFirstArgs>(args?: SelectSubset<T, FacturaFindFirstArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Factura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaFindFirstOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacturaFindFirstOrThrowArgs>(args?: SelectSubset<T, FacturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facturas
     * const facturas = await prisma.factura.findMany()
     * 
     * // Get first 10 Facturas
     * const facturas = await prisma.factura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facturaWithIdOnly = await prisma.factura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacturaFindManyArgs>(args?: SelectSubset<T, FacturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Factura.
     * @param {FacturaCreateArgs} args - Arguments to create a Factura.
     * @example
     * // Create one Factura
     * const Factura = await prisma.factura.create({
     *   data: {
     *     // ... data to create a Factura
     *   }
     * })
     * 
     */
    create<T extends FacturaCreateArgs>(args: SelectSubset<T, FacturaCreateArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Facturas.
     * @param {FacturaCreateManyArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const factura = await prisma.factura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacturaCreateManyArgs>(args?: SelectSubset<T, FacturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facturas and returns the data saved in the database.
     * @param {FacturaCreateManyAndReturnArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const factura = await prisma.factura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facturas and only return the `id`
     * const facturaWithIdOnly = await prisma.factura.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacturaCreateManyAndReturnArgs>(args?: SelectSubset<T, FacturaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Factura.
     * @param {FacturaDeleteArgs} args - Arguments to delete one Factura.
     * @example
     * // Delete one Factura
     * const Factura = await prisma.factura.delete({
     *   where: {
     *     // ... filter to delete one Factura
     *   }
     * })
     * 
     */
    delete<T extends FacturaDeleteArgs>(args: SelectSubset<T, FacturaDeleteArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Factura.
     * @param {FacturaUpdateArgs} args - Arguments to update one Factura.
     * @example
     * // Update one Factura
     * const factura = await prisma.factura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacturaUpdateArgs>(args: SelectSubset<T, FacturaUpdateArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Facturas.
     * @param {FacturaDeleteManyArgs} args - Arguments to filter Facturas to delete.
     * @example
     * // Delete a few Facturas
     * const { count } = await prisma.factura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacturaDeleteManyArgs>(args?: SelectSubset<T, FacturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facturas
     * const factura = await prisma.factura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacturaUpdateManyArgs>(args: SelectSubset<T, FacturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura.
     * @param {FacturaUpsertArgs} args - Arguments to update or create a Factura.
     * @example
     * // Update or create a Factura
     * const factura = await prisma.factura.upsert({
     *   create: {
     *     // ... data to create a Factura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura we want to update
     *   }
     * })
     */
    upsert<T extends FacturaUpsertArgs>(args: SelectSubset<T, FacturaUpsertArgs<ExtArgs>>): Prisma__FacturaClient<$Result.GetResult<Prisma.$FacturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaCountArgs} args - Arguments to filter Facturas to count.
     * @example
     * // Count the number of Facturas
     * const count = await prisma.factura.count({
     *   where: {
     *     // ... the filter for the Facturas we want to count
     *   }
     * })
    **/
    count<T extends FacturaCountArgs>(
      args?: Subset<T, FacturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturaAggregateArgs>(args: Subset<T, FacturaAggregateArgs>): Prisma.PrismaPromise<GetFacturaAggregateType<T>>

    /**
     * Group by Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacturaGroupByArgs['orderBy'] }
        : { orderBy?: FacturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Factura model
   */
  readonly fields: FacturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Factura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Factura model
   */ 
  interface FacturaFieldRefs {
    readonly id: FieldRef<"Factura", 'String'>
    readonly empresaId: FieldRef<"Factura", 'String'>
    readonly createdAt: FieldRef<"Factura", 'DateTime'>
    readonly updatedAt: FieldRef<"Factura", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Factura findUnique
   */
  export type FacturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter, which Factura to fetch.
     */
    where: FacturaWhereUniqueInput
  }

  /**
   * Factura findUniqueOrThrow
   */
  export type FacturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter, which Factura to fetch.
     */
    where: FacturaWhereUniqueInput
  }

  /**
   * Factura findFirst
   */
  export type FacturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter, which Factura to fetch.
     */
    where?: FacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facturas to fetch.
     */
    orderBy?: FacturaOrderByWithRelationInput | FacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facturas.
     */
    cursor?: FacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * Factura findFirstOrThrow
   */
  export type FacturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter, which Factura to fetch.
     */
    where?: FacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facturas to fetch.
     */
    orderBy?: FacturaOrderByWithRelationInput | FacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facturas.
     */
    cursor?: FacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * Factura findMany
   */
  export type FacturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter, which Facturas to fetch.
     */
    where?: FacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facturas to fetch.
     */
    orderBy?: FacturaOrderByWithRelationInput | FacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facturas.
     */
    cursor?: FacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facturas.
     */
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * Factura create
   */
  export type FacturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * The data needed to create a Factura.
     */
    data: XOR<FacturaCreateInput, FacturaUncheckedCreateInput>
  }

  /**
   * Factura createMany
   */
  export type FacturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facturas.
     */
    data: FacturaCreateManyInput | FacturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Factura createManyAndReturn
   */
  export type FacturaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Facturas.
     */
    data: FacturaCreateManyInput | FacturaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Factura update
   */
  export type FacturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * The data needed to update a Factura.
     */
    data: XOR<FacturaUpdateInput, FacturaUncheckedUpdateInput>
    /**
     * Choose, which Factura to update.
     */
    where: FacturaWhereUniqueInput
  }

  /**
   * Factura updateMany
   */
  export type FacturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facturas.
     */
    data: XOR<FacturaUpdateManyMutationInput, FacturaUncheckedUpdateManyInput>
    /**
     * Filter which Facturas to update
     */
    where?: FacturaWhereInput
  }

  /**
   * Factura upsert
   */
  export type FacturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * The filter to search for the Factura to update in case it exists.
     */
    where: FacturaWhereUniqueInput
    /**
     * In case the Factura found by the `where` argument doesn't exist, create a new Factura with this data.
     */
    create: XOR<FacturaCreateInput, FacturaUncheckedCreateInput>
    /**
     * In case the Factura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacturaUpdateInput, FacturaUncheckedUpdateInput>
  }

  /**
   * Factura delete
   */
  export type FacturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
    /**
     * Filter which Factura to delete.
     */
    where: FacturaWhereUniqueInput
  }

  /**
   * Factura deleteMany
   */
  export type FacturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facturas to delete
     */
    where?: FacturaWhereInput
  }

  /**
   * Factura without action
   */
  export type FacturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Factura
     */
    select?: FacturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacturaInclude<ExtArgs> | null
  }


  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    empresaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductoMinAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id: string
    empresaId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductoCountAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectScalar = {
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type ProductoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }

  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoFindUniqueArgs>(args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Producto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoFindFirstArgs>(args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductoFindManyArgs>(args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
     */
    create<T extends ProductoCreateArgs>(args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Productos.
     * @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoCreateManyArgs>(args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos and returns the data saved in the database.
     * @param {ProductoCreateManyAndReturnArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos and only return the `id`
     * const productoWithIdOnly = await prisma.producto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
     */
    delete<T extends ProductoDeleteArgs>(args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoUpdateArgs>(args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoDeleteManyArgs>(args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoUpdateManyArgs>(args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
     */
    upsert<T extends ProductoUpsertArgs>(args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Producto model
   */ 
  interface ProductoFieldRefs {
    readonly id: FieldRef<"Producto", 'String'>
    readonly empresaId: FieldRef<"Producto", 'String'>
    readonly createdAt: FieldRef<"Producto", 'DateTime'>
    readonly updatedAt: FieldRef<"Producto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }

  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Producto createManyAndReturn
   */
  export type ProductoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
  }

  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }

  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
  }

  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    empresaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClienteMinAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: string
    empresaId: string
    createdAt: Date
    updatedAt: Date
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'String'>
    readonly empresaId: FieldRef<"Cliente", 'String'>
    readonly createdAt: FieldRef<"Cliente", 'DateTime'>
    readonly updatedAt: FieldRef<"Cliente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model MovimientoCaja
   */

  export type AggregateMovimientoCaja = {
    _count: MovimientoCajaCountAggregateOutputType | null
    _min: MovimientoCajaMinAggregateOutputType | null
    _max: MovimientoCajaMaxAggregateOutputType | null
  }

  export type MovimientoCajaMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovimientoCajaMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovimientoCajaCountAggregateOutputType = {
    id: number
    empresaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovimientoCajaMinAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovimientoCajaMaxAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovimientoCajaCountAggregateInputType = {
    id?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovimientoCajaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovimientoCaja to aggregate.
     */
    where?: MovimientoCajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovimientoCajas to fetch.
     */
    orderBy?: MovimientoCajaOrderByWithRelationInput | MovimientoCajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovimientoCajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovimientoCajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovimientoCajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovimientoCajas
    **/
    _count?: true | MovimientoCajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovimientoCajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovimientoCajaMaxAggregateInputType
  }

  export type GetMovimientoCajaAggregateType<T extends MovimientoCajaAggregateArgs> = {
        [P in keyof T & keyof AggregateMovimientoCaja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovimientoCaja[P]>
      : GetScalarType<T[P], AggregateMovimientoCaja[P]>
  }




  export type MovimientoCajaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoCajaWhereInput
    orderBy?: MovimientoCajaOrderByWithAggregationInput | MovimientoCajaOrderByWithAggregationInput[]
    by: MovimientoCajaScalarFieldEnum[] | MovimientoCajaScalarFieldEnum
    having?: MovimientoCajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovimientoCajaCountAggregateInputType | true
    _min?: MovimientoCajaMinAggregateInputType
    _max?: MovimientoCajaMaxAggregateInputType
  }

  export type MovimientoCajaGroupByOutputType = {
    id: string
    empresaId: string
    createdAt: Date
    updatedAt: Date
    _count: MovimientoCajaCountAggregateOutputType | null
    _min: MovimientoCajaMinAggregateOutputType | null
    _max: MovimientoCajaMaxAggregateOutputType | null
  }

  type GetMovimientoCajaGroupByPayload<T extends MovimientoCajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovimientoCajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovimientoCajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovimientoCajaGroupByOutputType[P]>
            : GetScalarType<T[P], MovimientoCajaGroupByOutputType[P]>
        }
      >
    >


  export type MovimientoCajaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimientoCaja"]>

  export type MovimientoCajaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimientoCaja"]>

  export type MovimientoCajaSelectScalar = {
    id?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovimientoCajaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type MovimientoCajaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $MovimientoCajaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovimientoCaja"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movimientoCaja"]>
    composites: {}
  }

  type MovimientoCajaGetPayload<S extends boolean | null | undefined | MovimientoCajaDefaultArgs> = $Result.GetResult<Prisma.$MovimientoCajaPayload, S>

  type MovimientoCajaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovimientoCajaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovimientoCajaCountAggregateInputType | true
    }

  export interface MovimientoCajaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovimientoCaja'], meta: { name: 'MovimientoCaja' } }
    /**
     * Find zero or one MovimientoCaja that matches the filter.
     * @param {MovimientoCajaFindUniqueArgs} args - Arguments to find a MovimientoCaja
     * @example
     * // Get one MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovimientoCajaFindUniqueArgs>(args: SelectSubset<T, MovimientoCajaFindUniqueArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovimientoCaja that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovimientoCajaFindUniqueOrThrowArgs} args - Arguments to find a MovimientoCaja
     * @example
     * // Get one MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovimientoCajaFindUniqueOrThrowArgs>(args: SelectSubset<T, MovimientoCajaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovimientoCaja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaFindFirstArgs} args - Arguments to find a MovimientoCaja
     * @example
     * // Get one MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovimientoCajaFindFirstArgs>(args?: SelectSubset<T, MovimientoCajaFindFirstArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovimientoCaja that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaFindFirstOrThrowArgs} args - Arguments to find a MovimientoCaja
     * @example
     * // Get one MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovimientoCajaFindFirstOrThrowArgs>(args?: SelectSubset<T, MovimientoCajaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovimientoCajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovimientoCajas
     * const movimientoCajas = await prisma.movimientoCaja.findMany()
     * 
     * // Get first 10 MovimientoCajas
     * const movimientoCajas = await prisma.movimientoCaja.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movimientoCajaWithIdOnly = await prisma.movimientoCaja.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovimientoCajaFindManyArgs>(args?: SelectSubset<T, MovimientoCajaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovimientoCaja.
     * @param {MovimientoCajaCreateArgs} args - Arguments to create a MovimientoCaja.
     * @example
     * // Create one MovimientoCaja
     * const MovimientoCaja = await prisma.movimientoCaja.create({
     *   data: {
     *     // ... data to create a MovimientoCaja
     *   }
     * })
     * 
     */
    create<T extends MovimientoCajaCreateArgs>(args: SelectSubset<T, MovimientoCajaCreateArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovimientoCajas.
     * @param {MovimientoCajaCreateManyArgs} args - Arguments to create many MovimientoCajas.
     * @example
     * // Create many MovimientoCajas
     * const movimientoCaja = await prisma.movimientoCaja.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovimientoCajaCreateManyArgs>(args?: SelectSubset<T, MovimientoCajaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovimientoCajas and returns the data saved in the database.
     * @param {MovimientoCajaCreateManyAndReturnArgs} args - Arguments to create many MovimientoCajas.
     * @example
     * // Create many MovimientoCajas
     * const movimientoCaja = await prisma.movimientoCaja.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovimientoCajas and only return the `id`
     * const movimientoCajaWithIdOnly = await prisma.movimientoCaja.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovimientoCajaCreateManyAndReturnArgs>(args?: SelectSubset<T, MovimientoCajaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovimientoCaja.
     * @param {MovimientoCajaDeleteArgs} args - Arguments to delete one MovimientoCaja.
     * @example
     * // Delete one MovimientoCaja
     * const MovimientoCaja = await prisma.movimientoCaja.delete({
     *   where: {
     *     // ... filter to delete one MovimientoCaja
     *   }
     * })
     * 
     */
    delete<T extends MovimientoCajaDeleteArgs>(args: SelectSubset<T, MovimientoCajaDeleteArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovimientoCaja.
     * @param {MovimientoCajaUpdateArgs} args - Arguments to update one MovimientoCaja.
     * @example
     * // Update one MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovimientoCajaUpdateArgs>(args: SelectSubset<T, MovimientoCajaUpdateArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovimientoCajas.
     * @param {MovimientoCajaDeleteManyArgs} args - Arguments to filter MovimientoCajas to delete.
     * @example
     * // Delete a few MovimientoCajas
     * const { count } = await prisma.movimientoCaja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovimientoCajaDeleteManyArgs>(args?: SelectSubset<T, MovimientoCajaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovimientoCajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovimientoCajas
     * const movimientoCaja = await prisma.movimientoCaja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovimientoCajaUpdateManyArgs>(args: SelectSubset<T, MovimientoCajaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovimientoCaja.
     * @param {MovimientoCajaUpsertArgs} args - Arguments to update or create a MovimientoCaja.
     * @example
     * // Update or create a MovimientoCaja
     * const movimientoCaja = await prisma.movimientoCaja.upsert({
     *   create: {
     *     // ... data to create a MovimientoCaja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovimientoCaja we want to update
     *   }
     * })
     */
    upsert<T extends MovimientoCajaUpsertArgs>(args: SelectSubset<T, MovimientoCajaUpsertArgs<ExtArgs>>): Prisma__MovimientoCajaClient<$Result.GetResult<Prisma.$MovimientoCajaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovimientoCajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaCountArgs} args - Arguments to filter MovimientoCajas to count.
     * @example
     * // Count the number of MovimientoCajas
     * const count = await prisma.movimientoCaja.count({
     *   where: {
     *     // ... the filter for the MovimientoCajas we want to count
     *   }
     * })
    **/
    count<T extends MovimientoCajaCountArgs>(
      args?: Subset<T, MovimientoCajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovimientoCajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovimientoCaja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovimientoCajaAggregateArgs>(args: Subset<T, MovimientoCajaAggregateArgs>): Prisma.PrismaPromise<GetMovimientoCajaAggregateType<T>>

    /**
     * Group by MovimientoCaja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovimientoCajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovimientoCajaGroupByArgs['orderBy'] }
        : { orderBy?: MovimientoCajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovimientoCajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovimientoCajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovimientoCaja model
   */
  readonly fields: MovimientoCajaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovimientoCaja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovimientoCajaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovimientoCaja model
   */ 
  interface MovimientoCajaFieldRefs {
    readonly id: FieldRef<"MovimientoCaja", 'String'>
    readonly empresaId: FieldRef<"MovimientoCaja", 'String'>
    readonly createdAt: FieldRef<"MovimientoCaja", 'DateTime'>
    readonly updatedAt: FieldRef<"MovimientoCaja", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovimientoCaja findUnique
   */
  export type MovimientoCajaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter, which MovimientoCaja to fetch.
     */
    where: MovimientoCajaWhereUniqueInput
  }

  /**
   * MovimientoCaja findUniqueOrThrow
   */
  export type MovimientoCajaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter, which MovimientoCaja to fetch.
     */
    where: MovimientoCajaWhereUniqueInput
  }

  /**
   * MovimientoCaja findFirst
   */
  export type MovimientoCajaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter, which MovimientoCaja to fetch.
     */
    where?: MovimientoCajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovimientoCajas to fetch.
     */
    orderBy?: MovimientoCajaOrderByWithRelationInput | MovimientoCajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovimientoCajas.
     */
    cursor?: MovimientoCajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovimientoCajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovimientoCajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovimientoCajas.
     */
    distinct?: MovimientoCajaScalarFieldEnum | MovimientoCajaScalarFieldEnum[]
  }

  /**
   * MovimientoCaja findFirstOrThrow
   */
  export type MovimientoCajaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter, which MovimientoCaja to fetch.
     */
    where?: MovimientoCajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovimientoCajas to fetch.
     */
    orderBy?: MovimientoCajaOrderByWithRelationInput | MovimientoCajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovimientoCajas.
     */
    cursor?: MovimientoCajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovimientoCajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovimientoCajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovimientoCajas.
     */
    distinct?: MovimientoCajaScalarFieldEnum | MovimientoCajaScalarFieldEnum[]
  }

  /**
   * MovimientoCaja findMany
   */
  export type MovimientoCajaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter, which MovimientoCajas to fetch.
     */
    where?: MovimientoCajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovimientoCajas to fetch.
     */
    orderBy?: MovimientoCajaOrderByWithRelationInput | MovimientoCajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovimientoCajas.
     */
    cursor?: MovimientoCajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovimientoCajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovimientoCajas.
     */
    skip?: number
    distinct?: MovimientoCajaScalarFieldEnum | MovimientoCajaScalarFieldEnum[]
  }

  /**
   * MovimientoCaja create
   */
  export type MovimientoCajaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * The data needed to create a MovimientoCaja.
     */
    data: XOR<MovimientoCajaCreateInput, MovimientoCajaUncheckedCreateInput>
  }

  /**
   * MovimientoCaja createMany
   */
  export type MovimientoCajaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovimientoCajas.
     */
    data: MovimientoCajaCreateManyInput | MovimientoCajaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovimientoCaja createManyAndReturn
   */
  export type MovimientoCajaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovimientoCajas.
     */
    data: MovimientoCajaCreateManyInput | MovimientoCajaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovimientoCaja update
   */
  export type MovimientoCajaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * The data needed to update a MovimientoCaja.
     */
    data: XOR<MovimientoCajaUpdateInput, MovimientoCajaUncheckedUpdateInput>
    /**
     * Choose, which MovimientoCaja to update.
     */
    where: MovimientoCajaWhereUniqueInput
  }

  /**
   * MovimientoCaja updateMany
   */
  export type MovimientoCajaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovimientoCajas.
     */
    data: XOR<MovimientoCajaUpdateManyMutationInput, MovimientoCajaUncheckedUpdateManyInput>
    /**
     * Filter which MovimientoCajas to update
     */
    where?: MovimientoCajaWhereInput
  }

  /**
   * MovimientoCaja upsert
   */
  export type MovimientoCajaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * The filter to search for the MovimientoCaja to update in case it exists.
     */
    where: MovimientoCajaWhereUniqueInput
    /**
     * In case the MovimientoCaja found by the `where` argument doesn't exist, create a new MovimientoCaja with this data.
     */
    create: XOR<MovimientoCajaCreateInput, MovimientoCajaUncheckedCreateInput>
    /**
     * In case the MovimientoCaja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovimientoCajaUpdateInput, MovimientoCajaUncheckedUpdateInput>
  }

  /**
   * MovimientoCaja delete
   */
  export type MovimientoCajaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
    /**
     * Filter which MovimientoCaja to delete.
     */
    where: MovimientoCajaWhereUniqueInput
  }

  /**
   * MovimientoCaja deleteMany
   */
  export type MovimientoCajaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovimientoCajas to delete
     */
    where?: MovimientoCajaWhereInput
  }

  /**
   * MovimientoCaja without action
   */
  export type MovimientoCajaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovimientoCaja
     */
    select?: MovimientoCajaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoCajaInclude<ExtArgs> | null
  }


  /**
   * Model ModuloHistorico
   */

  export type AggregateModuloHistorico = {
    _count: ModuloHistoricoCountAggregateOutputType | null
    _min: ModuloHistoricoMinAggregateOutputType | null
    _max: ModuloHistoricoMaxAggregateOutputType | null
  }

  export type ModuloHistoricoMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    moduloId: string | null
    accion: string | null
    usuarioId: string | null
    razon: string | null
    fechaCreacion: Date | null
  }

  export type ModuloHistoricoMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    moduloId: string | null
    accion: string | null
    usuarioId: string | null
    razon: string | null
    fechaCreacion: Date | null
  }

  export type ModuloHistoricoCountAggregateOutputType = {
    id: number
    empresaId: number
    moduloId: number
    accion: number
    usuarioId: number
    razon: number
    fechaCreacion: number
    _all: number
  }


  export type ModuloHistoricoMinAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    accion?: true
    usuarioId?: true
    razon?: true
    fechaCreacion?: true
  }

  export type ModuloHistoricoMaxAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    accion?: true
    usuarioId?: true
    razon?: true
    fechaCreacion?: true
  }

  export type ModuloHistoricoCountAggregateInputType = {
    id?: true
    empresaId?: true
    moduloId?: true
    accion?: true
    usuarioId?: true
    razon?: true
    fechaCreacion?: true
    _all?: true
  }

  export type ModuloHistoricoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloHistorico to aggregate.
     */
    where?: ModuloHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloHistoricos to fetch.
     */
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuloHistoricos
    **/
    _count?: true | ModuloHistoricoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloHistoricoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloHistoricoMaxAggregateInputType
  }

  export type GetModuloHistoricoAggregateType<T extends ModuloHistoricoAggregateArgs> = {
        [P in keyof T & keyof AggregateModuloHistorico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuloHistorico[P]>
      : GetScalarType<T[P], AggregateModuloHistorico[P]>
  }




  export type ModuloHistoricoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloHistoricoWhereInput
    orderBy?: ModuloHistoricoOrderByWithAggregationInput | ModuloHistoricoOrderByWithAggregationInput[]
    by: ModuloHistoricoScalarFieldEnum[] | ModuloHistoricoScalarFieldEnum
    having?: ModuloHistoricoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloHistoricoCountAggregateInputType | true
    _min?: ModuloHistoricoMinAggregateInputType
    _max?: ModuloHistoricoMaxAggregateInputType
  }

  export type ModuloHistoricoGroupByOutputType = {
    id: string
    empresaId: string
    moduloId: string
    accion: string
    usuarioId: string
    razon: string | null
    fechaCreacion: Date
    _count: ModuloHistoricoCountAggregateOutputType | null
    _min: ModuloHistoricoMinAggregateOutputType | null
    _max: ModuloHistoricoMaxAggregateOutputType | null
  }

  type GetModuloHistoricoGroupByPayload<T extends ModuloHistoricoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloHistoricoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloHistoricoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloHistoricoGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloHistoricoGroupByOutputType[P]>
        }
      >
    >


  export type ModuloHistoricoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    accion?: boolean
    usuarioId?: boolean
    razon?: boolean
    fechaCreacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloHistorico"]>

  export type ModuloHistoricoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    accion?: boolean
    usuarioId?: boolean
    razon?: boolean
    fechaCreacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduloHistorico"]>

  export type ModuloHistoricoSelectScalar = {
    id?: boolean
    empresaId?: boolean
    moduloId?: boolean
    accion?: boolean
    usuarioId?: boolean
    razon?: boolean
    fechaCreacion?: boolean
  }

  export type ModuloHistoricoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ModuloHistoricoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ModuloHistoricoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuloHistorico"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      modulo: Prisma.$ModuloPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      moduloId: string
      accion: string
      usuarioId: string
      razon: string | null
      fechaCreacion: Date
    }, ExtArgs["result"]["moduloHistorico"]>
    composites: {}
  }

  type ModuloHistoricoGetPayload<S extends boolean | null | undefined | ModuloHistoricoDefaultArgs> = $Result.GetResult<Prisma.$ModuloHistoricoPayload, S>

  type ModuloHistoricoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloHistoricoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloHistoricoCountAggregateInputType | true
    }

  export interface ModuloHistoricoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuloHistorico'], meta: { name: 'ModuloHistorico' } }
    /**
     * Find zero or one ModuloHistorico that matches the filter.
     * @param {ModuloHistoricoFindUniqueArgs} args - Arguments to find a ModuloHistorico
     * @example
     * // Get one ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloHistoricoFindUniqueArgs>(args: SelectSubset<T, ModuloHistoricoFindUniqueArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuloHistorico that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloHistoricoFindUniqueOrThrowArgs} args - Arguments to find a ModuloHistorico
     * @example
     * // Get one ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloHistoricoFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloHistoricoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuloHistorico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoFindFirstArgs} args - Arguments to find a ModuloHistorico
     * @example
     * // Get one ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloHistoricoFindFirstArgs>(args?: SelectSubset<T, ModuloHistoricoFindFirstArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuloHistorico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoFindFirstOrThrowArgs} args - Arguments to find a ModuloHistorico
     * @example
     * // Get one ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloHistoricoFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloHistoricoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuloHistoricos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuloHistoricos
     * const moduloHistoricos = await prisma.moduloHistorico.findMany()
     * 
     * // Get first 10 ModuloHistoricos
     * const moduloHistoricos = await prisma.moduloHistorico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloHistoricoWithIdOnly = await prisma.moduloHistorico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloHistoricoFindManyArgs>(args?: SelectSubset<T, ModuloHistoricoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuloHistorico.
     * @param {ModuloHistoricoCreateArgs} args - Arguments to create a ModuloHistorico.
     * @example
     * // Create one ModuloHistorico
     * const ModuloHistorico = await prisma.moduloHistorico.create({
     *   data: {
     *     // ... data to create a ModuloHistorico
     *   }
     * })
     * 
     */
    create<T extends ModuloHistoricoCreateArgs>(args: SelectSubset<T, ModuloHistoricoCreateArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuloHistoricos.
     * @param {ModuloHistoricoCreateManyArgs} args - Arguments to create many ModuloHistoricos.
     * @example
     * // Create many ModuloHistoricos
     * const moduloHistorico = await prisma.moduloHistorico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloHistoricoCreateManyArgs>(args?: SelectSubset<T, ModuloHistoricoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuloHistoricos and returns the data saved in the database.
     * @param {ModuloHistoricoCreateManyAndReturnArgs} args - Arguments to create many ModuloHistoricos.
     * @example
     * // Create many ModuloHistoricos
     * const moduloHistorico = await prisma.moduloHistorico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuloHistoricos and only return the `id`
     * const moduloHistoricoWithIdOnly = await prisma.moduloHistorico.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloHistoricoCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloHistoricoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuloHistorico.
     * @param {ModuloHistoricoDeleteArgs} args - Arguments to delete one ModuloHistorico.
     * @example
     * // Delete one ModuloHistorico
     * const ModuloHistorico = await prisma.moduloHistorico.delete({
     *   where: {
     *     // ... filter to delete one ModuloHistorico
     *   }
     * })
     * 
     */
    delete<T extends ModuloHistoricoDeleteArgs>(args: SelectSubset<T, ModuloHistoricoDeleteArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuloHistorico.
     * @param {ModuloHistoricoUpdateArgs} args - Arguments to update one ModuloHistorico.
     * @example
     * // Update one ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloHistoricoUpdateArgs>(args: SelectSubset<T, ModuloHistoricoUpdateArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuloHistoricos.
     * @param {ModuloHistoricoDeleteManyArgs} args - Arguments to filter ModuloHistoricos to delete.
     * @example
     * // Delete a few ModuloHistoricos
     * const { count } = await prisma.moduloHistorico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloHistoricoDeleteManyArgs>(args?: SelectSubset<T, ModuloHistoricoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuloHistoricos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuloHistoricos
     * const moduloHistorico = await prisma.moduloHistorico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloHistoricoUpdateManyArgs>(args: SelectSubset<T, ModuloHistoricoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuloHistorico.
     * @param {ModuloHistoricoUpsertArgs} args - Arguments to update or create a ModuloHistorico.
     * @example
     * // Update or create a ModuloHistorico
     * const moduloHistorico = await prisma.moduloHistorico.upsert({
     *   create: {
     *     // ... data to create a ModuloHistorico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuloHistorico we want to update
     *   }
     * })
     */
    upsert<T extends ModuloHistoricoUpsertArgs>(args: SelectSubset<T, ModuloHistoricoUpsertArgs<ExtArgs>>): Prisma__ModuloHistoricoClient<$Result.GetResult<Prisma.$ModuloHistoricoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuloHistoricos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoCountArgs} args - Arguments to filter ModuloHistoricos to count.
     * @example
     * // Count the number of ModuloHistoricos
     * const count = await prisma.moduloHistorico.count({
     *   where: {
     *     // ... the filter for the ModuloHistoricos we want to count
     *   }
     * })
    **/
    count<T extends ModuloHistoricoCountArgs>(
      args?: Subset<T, ModuloHistoricoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloHistoricoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuloHistorico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloHistoricoAggregateArgs>(args: Subset<T, ModuloHistoricoAggregateArgs>): Prisma.PrismaPromise<GetModuloHistoricoAggregateType<T>>

    /**
     * Group by ModuloHistorico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloHistoricoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloHistoricoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloHistoricoGroupByArgs['orderBy'] }
        : { orderBy?: ModuloHistoricoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloHistoricoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloHistoricoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuloHistorico model
   */
  readonly fields: ModuloHistoricoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuloHistorico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloHistoricoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuloHistorico model
   */ 
  interface ModuloHistoricoFieldRefs {
    readonly id: FieldRef<"ModuloHistorico", 'String'>
    readonly empresaId: FieldRef<"ModuloHistorico", 'String'>
    readonly moduloId: FieldRef<"ModuloHistorico", 'String'>
    readonly accion: FieldRef<"ModuloHistorico", 'String'>
    readonly usuarioId: FieldRef<"ModuloHistorico", 'String'>
    readonly razon: FieldRef<"ModuloHistorico", 'String'>
    readonly fechaCreacion: FieldRef<"ModuloHistorico", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuloHistorico findUnique
   */
  export type ModuloHistoricoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloHistorico to fetch.
     */
    where: ModuloHistoricoWhereUniqueInput
  }

  /**
   * ModuloHistorico findUniqueOrThrow
   */
  export type ModuloHistoricoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloHistorico to fetch.
     */
    where: ModuloHistoricoWhereUniqueInput
  }

  /**
   * ModuloHistorico findFirst
   */
  export type ModuloHistoricoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloHistorico to fetch.
     */
    where?: ModuloHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloHistoricos to fetch.
     */
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloHistoricos.
     */
    cursor?: ModuloHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloHistoricos.
     */
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * ModuloHistorico findFirstOrThrow
   */
  export type ModuloHistoricoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloHistorico to fetch.
     */
    where?: ModuloHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloHistoricos to fetch.
     */
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuloHistoricos.
     */
    cursor?: ModuloHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuloHistoricos.
     */
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * ModuloHistorico findMany
   */
  export type ModuloHistoricoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which ModuloHistoricos to fetch.
     */
    where?: ModuloHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuloHistoricos to fetch.
     */
    orderBy?: ModuloHistoricoOrderByWithRelationInput | ModuloHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuloHistoricos.
     */
    cursor?: ModuloHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuloHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuloHistoricos.
     */
    skip?: number
    distinct?: ModuloHistoricoScalarFieldEnum | ModuloHistoricoScalarFieldEnum[]
  }

  /**
   * ModuloHistorico create
   */
  export type ModuloHistoricoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuloHistorico.
     */
    data: XOR<ModuloHistoricoCreateInput, ModuloHistoricoUncheckedCreateInput>
  }

  /**
   * ModuloHistorico createMany
   */
  export type ModuloHistoricoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuloHistoricos.
     */
    data: ModuloHistoricoCreateManyInput | ModuloHistoricoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuloHistorico createManyAndReturn
   */
  export type ModuloHistoricoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuloHistoricos.
     */
    data: ModuloHistoricoCreateManyInput | ModuloHistoricoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuloHistorico update
   */
  export type ModuloHistoricoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuloHistorico.
     */
    data: XOR<ModuloHistoricoUpdateInput, ModuloHistoricoUncheckedUpdateInput>
    /**
     * Choose, which ModuloHistorico to update.
     */
    where: ModuloHistoricoWhereUniqueInput
  }

  /**
   * ModuloHistorico updateMany
   */
  export type ModuloHistoricoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuloHistoricos.
     */
    data: XOR<ModuloHistoricoUpdateManyMutationInput, ModuloHistoricoUncheckedUpdateManyInput>
    /**
     * Filter which ModuloHistoricos to update
     */
    where?: ModuloHistoricoWhereInput
  }

  /**
   * ModuloHistorico upsert
   */
  export type ModuloHistoricoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuloHistorico to update in case it exists.
     */
    where: ModuloHistoricoWhereUniqueInput
    /**
     * In case the ModuloHistorico found by the `where` argument doesn't exist, create a new ModuloHistorico with this data.
     */
    create: XOR<ModuloHistoricoCreateInput, ModuloHistoricoUncheckedCreateInput>
    /**
     * In case the ModuloHistorico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloHistoricoUpdateInput, ModuloHistoricoUncheckedUpdateInput>
  }

  /**
   * ModuloHistorico delete
   */
  export type ModuloHistoricoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
    /**
     * Filter which ModuloHistorico to delete.
     */
    where: ModuloHistoricoWhereUniqueInput
  }

  /**
   * ModuloHistorico deleteMany
   */
  export type ModuloHistoricoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuloHistoricos to delete
     */
    where?: ModuloHistoricoWhereInput
  }

  /**
   * ModuloHistorico without action
   */
  export type ModuloHistoricoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloHistorico
     */
    select?: ModuloHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloHistoricoInclude<ExtArgs> | null
  }


  /**
   * Model PlanCuentas
   */

  export type AggregatePlanCuentas = {
    _count: PlanCuentasCountAggregateOutputType | null
    _avg: PlanCuentasAvgAggregateOutputType | null
    _sum: PlanCuentasSumAggregateOutputType | null
    _min: PlanCuentasMinAggregateOutputType | null
    _max: PlanCuentasMaxAggregateOutputType | null
  }

  export type PlanCuentasAvgAggregateOutputType = {
    nivel: number | null
    nivelMaximo: number | null
  }

  export type PlanCuentasSumAggregateOutputType = {
    nivel: number | null
    nivelMaximo: number | null
  }

  export type PlanCuentasMinAggregateOutputType = {
    id: string | null
    empresaId: string | null
    codigo: string | null
    codigoPadre: string | null
    nivel: number | null
    nombre: string | null
    nombreCompleto: string | null
    nombreCorto: string | null
    tipoMayor: string | null
    tipoDetalle: string | null
    naturaleza: string | null
    permiteMovimiento: boolean | null
    esAuxiliar: boolean | null
    nivelMaximo: number | null
    monedaPermitida: string | null
    centroCostoObligatorio: boolean | null
    proyectoObligatorio: boolean | null
    requiereReferencia: boolean | null
    requiereCliente: boolean | null
    requiereProveedor: boolean | null
    activo: boolean | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type PlanCuentasMaxAggregateOutputType = {
    id: string | null
    empresaId: string | null
    codigo: string | null
    codigoPadre: string | null
    nivel: number | null
    nombre: string | null
    nombreCompleto: string | null
    nombreCorto: string | null
    tipoMayor: string | null
    tipoDetalle: string | null
    naturaleza: string | null
    permiteMovimiento: boolean | null
    esAuxiliar: boolean | null
    nivelMaximo: number | null
    monedaPermitida: string | null
    centroCostoObligatorio: boolean | null
    proyectoObligatorio: boolean | null
    requiereReferencia: boolean | null
    requiereCliente: boolean | null
    requiereProveedor: boolean | null
    activo: boolean | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type PlanCuentasCountAggregateOutputType = {
    id: number
    empresaId: number
    codigo: number
    codigoPadre: number
    nivel: number
    nombre: number
    nombreCompleto: number
    nombreCorto: number
    tipoMayor: number
    tipoDetalle: number
    naturaleza: number
    permiteMovimiento: number
    esAuxiliar: number
    nivelMaximo: number
    monedaPermitida: number
    centroCostoObligatorio: number
    proyectoObligatorio: number
    requiereReferencia: number
    requiereCliente: number
    requiereProveedor: number
    activo: number
    fechaCreacion: number
    fechaActualizacion: number
    _all: number
  }


  export type PlanCuentasAvgAggregateInputType = {
    nivel?: true
    nivelMaximo?: true
  }

  export type PlanCuentasSumAggregateInputType = {
    nivel?: true
    nivelMaximo?: true
  }

  export type PlanCuentasMinAggregateInputType = {
    id?: true
    empresaId?: true
    codigo?: true
    codigoPadre?: true
    nivel?: true
    nombre?: true
    nombreCompleto?: true
    nombreCorto?: true
    tipoMayor?: true
    tipoDetalle?: true
    naturaleza?: true
    permiteMovimiento?: true
    esAuxiliar?: true
    nivelMaximo?: true
    monedaPermitida?: true
    centroCostoObligatorio?: true
    proyectoObligatorio?: true
    requiereReferencia?: true
    requiereCliente?: true
    requiereProveedor?: true
    activo?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type PlanCuentasMaxAggregateInputType = {
    id?: true
    empresaId?: true
    codigo?: true
    codigoPadre?: true
    nivel?: true
    nombre?: true
    nombreCompleto?: true
    nombreCorto?: true
    tipoMayor?: true
    tipoDetalle?: true
    naturaleza?: true
    permiteMovimiento?: true
    esAuxiliar?: true
    nivelMaximo?: true
    monedaPermitida?: true
    centroCostoObligatorio?: true
    proyectoObligatorio?: true
    requiereReferencia?: true
    requiereCliente?: true
    requiereProveedor?: true
    activo?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type PlanCuentasCountAggregateInputType = {
    id?: true
    empresaId?: true
    codigo?: true
    codigoPadre?: true
    nivel?: true
    nombre?: true
    nombreCompleto?: true
    nombreCorto?: true
    tipoMayor?: true
    tipoDetalle?: true
    naturaleza?: true
    permiteMovimiento?: true
    esAuxiliar?: true
    nivelMaximo?: true
    monedaPermitida?: true
    centroCostoObligatorio?: true
    proyectoObligatorio?: true
    requiereReferencia?: true
    requiereCliente?: true
    requiereProveedor?: true
    activo?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    _all?: true
  }

  export type PlanCuentasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanCuentas to aggregate.
     */
    where?: PlanCuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanCuentas to fetch.
     */
    orderBy?: PlanCuentasOrderByWithRelationInput | PlanCuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanCuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanCuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanCuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanCuentas
    **/
    _count?: true | PlanCuentasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanCuentasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanCuentasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanCuentasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanCuentasMaxAggregateInputType
  }

  export type GetPlanCuentasAggregateType<T extends PlanCuentasAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanCuentas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanCuentas[P]>
      : GetScalarType<T[P], AggregatePlanCuentas[P]>
  }




  export type PlanCuentasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanCuentasWhereInput
    orderBy?: PlanCuentasOrderByWithAggregationInput | PlanCuentasOrderByWithAggregationInput[]
    by: PlanCuentasScalarFieldEnum[] | PlanCuentasScalarFieldEnum
    having?: PlanCuentasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCuentasCountAggregateInputType | true
    _avg?: PlanCuentasAvgAggregateInputType
    _sum?: PlanCuentasSumAggregateInputType
    _min?: PlanCuentasMinAggregateInputType
    _max?: PlanCuentasMaxAggregateInputType
  }

  export type PlanCuentasGroupByOutputType = {
    id: string
    empresaId: string
    codigo: string
    codigoPadre: string | null
    nivel: number
    nombre: string
    nombreCompleto: string | null
    nombreCorto: string | null
    tipoMayor: string
    tipoDetalle: string | null
    naturaleza: string
    permiteMovimiento: boolean
    esAuxiliar: boolean
    nivelMaximo: number
    monedaPermitida: string
    centroCostoObligatorio: boolean
    proyectoObligatorio: boolean
    requiereReferencia: boolean
    requiereCliente: boolean
    requiereProveedor: boolean
    activo: boolean
    fechaCreacion: Date
    fechaActualizacion: Date
    _count: PlanCuentasCountAggregateOutputType | null
    _avg: PlanCuentasAvgAggregateOutputType | null
    _sum: PlanCuentasSumAggregateOutputType | null
    _min: PlanCuentasMinAggregateOutputType | null
    _max: PlanCuentasMaxAggregateOutputType | null
  }

  type GetPlanCuentasGroupByPayload<T extends PlanCuentasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanCuentasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanCuentasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanCuentasGroupByOutputType[P]>
            : GetScalarType<T[P], PlanCuentasGroupByOutputType[P]>
        }
      >
    >


  export type PlanCuentasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    codigo?: boolean
    codigoPadre?: boolean
    nivel?: boolean
    nombre?: boolean
    nombreCompleto?: boolean
    nombreCorto?: boolean
    tipoMayor?: boolean
    tipoDetalle?: boolean
    naturaleza?: boolean
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: boolean
    monedaPermitida?: boolean
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planCuentas"]>

  export type PlanCuentasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    codigo?: boolean
    codigoPadre?: boolean
    nivel?: boolean
    nombre?: boolean
    nombreCompleto?: boolean
    nombreCorto?: boolean
    tipoMayor?: boolean
    tipoDetalle?: boolean
    naturaleza?: boolean
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: boolean
    monedaPermitida?: boolean
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planCuentas"]>

  export type PlanCuentasSelectScalar = {
    id?: boolean
    empresaId?: boolean
    codigo?: boolean
    codigoPadre?: boolean
    nivel?: boolean
    nombre?: boolean
    nombreCompleto?: boolean
    nombreCorto?: boolean
    tipoMayor?: boolean
    tipoDetalle?: boolean
    naturaleza?: boolean
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: boolean
    monedaPermitida?: boolean
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
  }

  export type PlanCuentasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type PlanCuentasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $PlanCuentasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanCuentas"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empresaId: string
      codigo: string
      codigoPadre: string | null
      nivel: number
      nombre: string
      nombreCompleto: string | null
      nombreCorto: string | null
      tipoMayor: string
      tipoDetalle: string | null
      naturaleza: string
      permiteMovimiento: boolean
      esAuxiliar: boolean
      nivelMaximo: number
      monedaPermitida: string
      centroCostoObligatorio: boolean
      proyectoObligatorio: boolean
      requiereReferencia: boolean
      requiereCliente: boolean
      requiereProveedor: boolean
      activo: boolean
      fechaCreacion: Date
      fechaActualizacion: Date
    }, ExtArgs["result"]["planCuentas"]>
    composites: {}
  }

  type PlanCuentasGetPayload<S extends boolean | null | undefined | PlanCuentasDefaultArgs> = $Result.GetResult<Prisma.$PlanCuentasPayload, S>

  type PlanCuentasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanCuentasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCuentasCountAggregateInputType | true
    }

  export interface PlanCuentasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanCuentas'], meta: { name: 'PlanCuentas' } }
    /**
     * Find zero or one PlanCuentas that matches the filter.
     * @param {PlanCuentasFindUniqueArgs} args - Arguments to find a PlanCuentas
     * @example
     * // Get one PlanCuentas
     * const planCuentas = await prisma.planCuentas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanCuentasFindUniqueArgs>(args: SelectSubset<T, PlanCuentasFindUniqueArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanCuentas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanCuentasFindUniqueOrThrowArgs} args - Arguments to find a PlanCuentas
     * @example
     * // Get one PlanCuentas
     * const planCuentas = await prisma.planCuentas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanCuentasFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanCuentasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanCuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasFindFirstArgs} args - Arguments to find a PlanCuentas
     * @example
     * // Get one PlanCuentas
     * const planCuentas = await prisma.planCuentas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanCuentasFindFirstArgs>(args?: SelectSubset<T, PlanCuentasFindFirstArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanCuentas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasFindFirstOrThrowArgs} args - Arguments to find a PlanCuentas
     * @example
     * // Get one PlanCuentas
     * const planCuentas = await prisma.planCuentas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanCuentasFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanCuentasFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanCuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanCuentas
     * const planCuentas = await prisma.planCuentas.findMany()
     * 
     * // Get first 10 PlanCuentas
     * const planCuentas = await prisma.planCuentas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planCuentasWithIdOnly = await prisma.planCuentas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanCuentasFindManyArgs>(args?: SelectSubset<T, PlanCuentasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanCuentas.
     * @param {PlanCuentasCreateArgs} args - Arguments to create a PlanCuentas.
     * @example
     * // Create one PlanCuentas
     * const PlanCuentas = await prisma.planCuentas.create({
     *   data: {
     *     // ... data to create a PlanCuentas
     *   }
     * })
     * 
     */
    create<T extends PlanCuentasCreateArgs>(args: SelectSubset<T, PlanCuentasCreateArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanCuentas.
     * @param {PlanCuentasCreateManyArgs} args - Arguments to create many PlanCuentas.
     * @example
     * // Create many PlanCuentas
     * const planCuentas = await prisma.planCuentas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCuentasCreateManyArgs>(args?: SelectSubset<T, PlanCuentasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanCuentas and returns the data saved in the database.
     * @param {PlanCuentasCreateManyAndReturnArgs} args - Arguments to create many PlanCuentas.
     * @example
     * // Create many PlanCuentas
     * const planCuentas = await prisma.planCuentas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanCuentas and only return the `id`
     * const planCuentasWithIdOnly = await prisma.planCuentas.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCuentasCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCuentasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanCuentas.
     * @param {PlanCuentasDeleteArgs} args - Arguments to delete one PlanCuentas.
     * @example
     * // Delete one PlanCuentas
     * const PlanCuentas = await prisma.planCuentas.delete({
     *   where: {
     *     // ... filter to delete one PlanCuentas
     *   }
     * })
     * 
     */
    delete<T extends PlanCuentasDeleteArgs>(args: SelectSubset<T, PlanCuentasDeleteArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanCuentas.
     * @param {PlanCuentasUpdateArgs} args - Arguments to update one PlanCuentas.
     * @example
     * // Update one PlanCuentas
     * const planCuentas = await prisma.planCuentas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanCuentasUpdateArgs>(args: SelectSubset<T, PlanCuentasUpdateArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanCuentas.
     * @param {PlanCuentasDeleteManyArgs} args - Arguments to filter PlanCuentas to delete.
     * @example
     * // Delete a few PlanCuentas
     * const { count } = await prisma.planCuentas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanCuentasDeleteManyArgs>(args?: SelectSubset<T, PlanCuentasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanCuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanCuentas
     * const planCuentas = await prisma.planCuentas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanCuentasUpdateManyArgs>(args: SelectSubset<T, PlanCuentasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanCuentas.
     * @param {PlanCuentasUpsertArgs} args - Arguments to update or create a PlanCuentas.
     * @example
     * // Update or create a PlanCuentas
     * const planCuentas = await prisma.planCuentas.upsert({
     *   create: {
     *     // ... data to create a PlanCuentas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanCuentas we want to update
     *   }
     * })
     */
    upsert<T extends PlanCuentasUpsertArgs>(args: SelectSubset<T, PlanCuentasUpsertArgs<ExtArgs>>): Prisma__PlanCuentasClient<$Result.GetResult<Prisma.$PlanCuentasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanCuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasCountArgs} args - Arguments to filter PlanCuentas to count.
     * @example
     * // Count the number of PlanCuentas
     * const count = await prisma.planCuentas.count({
     *   where: {
     *     // ... the filter for the PlanCuentas we want to count
     *   }
     * })
    **/
    count<T extends PlanCuentasCountArgs>(
      args?: Subset<T, PlanCuentasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCuentasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanCuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanCuentasAggregateArgs>(args: Subset<T, PlanCuentasAggregateArgs>): Prisma.PrismaPromise<GetPlanCuentasAggregateType<T>>

    /**
     * Group by PlanCuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCuentasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanCuentasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanCuentasGroupByArgs['orderBy'] }
        : { orderBy?: PlanCuentasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanCuentasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanCuentasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanCuentas model
   */
  readonly fields: PlanCuentasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanCuentas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanCuentasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanCuentas model
   */ 
  interface PlanCuentasFieldRefs {
    readonly id: FieldRef<"PlanCuentas", 'String'>
    readonly empresaId: FieldRef<"PlanCuentas", 'String'>
    readonly codigo: FieldRef<"PlanCuentas", 'String'>
    readonly codigoPadre: FieldRef<"PlanCuentas", 'String'>
    readonly nivel: FieldRef<"PlanCuentas", 'Int'>
    readonly nombre: FieldRef<"PlanCuentas", 'String'>
    readonly nombreCompleto: FieldRef<"PlanCuentas", 'String'>
    readonly nombreCorto: FieldRef<"PlanCuentas", 'String'>
    readonly tipoMayor: FieldRef<"PlanCuentas", 'String'>
    readonly tipoDetalle: FieldRef<"PlanCuentas", 'String'>
    readonly naturaleza: FieldRef<"PlanCuentas", 'String'>
    readonly permiteMovimiento: FieldRef<"PlanCuentas", 'Boolean'>
    readonly esAuxiliar: FieldRef<"PlanCuentas", 'Boolean'>
    readonly nivelMaximo: FieldRef<"PlanCuentas", 'Int'>
    readonly monedaPermitida: FieldRef<"PlanCuentas", 'String'>
    readonly centroCostoObligatorio: FieldRef<"PlanCuentas", 'Boolean'>
    readonly proyectoObligatorio: FieldRef<"PlanCuentas", 'Boolean'>
    readonly requiereReferencia: FieldRef<"PlanCuentas", 'Boolean'>
    readonly requiereCliente: FieldRef<"PlanCuentas", 'Boolean'>
    readonly requiereProveedor: FieldRef<"PlanCuentas", 'Boolean'>
    readonly activo: FieldRef<"PlanCuentas", 'Boolean'>
    readonly fechaCreacion: FieldRef<"PlanCuentas", 'DateTime'>
    readonly fechaActualizacion: FieldRef<"PlanCuentas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanCuentas findUnique
   */
  export type PlanCuentasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter, which PlanCuentas to fetch.
     */
    where: PlanCuentasWhereUniqueInput
  }

  /**
   * PlanCuentas findUniqueOrThrow
   */
  export type PlanCuentasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter, which PlanCuentas to fetch.
     */
    where: PlanCuentasWhereUniqueInput
  }

  /**
   * PlanCuentas findFirst
   */
  export type PlanCuentasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter, which PlanCuentas to fetch.
     */
    where?: PlanCuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanCuentas to fetch.
     */
    orderBy?: PlanCuentasOrderByWithRelationInput | PlanCuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanCuentas.
     */
    cursor?: PlanCuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanCuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanCuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanCuentas.
     */
    distinct?: PlanCuentasScalarFieldEnum | PlanCuentasScalarFieldEnum[]
  }

  /**
   * PlanCuentas findFirstOrThrow
   */
  export type PlanCuentasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter, which PlanCuentas to fetch.
     */
    where?: PlanCuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanCuentas to fetch.
     */
    orderBy?: PlanCuentasOrderByWithRelationInput | PlanCuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanCuentas.
     */
    cursor?: PlanCuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanCuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanCuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanCuentas.
     */
    distinct?: PlanCuentasScalarFieldEnum | PlanCuentasScalarFieldEnum[]
  }

  /**
   * PlanCuentas findMany
   */
  export type PlanCuentasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter, which PlanCuentas to fetch.
     */
    where?: PlanCuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanCuentas to fetch.
     */
    orderBy?: PlanCuentasOrderByWithRelationInput | PlanCuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanCuentas.
     */
    cursor?: PlanCuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanCuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanCuentas.
     */
    skip?: number
    distinct?: PlanCuentasScalarFieldEnum | PlanCuentasScalarFieldEnum[]
  }

  /**
   * PlanCuentas create
   */
  export type PlanCuentasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanCuentas.
     */
    data: XOR<PlanCuentasCreateInput, PlanCuentasUncheckedCreateInput>
  }

  /**
   * PlanCuentas createMany
   */
  export type PlanCuentasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanCuentas.
     */
    data: PlanCuentasCreateManyInput | PlanCuentasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanCuentas createManyAndReturn
   */
  export type PlanCuentasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanCuentas.
     */
    data: PlanCuentasCreateManyInput | PlanCuentasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanCuentas update
   */
  export type PlanCuentasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanCuentas.
     */
    data: XOR<PlanCuentasUpdateInput, PlanCuentasUncheckedUpdateInput>
    /**
     * Choose, which PlanCuentas to update.
     */
    where: PlanCuentasWhereUniqueInput
  }

  /**
   * PlanCuentas updateMany
   */
  export type PlanCuentasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanCuentas.
     */
    data: XOR<PlanCuentasUpdateManyMutationInput, PlanCuentasUncheckedUpdateManyInput>
    /**
     * Filter which PlanCuentas to update
     */
    where?: PlanCuentasWhereInput
  }

  /**
   * PlanCuentas upsert
   */
  export type PlanCuentasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanCuentas to update in case it exists.
     */
    where: PlanCuentasWhereUniqueInput
    /**
     * In case the PlanCuentas found by the `where` argument doesn't exist, create a new PlanCuentas with this data.
     */
    create: XOR<PlanCuentasCreateInput, PlanCuentasUncheckedCreateInput>
    /**
     * In case the PlanCuentas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanCuentasUpdateInput, PlanCuentasUncheckedUpdateInput>
  }

  /**
   * PlanCuentas delete
   */
  export type PlanCuentasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
    /**
     * Filter which PlanCuentas to delete.
     */
    where: PlanCuentasWhereUniqueInput
  }

  /**
   * PlanCuentas deleteMany
   */
  export type PlanCuentasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanCuentas to delete
     */
    where?: PlanCuentasWhereInput
  }

  /**
   * PlanCuentas without action
   */
  export type PlanCuentasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCuentas
     */
    select?: PlanCuentasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanCuentasInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmpresaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    ruc: 'ruc',
    activo: 'activo',
    direccion: 'direccion',
    email: 'email',
    fechaActualizacion: 'fechaActualizacion',
    fechaCreacion: 'fechaCreacion',
    telefono: 'telefono',
    plan: 'plan'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    email: 'email',
    nombre: 'nombre',
    apellido: 'apellido',
    password: 'password',
    empresaId: 'empresaId',
    rolId: 'rolId',
    activo: 'activo',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ModuloScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    displayName: 'displayName',
    version: 'version',
    activo: 'activo',
    color: 'color',
    descripcion: 'descripcion',
    icono: 'icono',
    orden: 'orden'
  };

  export type ModuloScalarFieldEnum = (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum]


  export const EmpresaModuloScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    moduloId: 'moduloId',
    activo: 'activo',
    configuracion: 'configuracion',
    fechaActivacion: 'fechaActivacion',
    fechaDesactivacion: 'fechaDesactivacion'
  };

  export type EmpresaModuloScalarFieldEnum = (typeof EmpresaModuloScalarFieldEnum)[keyof typeof EmpresaModuloScalarFieldEnum]


  export const ModuloDependenciaScalarFieldEnum: {
    id: 'id',
    moduloId: 'moduloId',
    dependeDeId: 'dependeDeId',
    requerido: 'requerido'
  };

  export type ModuloDependenciaScalarFieldEnum = (typeof ModuloDependenciaScalarFieldEnum)[keyof typeof ModuloDependenciaScalarFieldEnum]


  export const ModuloRutaScalarFieldEnum: {
    id: 'id',
    moduloId: 'moduloId',
    ruta: 'ruta',
    activo: 'activo',
    descripcion: 'descripcion',
    nombre: 'nombre'
  };

  export type ModuloRutaScalarFieldEnum = (typeof ModuloRutaScalarFieldEnum)[keyof typeof ModuloRutaScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    activo: 'activo',
    descripcion: 'descripcion'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const ModuloPermisoScalarFieldEnum: {
    id: 'id',
    moduloId: 'moduloId',
    nombre: 'nombre',
    codigo: 'codigo',
    descripcion: 'descripcion'
  };

  export type ModuloPermisoScalarFieldEnum = (typeof ModuloPermisoScalarFieldEnum)[keyof typeof ModuloPermisoScalarFieldEnum]


  export const RolPermisoScalarFieldEnum: {
    id: 'id',
    rolId: 'rolId',
    permisoId: 'permisoId'
  };

  export type RolPermisoScalarFieldEnum = (typeof RolPermisoScalarFieldEnum)[keyof typeof RolPermisoScalarFieldEnum]


  export const EmpresaConfiguracionScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    clave: 'clave',
    valor: 'valor',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmpresaConfiguracionScalarFieldEnum = (typeof EmpresaConfiguracionScalarFieldEnum)[keyof typeof EmpresaConfiguracionScalarFieldEnum]


  export const FacturaScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacturaScalarFieldEnum = (typeof FacturaScalarFieldEnum)[keyof typeof FacturaScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const MovimientoCajaScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovimientoCajaScalarFieldEnum = (typeof MovimientoCajaScalarFieldEnum)[keyof typeof MovimientoCajaScalarFieldEnum]


  export const ModuloHistoricoScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    moduloId: 'moduloId',
    accion: 'accion',
    usuarioId: 'usuarioId',
    razon: 'razon',
    fechaCreacion: 'fechaCreacion'
  };

  export type ModuloHistoricoScalarFieldEnum = (typeof ModuloHistoricoScalarFieldEnum)[keyof typeof ModuloHistoricoScalarFieldEnum]


  export const PlanCuentasScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    codigo: 'codigo',
    codigoPadre: 'codigoPadre',
    nivel: 'nivel',
    nombre: 'nombre',
    nombreCompleto: 'nombreCompleto',
    nombreCorto: 'nombreCorto',
    tipoMayor: 'tipoMayor',
    tipoDetalle: 'tipoDetalle',
    naturaleza: 'naturaleza',
    permiteMovimiento: 'permiteMovimiento',
    esAuxiliar: 'esAuxiliar',
    nivelMaximo: 'nivelMaximo',
    monedaPermitida: 'monedaPermitida',
    centroCostoObligatorio: 'centroCostoObligatorio',
    proyectoObligatorio: 'proyectoObligatorio',
    requiereReferencia: 'requiereReferencia',
    requiereCliente: 'requiereCliente',
    requiereProveedor: 'requiereProveedor',
    activo: 'activo',
    fechaCreacion: 'fechaCreacion',
    fechaActualizacion: 'fechaActualizacion'
  };

  export type PlanCuentasScalarFieldEnum = (typeof PlanCuentasScalarFieldEnum)[keyof typeof PlanCuentasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id?: StringFilter<"Empresa"> | string
    nombre?: StringFilter<"Empresa"> | string
    ruc?: StringFilter<"Empresa"> | string
    activo?: BoolFilter<"Empresa"> | boolean
    direccion?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    fechaActualizacion?: DateTimeFilter<"Empresa"> | Date | string
    fechaCreacion?: DateTimeFilter<"Empresa"> | Date | string
    telefono?: StringNullableFilter<"Empresa"> | string | null
    plan?: EnumPlanTypeFilter<"Empresa"> | $Enums.PlanType
    clientes?: ClienteListRelationFilter
    configuraciones?: EmpresaConfiguracionListRelationFilter
    modulosActivos?: EmpresaModuloListRelationFilter
    moduloHistorico?: ModuloHistoricoListRelationFilter
    facturas?: FacturaListRelationFilter
    movimientosCaja?: MovimientoCajaListRelationFilter
    productos?: ProductoListRelationFilter
    usuarios?: UsuarioListRelationFilter
    planCuentas?: PlanCuentasListRelationFilter
  }

  export type EmpresaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ruc?: SortOrder
    activo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    fechaActualizacion?: SortOrder
    fechaCreacion?: SortOrder
    telefono?: SortOrderInput | SortOrder
    plan?: SortOrder
    clientes?: ClienteOrderByRelationAggregateInput
    configuraciones?: EmpresaConfiguracionOrderByRelationAggregateInput
    modulosActivos?: EmpresaModuloOrderByRelationAggregateInput
    moduloHistorico?: ModuloHistoricoOrderByRelationAggregateInput
    facturas?: FacturaOrderByRelationAggregateInput
    movimientosCaja?: MovimientoCajaOrderByRelationAggregateInput
    productos?: ProductoOrderByRelationAggregateInput
    usuarios?: UsuarioOrderByRelationAggregateInput
    planCuentas?: PlanCuentasOrderByRelationAggregateInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ruc?: string
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    nombre?: StringFilter<"Empresa"> | string
    activo?: BoolFilter<"Empresa"> | boolean
    direccion?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    fechaActualizacion?: DateTimeFilter<"Empresa"> | Date | string
    fechaCreacion?: DateTimeFilter<"Empresa"> | Date | string
    telefono?: StringNullableFilter<"Empresa"> | string | null
    plan?: EnumPlanTypeFilter<"Empresa"> | $Enums.PlanType
    clientes?: ClienteListRelationFilter
    configuraciones?: EmpresaConfiguracionListRelationFilter
    modulosActivos?: EmpresaModuloListRelationFilter
    moduloHistorico?: ModuloHistoricoListRelationFilter
    facturas?: FacturaListRelationFilter
    movimientosCaja?: MovimientoCajaListRelationFilter
    productos?: ProductoListRelationFilter
    usuarios?: UsuarioListRelationFilter
    planCuentas?: PlanCuentasListRelationFilter
  }, "id" | "ruc">

  export type EmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ruc?: SortOrder
    activo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    fechaActualizacion?: SortOrder
    fechaCreacion?: SortOrder
    telefono?: SortOrderInput | SortOrder
    plan?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Empresa"> | string
    nombre?: StringWithAggregatesFilter<"Empresa"> | string
    ruc?: StringWithAggregatesFilter<"Empresa"> | string
    activo?: BoolWithAggregatesFilter<"Empresa"> | boolean
    direccion?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    email?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    fechaActualizacion?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    fechaCreacion?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    telefono?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    plan?: EnumPlanTypeWithAggregatesFilter<"Empresa"> | $Enums.PlanType
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringNullableFilter<"Usuario"> | string | null
    password?: StringFilter<"Usuario"> | string
    empresaId?: StringFilter<"Usuario"> | string
    rolId?: StringFilter<"Usuario"> | string
    activo?: BoolFilter<"Usuario"> | boolean
    resetToken?: StringNullableFilter<"Usuario"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
    moduloHistorico?: ModuloHistoricoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    password?: SortOrder
    empresaId?: SortOrder
    rolId?: SortOrder
    activo?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    empresa?: EmpresaOrderByWithRelationInput
    rol?: RolOrderByWithRelationInput
    moduloHistorico?: ModuloHistoricoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringNullableFilter<"Usuario"> | string | null
    password?: StringFilter<"Usuario"> | string
    empresaId?: StringFilter<"Usuario"> | string
    rolId?: StringFilter<"Usuario"> | string
    activo?: BoolFilter<"Usuario"> | boolean
    resetToken?: StringNullableFilter<"Usuario"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
    moduloHistorico?: ModuloHistoricoListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    password?: SortOrder
    empresaId?: SortOrder
    rolId?: SortOrder
    activo?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellido?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    password?: StringWithAggregatesFilter<"Usuario"> | string
    empresaId?: StringWithAggregatesFilter<"Usuario"> | string
    rolId?: StringWithAggregatesFilter<"Usuario"> | string
    activo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    resetToken?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
  }

  export type ModuloWhereInput = {
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    id?: StringFilter<"Modulo"> | string
    nombre?: StringFilter<"Modulo"> | string
    displayName?: StringFilter<"Modulo"> | string
    version?: StringFilter<"Modulo"> | string
    activo?: BoolFilter<"Modulo"> | boolean
    color?: StringNullableFilter<"Modulo"> | string | null
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    icono?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    empresasConModulo?: EmpresaModuloListRelationFilter
    moduloHistorico?: ModuloHistoricoListRelationFilter
    esDependenciaDe?: ModuloDependenciaListRelationFilter
    dependeDe?: ModuloDependenciaListRelationFilter
    permisos?: ModuloPermisoListRelationFilter
    rutas?: ModuloRutaListRelationFilter
  }

  export type ModuloOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    displayName?: SortOrder
    version?: SortOrder
    activo?: SortOrder
    color?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    orden?: SortOrder
    empresasConModulo?: EmpresaModuloOrderByRelationAggregateInput
    moduloHistorico?: ModuloHistoricoOrderByRelationAggregateInput
    esDependenciaDe?: ModuloDependenciaOrderByRelationAggregateInput
    dependeDe?: ModuloDependenciaOrderByRelationAggregateInput
    permisos?: ModuloPermisoOrderByRelationAggregateInput
    rutas?: ModuloRutaOrderByRelationAggregateInput
  }

  export type ModuloWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    displayName?: StringFilter<"Modulo"> | string
    version?: StringFilter<"Modulo"> | string
    activo?: BoolFilter<"Modulo"> | boolean
    color?: StringNullableFilter<"Modulo"> | string | null
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    icono?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    empresasConModulo?: EmpresaModuloListRelationFilter
    moduloHistorico?: ModuloHistoricoListRelationFilter
    esDependenciaDe?: ModuloDependenciaListRelationFilter
    dependeDe?: ModuloDependenciaListRelationFilter
    permisos?: ModuloPermisoListRelationFilter
    rutas?: ModuloRutaListRelationFilter
  }, "id" | "nombre">

  export type ModuloOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    displayName?: SortOrder
    version?: SortOrder
    activo?: SortOrder
    color?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    orden?: SortOrder
    _count?: ModuloCountOrderByAggregateInput
    _avg?: ModuloAvgOrderByAggregateInput
    _max?: ModuloMaxOrderByAggregateInput
    _min?: ModuloMinOrderByAggregateInput
    _sum?: ModuloSumOrderByAggregateInput
  }

  export type ModuloScalarWhereWithAggregatesInput = {
    AND?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    OR?: ModuloScalarWhereWithAggregatesInput[]
    NOT?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Modulo"> | string
    nombre?: StringWithAggregatesFilter<"Modulo"> | string
    displayName?: StringWithAggregatesFilter<"Modulo"> | string
    version?: StringWithAggregatesFilter<"Modulo"> | string
    activo?: BoolWithAggregatesFilter<"Modulo"> | boolean
    color?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    icono?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    orden?: IntWithAggregatesFilter<"Modulo"> | number
  }

  export type EmpresaModuloWhereInput = {
    AND?: EmpresaModuloWhereInput | EmpresaModuloWhereInput[]
    OR?: EmpresaModuloWhereInput[]
    NOT?: EmpresaModuloWhereInput | EmpresaModuloWhereInput[]
    id?: StringFilter<"EmpresaModulo"> | string
    empresaId?: StringFilter<"EmpresaModulo"> | string
    moduloId?: StringFilter<"EmpresaModulo"> | string
    activo?: BoolFilter<"EmpresaModulo"> | boolean
    configuracion?: JsonNullableFilter<"EmpresaModulo">
    fechaActivacion?: DateTimeFilter<"EmpresaModulo"> | Date | string
    fechaDesactivacion?: DateTimeNullableFilter<"EmpresaModulo"> | Date | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }

  export type EmpresaModuloOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    activo?: SortOrder
    configuracion?: SortOrderInput | SortOrder
    fechaActivacion?: SortOrder
    fechaDesactivacion?: SortOrderInput | SortOrder
    empresa?: EmpresaOrderByWithRelationInput
    modulo?: ModuloOrderByWithRelationInput
  }

  export type EmpresaModuloWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    empresaId_moduloId?: EmpresaModuloEmpresaIdModuloIdCompoundUniqueInput
    AND?: EmpresaModuloWhereInput | EmpresaModuloWhereInput[]
    OR?: EmpresaModuloWhereInput[]
    NOT?: EmpresaModuloWhereInput | EmpresaModuloWhereInput[]
    empresaId?: StringFilter<"EmpresaModulo"> | string
    moduloId?: StringFilter<"EmpresaModulo"> | string
    activo?: BoolFilter<"EmpresaModulo"> | boolean
    configuracion?: JsonNullableFilter<"EmpresaModulo">
    fechaActivacion?: DateTimeFilter<"EmpresaModulo"> | Date | string
    fechaDesactivacion?: DateTimeNullableFilter<"EmpresaModulo"> | Date | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }, "id" | "empresaId_moduloId">

  export type EmpresaModuloOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    activo?: SortOrder
    configuracion?: SortOrderInput | SortOrder
    fechaActivacion?: SortOrder
    fechaDesactivacion?: SortOrderInput | SortOrder
    _count?: EmpresaModuloCountOrderByAggregateInput
    _max?: EmpresaModuloMaxOrderByAggregateInput
    _min?: EmpresaModuloMinOrderByAggregateInput
  }

  export type EmpresaModuloScalarWhereWithAggregatesInput = {
    AND?: EmpresaModuloScalarWhereWithAggregatesInput | EmpresaModuloScalarWhereWithAggregatesInput[]
    OR?: EmpresaModuloScalarWhereWithAggregatesInput[]
    NOT?: EmpresaModuloScalarWhereWithAggregatesInput | EmpresaModuloScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmpresaModulo"> | string
    empresaId?: StringWithAggregatesFilter<"EmpresaModulo"> | string
    moduloId?: StringWithAggregatesFilter<"EmpresaModulo"> | string
    activo?: BoolWithAggregatesFilter<"EmpresaModulo"> | boolean
    configuracion?: JsonNullableWithAggregatesFilter<"EmpresaModulo">
    fechaActivacion?: DateTimeWithAggregatesFilter<"EmpresaModulo"> | Date | string
    fechaDesactivacion?: DateTimeNullableWithAggregatesFilter<"EmpresaModulo"> | Date | string | null
  }

  export type ModuloDependenciaWhereInput = {
    AND?: ModuloDependenciaWhereInput | ModuloDependenciaWhereInput[]
    OR?: ModuloDependenciaWhereInput[]
    NOT?: ModuloDependenciaWhereInput | ModuloDependenciaWhereInput[]
    id?: StringFilter<"ModuloDependencia"> | string
    moduloId?: StringFilter<"ModuloDependencia"> | string
    dependeDeId?: StringFilter<"ModuloDependencia"> | string
    requerido?: BoolFilter<"ModuloDependencia"> | boolean
    dependeDe?: XOR<ModuloRelationFilter, ModuloWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }

  export type ModuloDependenciaOrderByWithRelationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    dependeDeId?: SortOrder
    requerido?: SortOrder
    dependeDe?: ModuloOrderByWithRelationInput
    modulo?: ModuloOrderByWithRelationInput
  }

  export type ModuloDependenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduloId_dependeDeId?: ModuloDependenciaModuloIdDependeDeIdCompoundUniqueInput
    AND?: ModuloDependenciaWhereInput | ModuloDependenciaWhereInput[]
    OR?: ModuloDependenciaWhereInput[]
    NOT?: ModuloDependenciaWhereInput | ModuloDependenciaWhereInput[]
    moduloId?: StringFilter<"ModuloDependencia"> | string
    dependeDeId?: StringFilter<"ModuloDependencia"> | string
    requerido?: BoolFilter<"ModuloDependencia"> | boolean
    dependeDe?: XOR<ModuloRelationFilter, ModuloWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }, "id" | "moduloId_dependeDeId">

  export type ModuloDependenciaOrderByWithAggregationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    dependeDeId?: SortOrder
    requerido?: SortOrder
    _count?: ModuloDependenciaCountOrderByAggregateInput
    _max?: ModuloDependenciaMaxOrderByAggregateInput
    _min?: ModuloDependenciaMinOrderByAggregateInput
  }

  export type ModuloDependenciaScalarWhereWithAggregatesInput = {
    AND?: ModuloDependenciaScalarWhereWithAggregatesInput | ModuloDependenciaScalarWhereWithAggregatesInput[]
    OR?: ModuloDependenciaScalarWhereWithAggregatesInput[]
    NOT?: ModuloDependenciaScalarWhereWithAggregatesInput | ModuloDependenciaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuloDependencia"> | string
    moduloId?: StringWithAggregatesFilter<"ModuloDependencia"> | string
    dependeDeId?: StringWithAggregatesFilter<"ModuloDependencia"> | string
    requerido?: BoolWithAggregatesFilter<"ModuloDependencia"> | boolean
  }

  export type ModuloRutaWhereInput = {
    AND?: ModuloRutaWhereInput | ModuloRutaWhereInput[]
    OR?: ModuloRutaWhereInput[]
    NOT?: ModuloRutaWhereInput | ModuloRutaWhereInput[]
    id?: StringFilter<"ModuloRuta"> | string
    moduloId?: StringFilter<"ModuloRuta"> | string
    ruta?: StringFilter<"ModuloRuta"> | string
    activo?: BoolFilter<"ModuloRuta"> | boolean
    descripcion?: StringNullableFilter<"ModuloRuta"> | string | null
    nombre?: StringFilter<"ModuloRuta"> | string
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }

  export type ModuloRutaOrderByWithRelationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    ruta?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    nombre?: SortOrder
    modulo?: ModuloOrderByWithRelationInput
  }

  export type ModuloRutaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuloRutaWhereInput | ModuloRutaWhereInput[]
    OR?: ModuloRutaWhereInput[]
    NOT?: ModuloRutaWhereInput | ModuloRutaWhereInput[]
    moduloId?: StringFilter<"ModuloRuta"> | string
    ruta?: StringFilter<"ModuloRuta"> | string
    activo?: BoolFilter<"ModuloRuta"> | boolean
    descripcion?: StringNullableFilter<"ModuloRuta"> | string | null
    nombre?: StringFilter<"ModuloRuta"> | string
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }, "id">

  export type ModuloRutaOrderByWithAggregationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    ruta?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    nombre?: SortOrder
    _count?: ModuloRutaCountOrderByAggregateInput
    _max?: ModuloRutaMaxOrderByAggregateInput
    _min?: ModuloRutaMinOrderByAggregateInput
  }

  export type ModuloRutaScalarWhereWithAggregatesInput = {
    AND?: ModuloRutaScalarWhereWithAggregatesInput | ModuloRutaScalarWhereWithAggregatesInput[]
    OR?: ModuloRutaScalarWhereWithAggregatesInput[]
    NOT?: ModuloRutaScalarWhereWithAggregatesInput | ModuloRutaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuloRuta"> | string
    moduloId?: StringWithAggregatesFilter<"ModuloRuta"> | string
    ruta?: StringWithAggregatesFilter<"ModuloRuta"> | string
    activo?: BoolWithAggregatesFilter<"ModuloRuta"> | boolean
    descripcion?: StringNullableWithAggregatesFilter<"ModuloRuta"> | string | null
    nombre?: StringWithAggregatesFilter<"ModuloRuta"> | string
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: StringFilter<"Rol"> | string
    nombre?: StringFilter<"Rol"> | string
    activo?: BoolFilter<"Rol"> | boolean
    descripcion?: StringNullableFilter<"Rol"> | string | null
    permisos?: RolPermisoListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    permisos?: RolPermisoOrderByRelationAggregateInput
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    nombre?: StringFilter<"Rol"> | string
    activo?: BoolFilter<"Rol"> | boolean
    descripcion?: StringNullableFilter<"Rol"> | string | null
    permisos?: RolPermisoListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }, "id">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: RolCountOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rol"> | string
    nombre?: StringWithAggregatesFilter<"Rol"> | string
    activo?: BoolWithAggregatesFilter<"Rol"> | boolean
    descripcion?: StringNullableWithAggregatesFilter<"Rol"> | string | null
  }

  export type ModuloPermisoWhereInput = {
    AND?: ModuloPermisoWhereInput | ModuloPermisoWhereInput[]
    OR?: ModuloPermisoWhereInput[]
    NOT?: ModuloPermisoWhereInput | ModuloPermisoWhereInput[]
    id?: StringFilter<"ModuloPermiso"> | string
    moduloId?: StringFilter<"ModuloPermiso"> | string
    nombre?: StringFilter<"ModuloPermiso"> | string
    codigo?: StringFilter<"ModuloPermiso"> | string
    descripcion?: StringNullableFilter<"ModuloPermiso"> | string | null
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
    roles?: RolPermisoListRelationFilter
  }

  export type ModuloPermisoOrderByWithRelationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    modulo?: ModuloOrderByWithRelationInput
    roles?: RolPermisoOrderByRelationAggregateInput
  }

  export type ModuloPermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduloId_codigo?: ModuloPermisoModuloIdCodigoCompoundUniqueInput
    AND?: ModuloPermisoWhereInput | ModuloPermisoWhereInput[]
    OR?: ModuloPermisoWhereInput[]
    NOT?: ModuloPermisoWhereInput | ModuloPermisoWhereInput[]
    moduloId?: StringFilter<"ModuloPermiso"> | string
    nombre?: StringFilter<"ModuloPermiso"> | string
    codigo?: StringFilter<"ModuloPermiso"> | string
    descripcion?: StringNullableFilter<"ModuloPermiso"> | string | null
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
    roles?: RolPermisoListRelationFilter
  }, "id" | "moduloId_codigo">

  export type ModuloPermisoOrderByWithAggregationInput = {
    id?: SortOrder
    moduloId?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: ModuloPermisoCountOrderByAggregateInput
    _max?: ModuloPermisoMaxOrderByAggregateInput
    _min?: ModuloPermisoMinOrderByAggregateInput
  }

  export type ModuloPermisoScalarWhereWithAggregatesInput = {
    AND?: ModuloPermisoScalarWhereWithAggregatesInput | ModuloPermisoScalarWhereWithAggregatesInput[]
    OR?: ModuloPermisoScalarWhereWithAggregatesInput[]
    NOT?: ModuloPermisoScalarWhereWithAggregatesInput | ModuloPermisoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuloPermiso"> | string
    moduloId?: StringWithAggregatesFilter<"ModuloPermiso"> | string
    nombre?: StringWithAggregatesFilter<"ModuloPermiso"> | string
    codigo?: StringWithAggregatesFilter<"ModuloPermiso"> | string
    descripcion?: StringNullableWithAggregatesFilter<"ModuloPermiso"> | string | null
  }

  export type RolPermisoWhereInput = {
    AND?: RolPermisoWhereInput | RolPermisoWhereInput[]
    OR?: RolPermisoWhereInput[]
    NOT?: RolPermisoWhereInput | RolPermisoWhereInput[]
    id?: StringFilter<"RolPermiso"> | string
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
    permiso?: XOR<ModuloPermisoRelationFilter, ModuloPermisoWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
  }

  export type RolPermisoOrderByWithRelationInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    permiso?: ModuloPermisoOrderByWithRelationInput
    rol?: RolOrderByWithRelationInput
  }

  export type RolPermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rolId_permisoId?: RolPermisoRolIdPermisoIdCompoundUniqueInput
    AND?: RolPermisoWhereInput | RolPermisoWhereInput[]
    OR?: RolPermisoWhereInput[]
    NOT?: RolPermisoWhereInput | RolPermisoWhereInput[]
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
    permiso?: XOR<ModuloPermisoRelationFilter, ModuloPermisoWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
  }, "id" | "rolId_permisoId">

  export type RolPermisoOrderByWithAggregationInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    _count?: RolPermisoCountOrderByAggregateInput
    _max?: RolPermisoMaxOrderByAggregateInput
    _min?: RolPermisoMinOrderByAggregateInput
  }

  export type RolPermisoScalarWhereWithAggregatesInput = {
    AND?: RolPermisoScalarWhereWithAggregatesInput | RolPermisoScalarWhereWithAggregatesInput[]
    OR?: RolPermisoScalarWhereWithAggregatesInput[]
    NOT?: RolPermisoScalarWhereWithAggregatesInput | RolPermisoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolPermiso"> | string
    rolId?: StringWithAggregatesFilter<"RolPermiso"> | string
    permisoId?: StringWithAggregatesFilter<"RolPermiso"> | string
  }

  export type EmpresaConfiguracionWhereInput = {
    AND?: EmpresaConfiguracionWhereInput | EmpresaConfiguracionWhereInput[]
    OR?: EmpresaConfiguracionWhereInput[]
    NOT?: EmpresaConfiguracionWhereInput | EmpresaConfiguracionWhereInput[]
    id?: StringFilter<"EmpresaConfiguracion"> | string
    empresaId?: StringFilter<"EmpresaConfiguracion"> | string
    clave?: StringFilter<"EmpresaConfiguracion"> | string
    valor?: JsonFilter<"EmpresaConfiguracion">
    activo?: BoolFilter<"EmpresaConfiguracion"> | boolean
    createdAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
    updatedAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type EmpresaConfiguracionOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type EmpresaConfiguracionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    empresaId_clave?: EmpresaConfiguracionEmpresaIdClaveCompoundUniqueInput
    AND?: EmpresaConfiguracionWhereInput | EmpresaConfiguracionWhereInput[]
    OR?: EmpresaConfiguracionWhereInput[]
    NOT?: EmpresaConfiguracionWhereInput | EmpresaConfiguracionWhereInput[]
    empresaId?: StringFilter<"EmpresaConfiguracion"> | string
    clave?: StringFilter<"EmpresaConfiguracion"> | string
    valor?: JsonFilter<"EmpresaConfiguracion">
    activo?: BoolFilter<"EmpresaConfiguracion"> | boolean
    createdAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
    updatedAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id" | "empresaId_clave">

  export type EmpresaConfiguracionOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmpresaConfiguracionCountOrderByAggregateInput
    _max?: EmpresaConfiguracionMaxOrderByAggregateInput
    _min?: EmpresaConfiguracionMinOrderByAggregateInput
  }

  export type EmpresaConfiguracionScalarWhereWithAggregatesInput = {
    AND?: EmpresaConfiguracionScalarWhereWithAggregatesInput | EmpresaConfiguracionScalarWhereWithAggregatesInput[]
    OR?: EmpresaConfiguracionScalarWhereWithAggregatesInput[]
    NOT?: EmpresaConfiguracionScalarWhereWithAggregatesInput | EmpresaConfiguracionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmpresaConfiguracion"> | string
    empresaId?: StringWithAggregatesFilter<"EmpresaConfiguracion"> | string
    clave?: StringWithAggregatesFilter<"EmpresaConfiguracion"> | string
    valor?: JsonWithAggregatesFilter<"EmpresaConfiguracion">
    activo?: BoolWithAggregatesFilter<"EmpresaConfiguracion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmpresaConfiguracion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmpresaConfiguracion"> | Date | string
  }

  export type FacturaWhereInput = {
    AND?: FacturaWhereInput | FacturaWhereInput[]
    OR?: FacturaWhereInput[]
    NOT?: FacturaWhereInput | FacturaWhereInput[]
    id?: StringFilter<"Factura"> | string
    empresaId?: StringFilter<"Factura"> | string
    createdAt?: DateTimeFilter<"Factura"> | Date | string
    updatedAt?: DateTimeFilter<"Factura"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type FacturaOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type FacturaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacturaWhereInput | FacturaWhereInput[]
    OR?: FacturaWhereInput[]
    NOT?: FacturaWhereInput | FacturaWhereInput[]
    empresaId?: StringFilter<"Factura"> | string
    createdAt?: DateTimeFilter<"Factura"> | Date | string
    updatedAt?: DateTimeFilter<"Factura"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type FacturaOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacturaCountOrderByAggregateInput
    _max?: FacturaMaxOrderByAggregateInput
    _min?: FacturaMinOrderByAggregateInput
  }

  export type FacturaScalarWhereWithAggregatesInput = {
    AND?: FacturaScalarWhereWithAggregatesInput | FacturaScalarWhereWithAggregatesInput[]
    OR?: FacturaScalarWhereWithAggregatesInput[]
    NOT?: FacturaScalarWhereWithAggregatesInput | FacturaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Factura"> | string
    empresaId?: StringWithAggregatesFilter<"Factura"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Factura"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Factura"> | Date | string
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id?: StringFilter<"Producto"> | string
    empresaId?: StringFilter<"Producto"> | string
    createdAt?: DateTimeFilter<"Producto"> | Date | string
    updatedAt?: DateTimeFilter<"Producto"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    empresaId?: StringFilter<"Producto"> | string
    createdAt?: DateTimeFilter<"Producto"> | Date | string
    updatedAt?: DateTimeFilter<"Producto"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Producto"> | string
    empresaId?: StringWithAggregatesFilter<"Producto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Producto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Producto"> | Date | string
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: StringFilter<"Cliente"> | string
    empresaId?: StringFilter<"Cliente"> | string
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    empresaId?: StringFilter<"Cliente"> | string
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cliente"> | string
    empresaId?: StringWithAggregatesFilter<"Cliente"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
  }

  export type MovimientoCajaWhereInput = {
    AND?: MovimientoCajaWhereInput | MovimientoCajaWhereInput[]
    OR?: MovimientoCajaWhereInput[]
    NOT?: MovimientoCajaWhereInput | MovimientoCajaWhereInput[]
    id?: StringFilter<"MovimientoCaja"> | string
    empresaId?: StringFilter<"MovimientoCaja"> | string
    createdAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
    updatedAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type MovimientoCajaOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type MovimientoCajaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MovimientoCajaWhereInput | MovimientoCajaWhereInput[]
    OR?: MovimientoCajaWhereInput[]
    NOT?: MovimientoCajaWhereInput | MovimientoCajaWhereInput[]
    empresaId?: StringFilter<"MovimientoCaja"> | string
    createdAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
    updatedAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type MovimientoCajaOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovimientoCajaCountOrderByAggregateInput
    _max?: MovimientoCajaMaxOrderByAggregateInput
    _min?: MovimientoCajaMinOrderByAggregateInput
  }

  export type MovimientoCajaScalarWhereWithAggregatesInput = {
    AND?: MovimientoCajaScalarWhereWithAggregatesInput | MovimientoCajaScalarWhereWithAggregatesInput[]
    OR?: MovimientoCajaScalarWhereWithAggregatesInput[]
    NOT?: MovimientoCajaScalarWhereWithAggregatesInput | MovimientoCajaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovimientoCaja"> | string
    empresaId?: StringWithAggregatesFilter<"MovimientoCaja"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MovimientoCaja"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MovimientoCaja"> | Date | string
  }

  export type ModuloHistoricoWhereInput = {
    AND?: ModuloHistoricoWhereInput | ModuloHistoricoWhereInput[]
    OR?: ModuloHistoricoWhereInput[]
    NOT?: ModuloHistoricoWhereInput | ModuloHistoricoWhereInput[]
    id?: StringFilter<"ModuloHistorico"> | string
    empresaId?: StringFilter<"ModuloHistorico"> | string
    moduloId?: StringFilter<"ModuloHistorico"> | string
    accion?: StringFilter<"ModuloHistorico"> | string
    usuarioId?: StringFilter<"ModuloHistorico"> | string
    razon?: StringNullableFilter<"ModuloHistorico"> | string | null
    fechaCreacion?: DateTimeFilter<"ModuloHistorico"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ModuloHistoricoOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    razon?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
    modulo?: ModuloOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ModuloHistoricoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuloHistoricoWhereInput | ModuloHistoricoWhereInput[]
    OR?: ModuloHistoricoWhereInput[]
    NOT?: ModuloHistoricoWhereInput | ModuloHistoricoWhereInput[]
    empresaId?: StringFilter<"ModuloHistorico"> | string
    moduloId?: StringFilter<"ModuloHistorico"> | string
    accion?: StringFilter<"ModuloHistorico"> | string
    usuarioId?: StringFilter<"ModuloHistorico"> | string
    razon?: StringNullableFilter<"ModuloHistorico"> | string | null
    fechaCreacion?: DateTimeFilter<"ModuloHistorico"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ModuloHistoricoOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    razon?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    _count?: ModuloHistoricoCountOrderByAggregateInput
    _max?: ModuloHistoricoMaxOrderByAggregateInput
    _min?: ModuloHistoricoMinOrderByAggregateInput
  }

  export type ModuloHistoricoScalarWhereWithAggregatesInput = {
    AND?: ModuloHistoricoScalarWhereWithAggregatesInput | ModuloHistoricoScalarWhereWithAggregatesInput[]
    OR?: ModuloHistoricoScalarWhereWithAggregatesInput[]
    NOT?: ModuloHistoricoScalarWhereWithAggregatesInput | ModuloHistoricoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuloHistorico"> | string
    empresaId?: StringWithAggregatesFilter<"ModuloHistorico"> | string
    moduloId?: StringWithAggregatesFilter<"ModuloHistorico"> | string
    accion?: StringWithAggregatesFilter<"ModuloHistorico"> | string
    usuarioId?: StringWithAggregatesFilter<"ModuloHistorico"> | string
    razon?: StringNullableWithAggregatesFilter<"ModuloHistorico"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"ModuloHistorico"> | Date | string
  }

  export type PlanCuentasWhereInput = {
    AND?: PlanCuentasWhereInput | PlanCuentasWhereInput[]
    OR?: PlanCuentasWhereInput[]
    NOT?: PlanCuentasWhereInput | PlanCuentasWhereInput[]
    id?: StringFilter<"PlanCuentas"> | string
    empresaId?: StringFilter<"PlanCuentas"> | string
    codigo?: StringFilter<"PlanCuentas"> | string
    codigoPadre?: StringNullableFilter<"PlanCuentas"> | string | null
    nivel?: IntFilter<"PlanCuentas"> | number
    nombre?: StringFilter<"PlanCuentas"> | string
    nombreCompleto?: StringNullableFilter<"PlanCuentas"> | string | null
    nombreCorto?: StringNullableFilter<"PlanCuentas"> | string | null
    tipoMayor?: StringFilter<"PlanCuentas"> | string
    tipoDetalle?: StringNullableFilter<"PlanCuentas"> | string | null
    naturaleza?: StringFilter<"PlanCuentas"> | string
    permiteMovimiento?: BoolFilter<"PlanCuentas"> | boolean
    esAuxiliar?: BoolFilter<"PlanCuentas"> | boolean
    nivelMaximo?: IntFilter<"PlanCuentas"> | number
    monedaPermitida?: StringFilter<"PlanCuentas"> | string
    centroCostoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    proyectoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    requiereReferencia?: BoolFilter<"PlanCuentas"> | boolean
    requiereCliente?: BoolFilter<"PlanCuentas"> | boolean
    requiereProveedor?: BoolFilter<"PlanCuentas"> | boolean
    activo?: BoolFilter<"PlanCuentas"> | boolean
    fechaCreacion?: DateTimeFilter<"PlanCuentas"> | Date | string
    fechaActualizacion?: DateTimeFilter<"PlanCuentas"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type PlanCuentasOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    codigo?: SortOrder
    codigoPadre?: SortOrderInput | SortOrder
    nivel?: SortOrder
    nombre?: SortOrder
    nombreCompleto?: SortOrderInput | SortOrder
    nombreCorto?: SortOrderInput | SortOrder
    tipoMayor?: SortOrder
    tipoDetalle?: SortOrderInput | SortOrder
    naturaleza?: SortOrder
    permiteMovimiento?: SortOrder
    esAuxiliar?: SortOrder
    nivelMaximo?: SortOrder
    monedaPermitida?: SortOrder
    centroCostoObligatorio?: SortOrder
    proyectoObligatorio?: SortOrder
    requiereReferencia?: SortOrder
    requiereCliente?: SortOrder
    requiereProveedor?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type PlanCuentasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    empresaId_codigo?: PlanCuentasEmpresaIdCodigoCompoundUniqueInput
    AND?: PlanCuentasWhereInput | PlanCuentasWhereInput[]
    OR?: PlanCuentasWhereInput[]
    NOT?: PlanCuentasWhereInput | PlanCuentasWhereInput[]
    empresaId?: StringFilter<"PlanCuentas"> | string
    codigo?: StringFilter<"PlanCuentas"> | string
    codigoPadre?: StringNullableFilter<"PlanCuentas"> | string | null
    nivel?: IntFilter<"PlanCuentas"> | number
    nombre?: StringFilter<"PlanCuentas"> | string
    nombreCompleto?: StringNullableFilter<"PlanCuentas"> | string | null
    nombreCorto?: StringNullableFilter<"PlanCuentas"> | string | null
    tipoMayor?: StringFilter<"PlanCuentas"> | string
    tipoDetalle?: StringNullableFilter<"PlanCuentas"> | string | null
    naturaleza?: StringFilter<"PlanCuentas"> | string
    permiteMovimiento?: BoolFilter<"PlanCuentas"> | boolean
    esAuxiliar?: BoolFilter<"PlanCuentas"> | boolean
    nivelMaximo?: IntFilter<"PlanCuentas"> | number
    monedaPermitida?: StringFilter<"PlanCuentas"> | string
    centroCostoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    proyectoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    requiereReferencia?: BoolFilter<"PlanCuentas"> | boolean
    requiereCliente?: BoolFilter<"PlanCuentas"> | boolean
    requiereProveedor?: BoolFilter<"PlanCuentas"> | boolean
    activo?: BoolFilter<"PlanCuentas"> | boolean
    fechaCreacion?: DateTimeFilter<"PlanCuentas"> | Date | string
    fechaActualizacion?: DateTimeFilter<"PlanCuentas"> | Date | string
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id" | "empresaId_codigo">

  export type PlanCuentasOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    codigo?: SortOrder
    codigoPadre?: SortOrderInput | SortOrder
    nivel?: SortOrder
    nombre?: SortOrder
    nombreCompleto?: SortOrderInput | SortOrder
    nombreCorto?: SortOrderInput | SortOrder
    tipoMayor?: SortOrder
    tipoDetalle?: SortOrderInput | SortOrder
    naturaleza?: SortOrder
    permiteMovimiento?: SortOrder
    esAuxiliar?: SortOrder
    nivelMaximo?: SortOrder
    monedaPermitida?: SortOrder
    centroCostoObligatorio?: SortOrder
    proyectoObligatorio?: SortOrder
    requiereReferencia?: SortOrder
    requiereCliente?: SortOrder
    requiereProveedor?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    _count?: PlanCuentasCountOrderByAggregateInput
    _avg?: PlanCuentasAvgOrderByAggregateInput
    _max?: PlanCuentasMaxOrderByAggregateInput
    _min?: PlanCuentasMinOrderByAggregateInput
    _sum?: PlanCuentasSumOrderByAggregateInput
  }

  export type PlanCuentasScalarWhereWithAggregatesInput = {
    AND?: PlanCuentasScalarWhereWithAggregatesInput | PlanCuentasScalarWhereWithAggregatesInput[]
    OR?: PlanCuentasScalarWhereWithAggregatesInput[]
    NOT?: PlanCuentasScalarWhereWithAggregatesInput | PlanCuentasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanCuentas"> | string
    empresaId?: StringWithAggregatesFilter<"PlanCuentas"> | string
    codigo?: StringWithAggregatesFilter<"PlanCuentas"> | string
    codigoPadre?: StringNullableWithAggregatesFilter<"PlanCuentas"> | string | null
    nivel?: IntWithAggregatesFilter<"PlanCuentas"> | number
    nombre?: StringWithAggregatesFilter<"PlanCuentas"> | string
    nombreCompleto?: StringNullableWithAggregatesFilter<"PlanCuentas"> | string | null
    nombreCorto?: StringNullableWithAggregatesFilter<"PlanCuentas"> | string | null
    tipoMayor?: StringWithAggregatesFilter<"PlanCuentas"> | string
    tipoDetalle?: StringNullableWithAggregatesFilter<"PlanCuentas"> | string | null
    naturaleza?: StringWithAggregatesFilter<"PlanCuentas"> | string
    permiteMovimiento?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    esAuxiliar?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    nivelMaximo?: IntWithAggregatesFilter<"PlanCuentas"> | number
    monedaPermitida?: StringWithAggregatesFilter<"PlanCuentas"> | string
    centroCostoObligatorio?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    proyectoObligatorio?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    requiereReferencia?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    requiereCliente?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    requiereProveedor?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    activo?: BoolWithAggregatesFilter<"PlanCuentas"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"PlanCuentas"> | Date | string
    fechaActualizacion?: DateTimeWithAggregatesFilter<"PlanCuentas"> | Date | string
  }

  export type EmpresaCreateInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
  }

  export type EmpresaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
  }

  export type UsuarioCreateInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    empresa: EmpresaCreateNestedOneWithoutUsuariosInput
    rol: RolCreateNestedOneWithoutUsuariosInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    empresaId: string
    rolId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutUsuariosNestedInput
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    empresaId: string
    rolId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuloCreateInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type ModuloCreateManyInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
  }

  export type ModuloUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type ModuloUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaModuloCreateInput = {
    id?: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
    empresa: EmpresaCreateNestedOneWithoutModulosActivosInput
    modulo: ModuloCreateNestedOneWithoutEmpresasConModuloInput
  }

  export type EmpresaModuloUncheckedCreateInput = {
    id?: string
    empresaId: string
    moduloId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type EmpresaModuloUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutModulosActivosNestedInput
    modulo?: ModuloUpdateOneRequiredWithoutEmpresasConModuloNestedInput
  }

  export type EmpresaModuloUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpresaModuloCreateManyInput = {
    id?: string
    empresaId: string
    moduloId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type EmpresaModuloUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpresaModuloUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuloDependenciaCreateInput = {
    id?: string
    requerido?: boolean
    dependeDe: ModuloCreateNestedOneWithoutEsDependenciaDeInput
    modulo: ModuloCreateNestedOneWithoutDependeDeInput
  }

  export type ModuloDependenciaUncheckedCreateInput = {
    id?: string
    moduloId: string
    dependeDeId: string
    requerido?: boolean
  }

  export type ModuloDependenciaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
    dependeDe?: ModuloUpdateOneRequiredWithoutEsDependenciaDeNestedInput
    modulo?: ModuloUpdateOneRequiredWithoutDependeDeNestedInput
  }

  export type ModuloDependenciaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    dependeDeId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloDependenciaCreateManyInput = {
    id?: string
    moduloId: string
    dependeDeId: string
    requerido?: boolean
  }

  export type ModuloDependenciaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloDependenciaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    dependeDeId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloRutaCreateInput = {
    id?: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
    modulo: ModuloCreateNestedOneWithoutRutasInput
  }

  export type ModuloRutaUncheckedCreateInput = {
    id?: string
    moduloId: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
  }

  export type ModuloRutaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    modulo?: ModuloUpdateOneRequiredWithoutRutasNestedInput
  }

  export type ModuloRutaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ModuloRutaCreateManyInput = {
    id?: string
    moduloId: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
  }

  export type ModuloRutaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ModuloRutaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolCreateInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    permisos?: RolPermisoCreateNestedManyWithoutRolInput
    usuarios?: UsuarioCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    permisos?: RolPermisoUncheckedCreateNestedManyWithoutRolInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    permisos?: RolPermisoUpdateManyWithoutRolNestedInput
    usuarios?: UsuarioUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    permisos?: RolPermisoUncheckedUpdateManyWithoutRolNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateManyInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
  }

  export type RolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuloPermisoCreateInput = {
    id?: string
    nombre: string
    codigo: string
    descripcion?: string | null
    modulo: ModuloCreateNestedOneWithoutPermisosInput
    roles?: RolPermisoCreateNestedManyWithoutPermisoInput
  }

  export type ModuloPermisoUncheckedCreateInput = {
    id?: string
    moduloId: string
    nombre: string
    codigo: string
    descripcion?: string | null
    roles?: RolPermisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type ModuloPermisoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: ModuloUpdateOneRequiredWithoutPermisosNestedInput
    roles?: RolPermisoUpdateManyWithoutPermisoNestedInput
  }

  export type ModuloPermisoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type ModuloPermisoCreateManyInput = {
    id?: string
    moduloId: string
    nombre: string
    codigo: string
    descripcion?: string | null
  }

  export type ModuloPermisoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuloPermisoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolPermisoCreateInput = {
    id?: string
    permiso: ModuloPermisoCreateNestedOneWithoutRolesInput
    rol: RolCreateNestedOneWithoutPermisosInput
  }

  export type RolPermisoUncheckedCreateInput = {
    id?: string
    rolId: string
    permisoId: string
  }

  export type RolPermisoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permiso?: ModuloPermisoUpdateOneRequiredWithoutRolesNestedInput
    rol?: RolUpdateOneRequiredWithoutPermisosNestedInput
  }

  export type RolPermisoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoCreateManyInput = {
    id?: string
    rolId: string
    permisoId: string
  }

  export type RolPermisoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type EmpresaConfiguracionCreateInput = {
    id?: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutConfiguracionesInput
  }

  export type EmpresaConfiguracionUncheckedCreateInput = {
    id?: string
    empresaId: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaConfiguracionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutConfiguracionesNestedInput
  }

  export type EmpresaConfiguracionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaConfiguracionCreateManyInput = {
    id?: string
    empresaId: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaConfiguracionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaConfiguracionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutFacturasInput
  }

  export type FacturaUncheckedCreateInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacturaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type FacturaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaCreateManyInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacturaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoCreateManyInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutClientesInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutClientesNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateManyInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutMovimientosCajaInput
  }

  export type MovimientoCajaUncheckedCreateInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovimientoCajaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutMovimientosCajaNestedInput
  }

  export type MovimientoCajaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaCreateManyInput = {
    id?: string
    empresaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovimientoCajaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoCreateInput = {
    id?: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
    empresa: EmpresaCreateNestedOneWithoutModuloHistoricoInput
    modulo: ModuloCreateNestedOneWithoutModuloHistoricoInput
    usuario: UsuarioCreateNestedOneWithoutModuloHistoricoInput
  }

  export type ModuloHistoricoUncheckedCreateInput = {
    id?: string
    empresaId: string
    moduloId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutModuloHistoricoNestedInput
    modulo?: ModuloUpdateOneRequiredWithoutModuloHistoricoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutModuloHistoricoNestedInput
  }

  export type ModuloHistoricoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoCreateManyInput = {
    id?: string
    empresaId: string
    moduloId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCuentasCreateInput = {
    id?: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    empresa: EmpresaCreateNestedOneWithoutPlanCuentasInput
  }

  export type PlanCuentasUncheckedCreateInput = {
    id?: string
    empresaId: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type PlanCuentasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutPlanCuentasNestedInput
  }

  export type PlanCuentasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCuentasCreateManyInput = {
    id?: string
    empresaId: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type PlanCuentasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCuentasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type ClienteListRelationFilter = {
    every?: ClienteWhereInput
    some?: ClienteWhereInput
    none?: ClienteWhereInput
  }

  export type EmpresaConfiguracionListRelationFilter = {
    every?: EmpresaConfiguracionWhereInput
    some?: EmpresaConfiguracionWhereInput
    none?: EmpresaConfiguracionWhereInput
  }

  export type EmpresaModuloListRelationFilter = {
    every?: EmpresaModuloWhereInput
    some?: EmpresaModuloWhereInput
    none?: EmpresaModuloWhereInput
  }

  export type ModuloHistoricoListRelationFilter = {
    every?: ModuloHistoricoWhereInput
    some?: ModuloHistoricoWhereInput
    none?: ModuloHistoricoWhereInput
  }

  export type FacturaListRelationFilter = {
    every?: FacturaWhereInput
    some?: FacturaWhereInput
    none?: FacturaWhereInput
  }

  export type MovimientoCajaListRelationFilter = {
    every?: MovimientoCajaWhereInput
    some?: MovimientoCajaWhereInput
    none?: MovimientoCajaWhereInput
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type PlanCuentasListRelationFilter = {
    every?: PlanCuentasWhereInput
    some?: PlanCuentasWhereInput
    none?: PlanCuentasWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaConfiguracionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaModuloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuloHistoricoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovimientoCajaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCuentasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ruc?: SortOrder
    activo?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    fechaActualizacion?: SortOrder
    fechaCreacion?: SortOrder
    telefono?: SortOrder
    plan?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ruc?: SortOrder
    activo?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    fechaActualizacion?: SortOrder
    fechaCreacion?: SortOrder
    telefono?: SortOrder
    plan?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ruc?: SortOrder
    activo?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    fechaActualizacion?: SortOrder
    fechaCreacion?: SortOrder
    telefono?: SortOrder
    plan?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type RolRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    password?: SortOrder
    empresaId?: SortOrder
    rolId?: SortOrder
    activo?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    password?: SortOrder
    empresaId?: SortOrder
    rolId?: SortOrder
    activo?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    password?: SortOrder
    empresaId?: SortOrder
    rolId?: SortOrder
    activo?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ModuloDependenciaListRelationFilter = {
    every?: ModuloDependenciaWhereInput
    some?: ModuloDependenciaWhereInput
    none?: ModuloDependenciaWhereInput
  }

  export type ModuloPermisoListRelationFilter = {
    every?: ModuloPermisoWhereInput
    some?: ModuloPermisoWhereInput
    none?: ModuloPermisoWhereInput
  }

  export type ModuloRutaListRelationFilter = {
    every?: ModuloRutaWhereInput
    some?: ModuloRutaWhereInput
    none?: ModuloRutaWhereInput
  }

  export type ModuloDependenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuloPermisoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuloRutaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuloCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    displayName?: SortOrder
    version?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
  }

  export type ModuloAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type ModuloMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    displayName?: SortOrder
    version?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
  }

  export type ModuloMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    displayName?: SortOrder
    version?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
  }

  export type ModuloSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ModuloRelationFilter = {
    is?: ModuloWhereInput
    isNot?: ModuloWhereInput
  }

  export type EmpresaModuloEmpresaIdModuloIdCompoundUniqueInput = {
    empresaId: string
    moduloId: string
  }

  export type EmpresaModuloCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    activo?: SortOrder
    configuracion?: SortOrder
    fechaActivacion?: SortOrder
    fechaDesactivacion?: SortOrder
  }

  export type EmpresaModuloMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    activo?: SortOrder
    fechaActivacion?: SortOrder
    fechaDesactivacion?: SortOrder
  }

  export type EmpresaModuloMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    activo?: SortOrder
    fechaActivacion?: SortOrder
    fechaDesactivacion?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ModuloDependenciaModuloIdDependeDeIdCompoundUniqueInput = {
    moduloId: string
    dependeDeId: string
  }

  export type ModuloDependenciaCountOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    dependeDeId?: SortOrder
    requerido?: SortOrder
  }

  export type ModuloDependenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    dependeDeId?: SortOrder
    requerido?: SortOrder
  }

  export type ModuloDependenciaMinOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    dependeDeId?: SortOrder
    requerido?: SortOrder
  }

  export type ModuloRutaCountOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    ruta?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
    nombre?: SortOrder
  }

  export type ModuloRutaMaxOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    ruta?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
    nombre?: SortOrder
  }

  export type ModuloRutaMinOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    ruta?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
    nombre?: SortOrder
  }

  export type RolPermisoListRelationFilter = {
    every?: RolPermisoWhereInput
    some?: RolPermisoWhereInput
    none?: RolPermisoWhereInput
  }

  export type RolPermisoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    descripcion?: SortOrder
  }

  export type ModuloPermisoModuloIdCodigoCompoundUniqueInput = {
    moduloId: string
    codigo: string
  }

  export type ModuloPermisoCountOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
  }

  export type ModuloPermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
  }

  export type ModuloPermisoMinOrderByAggregateInput = {
    id?: SortOrder
    moduloId?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
  }

  export type ModuloPermisoRelationFilter = {
    is?: ModuloPermisoWhereInput
    isNot?: ModuloPermisoWhereInput
  }

  export type RolPermisoRolIdPermisoIdCompoundUniqueInput = {
    rolId: string
    permisoId: string
  }

  export type RolPermisoCountOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type RolPermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type RolPermisoMinOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EmpresaConfiguracionEmpresaIdClaveCompoundUniqueInput = {
    empresaId: string
    clave: string
  }

  export type EmpresaConfiguracionCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaConfiguracionMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    clave?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaConfiguracionMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    clave?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FacturaCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacturaMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacturaMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovimientoCajaCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovimientoCajaMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovimientoCajaMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ModuloHistoricoCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    razon?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ModuloHistoricoMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    razon?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ModuloHistoricoMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    moduloId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    razon?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type PlanCuentasEmpresaIdCodigoCompoundUniqueInput = {
    empresaId: string
    codigo: string
  }

  export type PlanCuentasCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    codigo?: SortOrder
    codigoPadre?: SortOrder
    nivel?: SortOrder
    nombre?: SortOrder
    nombreCompleto?: SortOrder
    nombreCorto?: SortOrder
    tipoMayor?: SortOrder
    tipoDetalle?: SortOrder
    naturaleza?: SortOrder
    permiteMovimiento?: SortOrder
    esAuxiliar?: SortOrder
    nivelMaximo?: SortOrder
    monedaPermitida?: SortOrder
    centroCostoObligatorio?: SortOrder
    proyectoObligatorio?: SortOrder
    requiereReferencia?: SortOrder
    requiereCliente?: SortOrder
    requiereProveedor?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type PlanCuentasAvgOrderByAggregateInput = {
    nivel?: SortOrder
    nivelMaximo?: SortOrder
  }

  export type PlanCuentasMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    codigo?: SortOrder
    codigoPadre?: SortOrder
    nivel?: SortOrder
    nombre?: SortOrder
    nombreCompleto?: SortOrder
    nombreCorto?: SortOrder
    tipoMayor?: SortOrder
    tipoDetalle?: SortOrder
    naturaleza?: SortOrder
    permiteMovimiento?: SortOrder
    esAuxiliar?: SortOrder
    nivelMaximo?: SortOrder
    monedaPermitida?: SortOrder
    centroCostoObligatorio?: SortOrder
    proyectoObligatorio?: SortOrder
    requiereReferencia?: SortOrder
    requiereCliente?: SortOrder
    requiereProveedor?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type PlanCuentasMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    codigo?: SortOrder
    codigoPadre?: SortOrder
    nivel?: SortOrder
    nombre?: SortOrder
    nombreCompleto?: SortOrder
    nombreCorto?: SortOrder
    tipoMayor?: SortOrder
    tipoDetalle?: SortOrder
    naturaleza?: SortOrder
    permiteMovimiento?: SortOrder
    esAuxiliar?: SortOrder
    nivelMaximo?: SortOrder
    monedaPermitida?: SortOrder
    centroCostoObligatorio?: SortOrder
    proyectoObligatorio?: SortOrder
    requiereReferencia?: SortOrder
    requiereCliente?: SortOrder
    requiereProveedor?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type PlanCuentasSumOrderByAggregateInput = {
    nivel?: SortOrder
    nivelMaximo?: SortOrder
  }

  export type ClienteCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput> | ClienteCreateWithoutEmpresaInput[] | ClienteUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutEmpresaInput | ClienteCreateOrConnectWithoutEmpresaInput[]
    createMany?: ClienteCreateManyEmpresaInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput> | EmpresaConfiguracionCreateWithoutEmpresaInput[] | EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput | EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput[]
    createMany?: EmpresaConfiguracionCreateManyEmpresaInputEnvelope
    connect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
  }

  export type EmpresaModuloCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput> | EmpresaModuloCreateWithoutEmpresaInput[] | EmpresaModuloUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutEmpresaInput | EmpresaModuloCreateOrConnectWithoutEmpresaInput[]
    createMany?: EmpresaModuloCreateManyEmpresaInputEnvelope
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
  }

  export type ModuloHistoricoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput> | ModuloHistoricoCreateWithoutEmpresaInput[] | ModuloHistoricoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutEmpresaInput | ModuloHistoricoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ModuloHistoricoCreateManyEmpresaInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type FacturaCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput> | FacturaCreateWithoutEmpresaInput[] | FacturaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FacturaCreateOrConnectWithoutEmpresaInput | FacturaCreateOrConnectWithoutEmpresaInput[]
    createMany?: FacturaCreateManyEmpresaInputEnvelope
    connect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
  }

  export type MovimientoCajaCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput> | MovimientoCajaCreateWithoutEmpresaInput[] | MovimientoCajaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: MovimientoCajaCreateOrConnectWithoutEmpresaInput | MovimientoCajaCreateOrConnectWithoutEmpresaInput[]
    createMany?: MovimientoCajaCreateManyEmpresaInputEnvelope
    connect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
  }

  export type ProductoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput> | ProductoCreateWithoutEmpresaInput[] | ProductoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmpresaInput | ProductoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ProductoCreateManyEmpresaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput> | UsuarioCreateWithoutEmpresaInput[] | UsuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmpresaInput | UsuarioCreateOrConnectWithoutEmpresaInput[]
    createMany?: UsuarioCreateManyEmpresaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type PlanCuentasCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput> | PlanCuentasCreateWithoutEmpresaInput[] | PlanCuentasUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: PlanCuentasCreateOrConnectWithoutEmpresaInput | PlanCuentasCreateOrConnectWithoutEmpresaInput[]
    createMany?: PlanCuentasCreateManyEmpresaInputEnvelope
    connect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
  }

  export type ClienteUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput> | ClienteCreateWithoutEmpresaInput[] | ClienteUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutEmpresaInput | ClienteCreateOrConnectWithoutEmpresaInput[]
    createMany?: ClienteCreateManyEmpresaInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput> | EmpresaConfiguracionCreateWithoutEmpresaInput[] | EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput | EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput[]
    createMany?: EmpresaConfiguracionCreateManyEmpresaInputEnvelope
    connect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
  }

  export type EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput> | EmpresaModuloCreateWithoutEmpresaInput[] | EmpresaModuloUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutEmpresaInput | EmpresaModuloCreateOrConnectWithoutEmpresaInput[]
    createMany?: EmpresaModuloCreateManyEmpresaInputEnvelope
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
  }

  export type ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput> | ModuloHistoricoCreateWithoutEmpresaInput[] | ModuloHistoricoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutEmpresaInput | ModuloHistoricoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ModuloHistoricoCreateManyEmpresaInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type FacturaUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput> | FacturaCreateWithoutEmpresaInput[] | FacturaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FacturaCreateOrConnectWithoutEmpresaInput | FacturaCreateOrConnectWithoutEmpresaInput[]
    createMany?: FacturaCreateManyEmpresaInputEnvelope
    connect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
  }

  export type MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput> | MovimientoCajaCreateWithoutEmpresaInput[] | MovimientoCajaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: MovimientoCajaCreateOrConnectWithoutEmpresaInput | MovimientoCajaCreateOrConnectWithoutEmpresaInput[]
    createMany?: MovimientoCajaCreateManyEmpresaInputEnvelope
    connect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput> | ProductoCreateWithoutEmpresaInput[] | ProductoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmpresaInput | ProductoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ProductoCreateManyEmpresaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput> | UsuarioCreateWithoutEmpresaInput[] | UsuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmpresaInput | UsuarioCreateOrConnectWithoutEmpresaInput[]
    createMany?: UsuarioCreateManyEmpresaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput> | PlanCuentasCreateWithoutEmpresaInput[] | PlanCuentasUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: PlanCuentasCreateOrConnectWithoutEmpresaInput | PlanCuentasCreateOrConnectWithoutEmpresaInput[]
    createMany?: PlanCuentasCreateManyEmpresaInputEnvelope
    connect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type ClienteUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput> | ClienteCreateWithoutEmpresaInput[] | ClienteUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutEmpresaInput | ClienteCreateOrConnectWithoutEmpresaInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutEmpresaInput | ClienteUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ClienteCreateManyEmpresaInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutEmpresaInput | ClienteUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutEmpresaInput | ClienteUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput> | EmpresaConfiguracionCreateWithoutEmpresaInput[] | EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput | EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput[]
    upsert?: EmpresaConfiguracionUpsertWithWhereUniqueWithoutEmpresaInput | EmpresaConfiguracionUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: EmpresaConfiguracionCreateManyEmpresaInputEnvelope
    set?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    disconnect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    delete?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    connect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    update?: EmpresaConfiguracionUpdateWithWhereUniqueWithoutEmpresaInput | EmpresaConfiguracionUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: EmpresaConfiguracionUpdateManyWithWhereWithoutEmpresaInput | EmpresaConfiguracionUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: EmpresaConfiguracionScalarWhereInput | EmpresaConfiguracionScalarWhereInput[]
  }

  export type EmpresaModuloUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput> | EmpresaModuloCreateWithoutEmpresaInput[] | EmpresaModuloUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutEmpresaInput | EmpresaModuloCreateOrConnectWithoutEmpresaInput[]
    upsert?: EmpresaModuloUpsertWithWhereUniqueWithoutEmpresaInput | EmpresaModuloUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: EmpresaModuloCreateManyEmpresaInputEnvelope
    set?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    disconnect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    delete?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    update?: EmpresaModuloUpdateWithWhereUniqueWithoutEmpresaInput | EmpresaModuloUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: EmpresaModuloUpdateManyWithWhereWithoutEmpresaInput | EmpresaModuloUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
  }

  export type ModuloHistoricoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput> | ModuloHistoricoCreateWithoutEmpresaInput[] | ModuloHistoricoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutEmpresaInput | ModuloHistoricoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutEmpresaInput | ModuloHistoricoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ModuloHistoricoCreateManyEmpresaInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutEmpresaInput | ModuloHistoricoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutEmpresaInput | ModuloHistoricoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type FacturaUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput> | FacturaCreateWithoutEmpresaInput[] | FacturaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FacturaCreateOrConnectWithoutEmpresaInput | FacturaCreateOrConnectWithoutEmpresaInput[]
    upsert?: FacturaUpsertWithWhereUniqueWithoutEmpresaInput | FacturaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: FacturaCreateManyEmpresaInputEnvelope
    set?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    disconnect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    delete?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    connect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    update?: FacturaUpdateWithWhereUniqueWithoutEmpresaInput | FacturaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: FacturaUpdateManyWithWhereWithoutEmpresaInput | FacturaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: FacturaScalarWhereInput | FacturaScalarWhereInput[]
  }

  export type MovimientoCajaUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput> | MovimientoCajaCreateWithoutEmpresaInput[] | MovimientoCajaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: MovimientoCajaCreateOrConnectWithoutEmpresaInput | MovimientoCajaCreateOrConnectWithoutEmpresaInput[]
    upsert?: MovimientoCajaUpsertWithWhereUniqueWithoutEmpresaInput | MovimientoCajaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: MovimientoCajaCreateManyEmpresaInputEnvelope
    set?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    disconnect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    delete?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    connect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    update?: MovimientoCajaUpdateWithWhereUniqueWithoutEmpresaInput | MovimientoCajaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: MovimientoCajaUpdateManyWithWhereWithoutEmpresaInput | MovimientoCajaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: MovimientoCajaScalarWhereInput | MovimientoCajaScalarWhereInput[]
  }

  export type ProductoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput> | ProductoCreateWithoutEmpresaInput[] | ProductoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmpresaInput | ProductoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutEmpresaInput | ProductoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ProductoCreateManyEmpresaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutEmpresaInput | ProductoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutEmpresaInput | ProductoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput> | UsuarioCreateWithoutEmpresaInput[] | UsuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmpresaInput | UsuarioCreateOrConnectWithoutEmpresaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEmpresaInput | UsuarioUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: UsuarioCreateManyEmpresaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEmpresaInput | UsuarioUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEmpresaInput | UsuarioUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type PlanCuentasUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput> | PlanCuentasCreateWithoutEmpresaInput[] | PlanCuentasUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: PlanCuentasCreateOrConnectWithoutEmpresaInput | PlanCuentasCreateOrConnectWithoutEmpresaInput[]
    upsert?: PlanCuentasUpsertWithWhereUniqueWithoutEmpresaInput | PlanCuentasUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: PlanCuentasCreateManyEmpresaInputEnvelope
    set?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    disconnect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    delete?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    connect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    update?: PlanCuentasUpdateWithWhereUniqueWithoutEmpresaInput | PlanCuentasUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: PlanCuentasUpdateManyWithWhereWithoutEmpresaInput | PlanCuentasUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: PlanCuentasScalarWhereInput | PlanCuentasScalarWhereInput[]
  }

  export type ClienteUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput> | ClienteCreateWithoutEmpresaInput[] | ClienteUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutEmpresaInput | ClienteCreateOrConnectWithoutEmpresaInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutEmpresaInput | ClienteUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ClienteCreateManyEmpresaInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutEmpresaInput | ClienteUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutEmpresaInput | ClienteUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput> | EmpresaConfiguracionCreateWithoutEmpresaInput[] | EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput | EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput[]
    upsert?: EmpresaConfiguracionUpsertWithWhereUniqueWithoutEmpresaInput | EmpresaConfiguracionUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: EmpresaConfiguracionCreateManyEmpresaInputEnvelope
    set?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    disconnect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    delete?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    connect?: EmpresaConfiguracionWhereUniqueInput | EmpresaConfiguracionWhereUniqueInput[]
    update?: EmpresaConfiguracionUpdateWithWhereUniqueWithoutEmpresaInput | EmpresaConfiguracionUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: EmpresaConfiguracionUpdateManyWithWhereWithoutEmpresaInput | EmpresaConfiguracionUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: EmpresaConfiguracionScalarWhereInput | EmpresaConfiguracionScalarWhereInput[]
  }

  export type EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput> | EmpresaModuloCreateWithoutEmpresaInput[] | EmpresaModuloUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutEmpresaInput | EmpresaModuloCreateOrConnectWithoutEmpresaInput[]
    upsert?: EmpresaModuloUpsertWithWhereUniqueWithoutEmpresaInput | EmpresaModuloUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: EmpresaModuloCreateManyEmpresaInputEnvelope
    set?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    disconnect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    delete?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    update?: EmpresaModuloUpdateWithWhereUniqueWithoutEmpresaInput | EmpresaModuloUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: EmpresaModuloUpdateManyWithWhereWithoutEmpresaInput | EmpresaModuloUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput> | ModuloHistoricoCreateWithoutEmpresaInput[] | ModuloHistoricoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutEmpresaInput | ModuloHistoricoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutEmpresaInput | ModuloHistoricoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ModuloHistoricoCreateManyEmpresaInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutEmpresaInput | ModuloHistoricoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutEmpresaInput | ModuloHistoricoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type FacturaUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput> | FacturaCreateWithoutEmpresaInput[] | FacturaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FacturaCreateOrConnectWithoutEmpresaInput | FacturaCreateOrConnectWithoutEmpresaInput[]
    upsert?: FacturaUpsertWithWhereUniqueWithoutEmpresaInput | FacturaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: FacturaCreateManyEmpresaInputEnvelope
    set?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    disconnect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    delete?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    connect?: FacturaWhereUniqueInput | FacturaWhereUniqueInput[]
    update?: FacturaUpdateWithWhereUniqueWithoutEmpresaInput | FacturaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: FacturaUpdateManyWithWhereWithoutEmpresaInput | FacturaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: FacturaScalarWhereInput | FacturaScalarWhereInput[]
  }

  export type MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput> | MovimientoCajaCreateWithoutEmpresaInput[] | MovimientoCajaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: MovimientoCajaCreateOrConnectWithoutEmpresaInput | MovimientoCajaCreateOrConnectWithoutEmpresaInput[]
    upsert?: MovimientoCajaUpsertWithWhereUniqueWithoutEmpresaInput | MovimientoCajaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: MovimientoCajaCreateManyEmpresaInputEnvelope
    set?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    disconnect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    delete?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    connect?: MovimientoCajaWhereUniqueInput | MovimientoCajaWhereUniqueInput[]
    update?: MovimientoCajaUpdateWithWhereUniqueWithoutEmpresaInput | MovimientoCajaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: MovimientoCajaUpdateManyWithWhereWithoutEmpresaInput | MovimientoCajaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: MovimientoCajaScalarWhereInput | MovimientoCajaScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput> | ProductoCreateWithoutEmpresaInput[] | ProductoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmpresaInput | ProductoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutEmpresaInput | ProductoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ProductoCreateManyEmpresaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutEmpresaInput | ProductoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutEmpresaInput | ProductoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput> | UsuarioCreateWithoutEmpresaInput[] | UsuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmpresaInput | UsuarioCreateOrConnectWithoutEmpresaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEmpresaInput | UsuarioUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: UsuarioCreateManyEmpresaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEmpresaInput | UsuarioUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEmpresaInput | UsuarioUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput> | PlanCuentasCreateWithoutEmpresaInput[] | PlanCuentasUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: PlanCuentasCreateOrConnectWithoutEmpresaInput | PlanCuentasCreateOrConnectWithoutEmpresaInput[]
    upsert?: PlanCuentasUpsertWithWhereUniqueWithoutEmpresaInput | PlanCuentasUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: PlanCuentasCreateManyEmpresaInputEnvelope
    set?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    disconnect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    delete?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    connect?: PlanCuentasWhereUniqueInput | PlanCuentasWhereUniqueInput[]
    update?: PlanCuentasUpdateWithWhereUniqueWithoutEmpresaInput | PlanCuentasUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: PlanCuentasUpdateManyWithWhereWithoutEmpresaInput | PlanCuentasUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: PlanCuentasScalarWhereInput | PlanCuentasScalarWhereInput[]
  }

  export type EmpresaCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<EmpresaCreateWithoutUsuariosInput, EmpresaUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutUsuariosInput
    connect?: EmpresaWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    connect?: RolWhereUniqueInput
  }

  export type ModuloHistoricoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput> | ModuloHistoricoCreateWithoutUsuarioInput[] | ModuloHistoricoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutUsuarioInput | ModuloHistoricoCreateOrConnectWithoutUsuarioInput[]
    createMany?: ModuloHistoricoCreateManyUsuarioInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type ModuloHistoricoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput> | ModuloHistoricoCreateWithoutUsuarioInput[] | ModuloHistoricoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutUsuarioInput | ModuloHistoricoCreateOrConnectWithoutUsuarioInput[]
    createMany?: ModuloHistoricoCreateManyUsuarioInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EmpresaUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<EmpresaCreateWithoutUsuariosInput, EmpresaUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutUsuariosInput
    upsert?: EmpresaUpsertWithoutUsuariosInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutUsuariosInput, EmpresaUpdateWithoutUsuariosInput>, EmpresaUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    upsert?: RolUpsertWithoutUsuariosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutUsuariosInput, RolUpdateWithoutUsuariosInput>, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type ModuloHistoricoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput> | ModuloHistoricoCreateWithoutUsuarioInput[] | ModuloHistoricoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutUsuarioInput | ModuloHistoricoCreateOrConnectWithoutUsuarioInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutUsuarioInput | ModuloHistoricoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ModuloHistoricoCreateManyUsuarioInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutUsuarioInput | ModuloHistoricoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutUsuarioInput | ModuloHistoricoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput> | ModuloHistoricoCreateWithoutUsuarioInput[] | ModuloHistoricoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutUsuarioInput | ModuloHistoricoCreateOrConnectWithoutUsuarioInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutUsuarioInput | ModuloHistoricoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ModuloHistoricoCreateManyUsuarioInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutUsuarioInput | ModuloHistoricoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutUsuarioInput | ModuloHistoricoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type EmpresaModuloCreateNestedManyWithoutModuloInput = {
    create?: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput> | EmpresaModuloCreateWithoutModuloInput[] | EmpresaModuloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutModuloInput | EmpresaModuloCreateOrConnectWithoutModuloInput[]
    createMany?: EmpresaModuloCreateManyModuloInputEnvelope
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
  }

  export type ModuloHistoricoCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput> | ModuloHistoricoCreateWithoutModuloInput[] | ModuloHistoricoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutModuloInput | ModuloHistoricoCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloHistoricoCreateManyModuloInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type ModuloDependenciaCreateNestedManyWithoutDependeDeInput = {
    create?: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput> | ModuloDependenciaCreateWithoutDependeDeInput[] | ModuloDependenciaUncheckedCreateWithoutDependeDeInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutDependeDeInput | ModuloDependenciaCreateOrConnectWithoutDependeDeInput[]
    createMany?: ModuloDependenciaCreateManyDependeDeInputEnvelope
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
  }

  export type ModuloDependenciaCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput> | ModuloDependenciaCreateWithoutModuloInput[] | ModuloDependenciaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutModuloInput | ModuloDependenciaCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloDependenciaCreateManyModuloInputEnvelope
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
  }

  export type ModuloPermisoCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput> | ModuloPermisoCreateWithoutModuloInput[] | ModuloPermisoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutModuloInput | ModuloPermisoCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloPermisoCreateManyModuloInputEnvelope
    connect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
  }

  export type ModuloRutaCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput> | ModuloRutaCreateWithoutModuloInput[] | ModuloRutaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloRutaCreateOrConnectWithoutModuloInput | ModuloRutaCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloRutaCreateManyModuloInputEnvelope
    connect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
  }

  export type EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput> | EmpresaModuloCreateWithoutModuloInput[] | EmpresaModuloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutModuloInput | EmpresaModuloCreateOrConnectWithoutModuloInput[]
    createMany?: EmpresaModuloCreateManyModuloInputEnvelope
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
  }

  export type ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput> | ModuloHistoricoCreateWithoutModuloInput[] | ModuloHistoricoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutModuloInput | ModuloHistoricoCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloHistoricoCreateManyModuloInputEnvelope
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
  }

  export type ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput = {
    create?: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput> | ModuloDependenciaCreateWithoutDependeDeInput[] | ModuloDependenciaUncheckedCreateWithoutDependeDeInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutDependeDeInput | ModuloDependenciaCreateOrConnectWithoutDependeDeInput[]
    createMany?: ModuloDependenciaCreateManyDependeDeInputEnvelope
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
  }

  export type ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput> | ModuloDependenciaCreateWithoutModuloInput[] | ModuloDependenciaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutModuloInput | ModuloDependenciaCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloDependenciaCreateManyModuloInputEnvelope
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
  }

  export type ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput> | ModuloPermisoCreateWithoutModuloInput[] | ModuloPermisoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutModuloInput | ModuloPermisoCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloPermisoCreateManyModuloInputEnvelope
    connect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
  }

  export type ModuloRutaUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput> | ModuloRutaCreateWithoutModuloInput[] | ModuloRutaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloRutaCreateOrConnectWithoutModuloInput | ModuloRutaCreateOrConnectWithoutModuloInput[]
    createMany?: ModuloRutaCreateManyModuloInputEnvelope
    connect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmpresaModuloUpdateManyWithoutModuloNestedInput = {
    create?: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput> | EmpresaModuloCreateWithoutModuloInput[] | EmpresaModuloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutModuloInput | EmpresaModuloCreateOrConnectWithoutModuloInput[]
    upsert?: EmpresaModuloUpsertWithWhereUniqueWithoutModuloInput | EmpresaModuloUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: EmpresaModuloCreateManyModuloInputEnvelope
    set?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    disconnect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    delete?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    update?: EmpresaModuloUpdateWithWhereUniqueWithoutModuloInput | EmpresaModuloUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: EmpresaModuloUpdateManyWithWhereWithoutModuloInput | EmpresaModuloUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
  }

  export type ModuloHistoricoUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput> | ModuloHistoricoCreateWithoutModuloInput[] | ModuloHistoricoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutModuloInput | ModuloHistoricoCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutModuloInput | ModuloHistoricoUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloHistoricoCreateManyModuloInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutModuloInput | ModuloHistoricoUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutModuloInput | ModuloHistoricoUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type ModuloDependenciaUpdateManyWithoutDependeDeNestedInput = {
    create?: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput> | ModuloDependenciaCreateWithoutDependeDeInput[] | ModuloDependenciaUncheckedCreateWithoutDependeDeInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutDependeDeInput | ModuloDependenciaCreateOrConnectWithoutDependeDeInput[]
    upsert?: ModuloDependenciaUpsertWithWhereUniqueWithoutDependeDeInput | ModuloDependenciaUpsertWithWhereUniqueWithoutDependeDeInput[]
    createMany?: ModuloDependenciaCreateManyDependeDeInputEnvelope
    set?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    disconnect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    delete?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    update?: ModuloDependenciaUpdateWithWhereUniqueWithoutDependeDeInput | ModuloDependenciaUpdateWithWhereUniqueWithoutDependeDeInput[]
    updateMany?: ModuloDependenciaUpdateManyWithWhereWithoutDependeDeInput | ModuloDependenciaUpdateManyWithWhereWithoutDependeDeInput[]
    deleteMany?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
  }

  export type ModuloDependenciaUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput> | ModuloDependenciaCreateWithoutModuloInput[] | ModuloDependenciaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutModuloInput | ModuloDependenciaCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloDependenciaUpsertWithWhereUniqueWithoutModuloInput | ModuloDependenciaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloDependenciaCreateManyModuloInputEnvelope
    set?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    disconnect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    delete?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    update?: ModuloDependenciaUpdateWithWhereUniqueWithoutModuloInput | ModuloDependenciaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloDependenciaUpdateManyWithWhereWithoutModuloInput | ModuloDependenciaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
  }

  export type ModuloPermisoUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput> | ModuloPermisoCreateWithoutModuloInput[] | ModuloPermisoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutModuloInput | ModuloPermisoCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloPermisoUpsertWithWhereUniqueWithoutModuloInput | ModuloPermisoUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloPermisoCreateManyModuloInputEnvelope
    set?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    disconnect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    delete?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    connect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    update?: ModuloPermisoUpdateWithWhereUniqueWithoutModuloInput | ModuloPermisoUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloPermisoUpdateManyWithWhereWithoutModuloInput | ModuloPermisoUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloPermisoScalarWhereInput | ModuloPermisoScalarWhereInput[]
  }

  export type ModuloRutaUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput> | ModuloRutaCreateWithoutModuloInput[] | ModuloRutaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloRutaCreateOrConnectWithoutModuloInput | ModuloRutaCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloRutaUpsertWithWhereUniqueWithoutModuloInput | ModuloRutaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloRutaCreateManyModuloInputEnvelope
    set?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    disconnect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    delete?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    connect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    update?: ModuloRutaUpdateWithWhereUniqueWithoutModuloInput | ModuloRutaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloRutaUpdateManyWithWhereWithoutModuloInput | ModuloRutaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloRutaScalarWhereInput | ModuloRutaScalarWhereInput[]
  }

  export type EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput> | EmpresaModuloCreateWithoutModuloInput[] | EmpresaModuloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: EmpresaModuloCreateOrConnectWithoutModuloInput | EmpresaModuloCreateOrConnectWithoutModuloInput[]
    upsert?: EmpresaModuloUpsertWithWhereUniqueWithoutModuloInput | EmpresaModuloUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: EmpresaModuloCreateManyModuloInputEnvelope
    set?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    disconnect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    delete?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    connect?: EmpresaModuloWhereUniqueInput | EmpresaModuloWhereUniqueInput[]
    update?: EmpresaModuloUpdateWithWhereUniqueWithoutModuloInput | EmpresaModuloUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: EmpresaModuloUpdateManyWithWhereWithoutModuloInput | EmpresaModuloUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput> | ModuloHistoricoCreateWithoutModuloInput[] | ModuloHistoricoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloHistoricoCreateOrConnectWithoutModuloInput | ModuloHistoricoCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloHistoricoUpsertWithWhereUniqueWithoutModuloInput | ModuloHistoricoUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloHistoricoCreateManyModuloInputEnvelope
    set?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    disconnect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    delete?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    connect?: ModuloHistoricoWhereUniqueInput | ModuloHistoricoWhereUniqueInput[]
    update?: ModuloHistoricoUpdateWithWhereUniqueWithoutModuloInput | ModuloHistoricoUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloHistoricoUpdateManyWithWhereWithoutModuloInput | ModuloHistoricoUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
  }

  export type ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput = {
    create?: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput> | ModuloDependenciaCreateWithoutDependeDeInput[] | ModuloDependenciaUncheckedCreateWithoutDependeDeInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutDependeDeInput | ModuloDependenciaCreateOrConnectWithoutDependeDeInput[]
    upsert?: ModuloDependenciaUpsertWithWhereUniqueWithoutDependeDeInput | ModuloDependenciaUpsertWithWhereUniqueWithoutDependeDeInput[]
    createMany?: ModuloDependenciaCreateManyDependeDeInputEnvelope
    set?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    disconnect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    delete?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    update?: ModuloDependenciaUpdateWithWhereUniqueWithoutDependeDeInput | ModuloDependenciaUpdateWithWhereUniqueWithoutDependeDeInput[]
    updateMany?: ModuloDependenciaUpdateManyWithWhereWithoutDependeDeInput | ModuloDependenciaUpdateManyWithWhereWithoutDependeDeInput[]
    deleteMany?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
  }

  export type ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput> | ModuloDependenciaCreateWithoutModuloInput[] | ModuloDependenciaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloDependenciaCreateOrConnectWithoutModuloInput | ModuloDependenciaCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloDependenciaUpsertWithWhereUniqueWithoutModuloInput | ModuloDependenciaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloDependenciaCreateManyModuloInputEnvelope
    set?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    disconnect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    delete?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    connect?: ModuloDependenciaWhereUniqueInput | ModuloDependenciaWhereUniqueInput[]
    update?: ModuloDependenciaUpdateWithWhereUniqueWithoutModuloInput | ModuloDependenciaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloDependenciaUpdateManyWithWhereWithoutModuloInput | ModuloDependenciaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
  }

  export type ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput> | ModuloPermisoCreateWithoutModuloInput[] | ModuloPermisoUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutModuloInput | ModuloPermisoCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloPermisoUpsertWithWhereUniqueWithoutModuloInput | ModuloPermisoUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloPermisoCreateManyModuloInputEnvelope
    set?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    disconnect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    delete?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    connect?: ModuloPermisoWhereUniqueInput | ModuloPermisoWhereUniqueInput[]
    update?: ModuloPermisoUpdateWithWhereUniqueWithoutModuloInput | ModuloPermisoUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloPermisoUpdateManyWithWhereWithoutModuloInput | ModuloPermisoUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloPermisoScalarWhereInput | ModuloPermisoScalarWhereInput[]
  }

  export type ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput> | ModuloRutaCreateWithoutModuloInput[] | ModuloRutaUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ModuloRutaCreateOrConnectWithoutModuloInput | ModuloRutaCreateOrConnectWithoutModuloInput[]
    upsert?: ModuloRutaUpsertWithWhereUniqueWithoutModuloInput | ModuloRutaUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ModuloRutaCreateManyModuloInputEnvelope
    set?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    disconnect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    delete?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    connect?: ModuloRutaWhereUniqueInput | ModuloRutaWhereUniqueInput[]
    update?: ModuloRutaUpdateWithWhereUniqueWithoutModuloInput | ModuloRutaUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ModuloRutaUpdateManyWithWhereWithoutModuloInput | ModuloRutaUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ModuloRutaScalarWhereInput | ModuloRutaScalarWhereInput[]
  }

  export type EmpresaCreateNestedOneWithoutModulosActivosInput = {
    create?: XOR<EmpresaCreateWithoutModulosActivosInput, EmpresaUncheckedCreateWithoutModulosActivosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutModulosActivosInput
    connect?: EmpresaWhereUniqueInput
  }

  export type ModuloCreateNestedOneWithoutEmpresasConModuloInput = {
    create?: XOR<ModuloCreateWithoutEmpresasConModuloInput, ModuloUncheckedCreateWithoutEmpresasConModuloInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutEmpresasConModuloInput
    connect?: ModuloWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutModulosActivosNestedInput = {
    create?: XOR<EmpresaCreateWithoutModulosActivosInput, EmpresaUncheckedCreateWithoutModulosActivosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutModulosActivosInput
    upsert?: EmpresaUpsertWithoutModulosActivosInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutModulosActivosInput, EmpresaUpdateWithoutModulosActivosInput>, EmpresaUncheckedUpdateWithoutModulosActivosInput>
  }

  export type ModuloUpdateOneRequiredWithoutEmpresasConModuloNestedInput = {
    create?: XOR<ModuloCreateWithoutEmpresasConModuloInput, ModuloUncheckedCreateWithoutEmpresasConModuloInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutEmpresasConModuloInput
    upsert?: ModuloUpsertWithoutEmpresasConModuloInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutEmpresasConModuloInput, ModuloUpdateWithoutEmpresasConModuloInput>, ModuloUncheckedUpdateWithoutEmpresasConModuloInput>
  }

  export type ModuloCreateNestedOneWithoutEsDependenciaDeInput = {
    create?: XOR<ModuloCreateWithoutEsDependenciaDeInput, ModuloUncheckedCreateWithoutEsDependenciaDeInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutEsDependenciaDeInput
    connect?: ModuloWhereUniqueInput
  }

  export type ModuloCreateNestedOneWithoutDependeDeInput = {
    create?: XOR<ModuloCreateWithoutDependeDeInput, ModuloUncheckedCreateWithoutDependeDeInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutDependeDeInput
    connect?: ModuloWhereUniqueInput
  }

  export type ModuloUpdateOneRequiredWithoutEsDependenciaDeNestedInput = {
    create?: XOR<ModuloCreateWithoutEsDependenciaDeInput, ModuloUncheckedCreateWithoutEsDependenciaDeInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutEsDependenciaDeInput
    upsert?: ModuloUpsertWithoutEsDependenciaDeInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutEsDependenciaDeInput, ModuloUpdateWithoutEsDependenciaDeInput>, ModuloUncheckedUpdateWithoutEsDependenciaDeInput>
  }

  export type ModuloUpdateOneRequiredWithoutDependeDeNestedInput = {
    create?: XOR<ModuloCreateWithoutDependeDeInput, ModuloUncheckedCreateWithoutDependeDeInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutDependeDeInput
    upsert?: ModuloUpsertWithoutDependeDeInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutDependeDeInput, ModuloUpdateWithoutDependeDeInput>, ModuloUncheckedUpdateWithoutDependeDeInput>
  }

  export type ModuloCreateNestedOneWithoutRutasInput = {
    create?: XOR<ModuloCreateWithoutRutasInput, ModuloUncheckedCreateWithoutRutasInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutRutasInput
    connect?: ModuloWhereUniqueInput
  }

  export type ModuloUpdateOneRequiredWithoutRutasNestedInput = {
    create?: XOR<ModuloCreateWithoutRutasInput, ModuloUncheckedCreateWithoutRutasInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutRutasInput
    upsert?: ModuloUpsertWithoutRutasInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutRutasInput, ModuloUpdateWithoutRutasInput>, ModuloUncheckedUpdateWithoutRutasInput>
  }

  export type RolPermisoCreateNestedManyWithoutRolInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput> | UsuarioCreateWithoutRolInput[] | UsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolInput | UsuarioCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioCreateManyRolInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type RolPermisoUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput> | UsuarioCreateWithoutRolInput[] | UsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolInput | UsuarioCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioCreateManyRolInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type RolPermisoUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutRolInput | RolPermisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutRolInput | RolPermisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutRolInput | RolPermisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput> | UsuarioCreateWithoutRolInput[] | UsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolInput | UsuarioCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRolInput | UsuarioUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioCreateManyRolInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRolInput | UsuarioUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRolInput | UsuarioUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type RolPermisoUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutRolInput | RolPermisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutRolInput | RolPermisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutRolInput | RolPermisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput> | UsuarioCreateWithoutRolInput[] | UsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolInput | UsuarioCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRolInput | UsuarioUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioCreateManyRolInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRolInput | UsuarioUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRolInput | UsuarioUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type ModuloCreateNestedOneWithoutPermisosInput = {
    create?: XOR<ModuloCreateWithoutPermisosInput, ModuloUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutPermisosInput
    connect?: ModuloWhereUniqueInput
  }

  export type RolPermisoCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type RolPermisoUncheckedCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type ModuloUpdateOneRequiredWithoutPermisosNestedInput = {
    create?: XOR<ModuloCreateWithoutPermisosInput, ModuloUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutPermisosInput
    upsert?: ModuloUpsertWithoutPermisosInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutPermisosInput, ModuloUpdateWithoutPermisosInput>, ModuloUncheckedUpdateWithoutPermisosInput>
  }

  export type RolPermisoUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutPermisoInput | RolPermisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutPermisoInput | RolPermisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutPermisoInput | RolPermisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutPermisoInput | RolPermisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutPermisoInput | RolPermisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutPermisoInput | RolPermisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type ModuloPermisoCreateNestedOneWithoutRolesInput = {
    create?: XOR<ModuloPermisoCreateWithoutRolesInput, ModuloPermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutRolesInput
    connect?: ModuloPermisoWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutPermisosInput = {
    create?: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: RolCreateOrConnectWithoutPermisosInput
    connect?: RolWhereUniqueInput
  }

  export type ModuloPermisoUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<ModuloPermisoCreateWithoutRolesInput, ModuloPermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ModuloPermisoCreateOrConnectWithoutRolesInput
    upsert?: ModuloPermisoUpsertWithoutRolesInput
    connect?: ModuloPermisoWhereUniqueInput
    update?: XOR<XOR<ModuloPermisoUpdateToOneWithWhereWithoutRolesInput, ModuloPermisoUpdateWithoutRolesInput>, ModuloPermisoUncheckedUpdateWithoutRolesInput>
  }

  export type RolUpdateOneRequiredWithoutPermisosNestedInput = {
    create?: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: RolCreateOrConnectWithoutPermisosInput
    upsert?: RolUpsertWithoutPermisosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutPermisosInput, RolUpdateWithoutPermisosInput>, RolUncheckedUpdateWithoutPermisosInput>
  }

  export type EmpresaCreateNestedOneWithoutConfiguracionesInput = {
    create?: XOR<EmpresaCreateWithoutConfiguracionesInput, EmpresaUncheckedCreateWithoutConfiguracionesInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutConfiguracionesInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutConfiguracionesNestedInput = {
    create?: XOR<EmpresaCreateWithoutConfiguracionesInput, EmpresaUncheckedCreateWithoutConfiguracionesInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutConfiguracionesInput
    upsert?: EmpresaUpsertWithoutConfiguracionesInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutConfiguracionesInput, EmpresaUpdateWithoutConfiguracionesInput>, EmpresaUncheckedUpdateWithoutConfiguracionesInput>
  }

  export type EmpresaCreateNestedOneWithoutFacturasInput = {
    create?: XOR<EmpresaCreateWithoutFacturasInput, EmpresaUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutFacturasInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<EmpresaCreateWithoutFacturasInput, EmpresaUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutFacturasInput
    upsert?: EmpresaUpsertWithoutFacturasInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutFacturasInput, EmpresaUpdateWithoutFacturasInput>, EmpresaUncheckedUpdateWithoutFacturasInput>
  }

  export type EmpresaCreateNestedOneWithoutProductosInput = {
    create?: XOR<EmpresaCreateWithoutProductosInput, EmpresaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutProductosInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<EmpresaCreateWithoutProductosInput, EmpresaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutProductosInput
    upsert?: EmpresaUpsertWithoutProductosInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutProductosInput, EmpresaUpdateWithoutProductosInput>, EmpresaUncheckedUpdateWithoutProductosInput>
  }

  export type EmpresaCreateNestedOneWithoutClientesInput = {
    create?: XOR<EmpresaCreateWithoutClientesInput, EmpresaUncheckedCreateWithoutClientesInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutClientesInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutClientesNestedInput = {
    create?: XOR<EmpresaCreateWithoutClientesInput, EmpresaUncheckedCreateWithoutClientesInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutClientesInput
    upsert?: EmpresaUpsertWithoutClientesInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutClientesInput, EmpresaUpdateWithoutClientesInput>, EmpresaUncheckedUpdateWithoutClientesInput>
  }

  export type EmpresaCreateNestedOneWithoutMovimientosCajaInput = {
    create?: XOR<EmpresaCreateWithoutMovimientosCajaInput, EmpresaUncheckedCreateWithoutMovimientosCajaInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutMovimientosCajaInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutMovimientosCajaNestedInput = {
    create?: XOR<EmpresaCreateWithoutMovimientosCajaInput, EmpresaUncheckedCreateWithoutMovimientosCajaInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutMovimientosCajaInput
    upsert?: EmpresaUpsertWithoutMovimientosCajaInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutMovimientosCajaInput, EmpresaUpdateWithoutMovimientosCajaInput>, EmpresaUncheckedUpdateWithoutMovimientosCajaInput>
  }

  export type EmpresaCreateNestedOneWithoutModuloHistoricoInput = {
    create?: XOR<EmpresaCreateWithoutModuloHistoricoInput, EmpresaUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutModuloHistoricoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type ModuloCreateNestedOneWithoutModuloHistoricoInput = {
    create?: XOR<ModuloCreateWithoutModuloHistoricoInput, ModuloUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutModuloHistoricoInput
    connect?: ModuloWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutModuloHistoricoInput = {
    create?: XOR<UsuarioCreateWithoutModuloHistoricoInput, UsuarioUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutModuloHistoricoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutModuloHistoricoNestedInput = {
    create?: XOR<EmpresaCreateWithoutModuloHistoricoInput, EmpresaUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutModuloHistoricoInput
    upsert?: EmpresaUpsertWithoutModuloHistoricoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutModuloHistoricoInput, EmpresaUpdateWithoutModuloHistoricoInput>, EmpresaUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type ModuloUpdateOneRequiredWithoutModuloHistoricoNestedInput = {
    create?: XOR<ModuloCreateWithoutModuloHistoricoInput, ModuloUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutModuloHistoricoInput
    upsert?: ModuloUpsertWithoutModuloHistoricoInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutModuloHistoricoInput, ModuloUpdateWithoutModuloHistoricoInput>, ModuloUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutModuloHistoricoNestedInput = {
    create?: XOR<UsuarioCreateWithoutModuloHistoricoInput, UsuarioUncheckedCreateWithoutModuloHistoricoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutModuloHistoricoInput
    upsert?: UsuarioUpsertWithoutModuloHistoricoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutModuloHistoricoInput, UsuarioUpdateWithoutModuloHistoricoInput>, UsuarioUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type EmpresaCreateNestedOneWithoutPlanCuentasInput = {
    create?: XOR<EmpresaCreateWithoutPlanCuentasInput, EmpresaUncheckedCreateWithoutPlanCuentasInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutPlanCuentasInput
    connect?: EmpresaWhereUniqueInput
  }

  export type EmpresaUpdateOneRequiredWithoutPlanCuentasNestedInput = {
    create?: XOR<EmpresaCreateWithoutPlanCuentasInput, EmpresaUncheckedCreateWithoutPlanCuentasInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutPlanCuentasInput
    upsert?: EmpresaUpsertWithoutPlanCuentasInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutPlanCuentasInput, EmpresaUpdateWithoutPlanCuentasInput>, EmpresaUncheckedUpdateWithoutPlanCuentasInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClienteCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUncheckedCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteCreateOrConnectWithoutEmpresaInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput>
  }

  export type ClienteCreateManyEmpresaInputEnvelope = {
    data: ClienteCreateManyEmpresaInput | ClienteCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaConfiguracionCreateWithoutEmpresaInput = {
    id?: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput = {
    id?: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaConfiguracionCreateOrConnectWithoutEmpresaInput = {
    where: EmpresaConfiguracionWhereUniqueInput
    create: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput>
  }

  export type EmpresaConfiguracionCreateManyEmpresaInputEnvelope = {
    data: EmpresaConfiguracionCreateManyEmpresaInput | EmpresaConfiguracionCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaModuloCreateWithoutEmpresaInput = {
    id?: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
    modulo: ModuloCreateNestedOneWithoutEmpresasConModuloInput
  }

  export type EmpresaModuloUncheckedCreateWithoutEmpresaInput = {
    id?: string
    moduloId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type EmpresaModuloCreateOrConnectWithoutEmpresaInput = {
    where: EmpresaModuloWhereUniqueInput
    create: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput>
  }

  export type EmpresaModuloCreateManyEmpresaInputEnvelope = {
    data: EmpresaModuloCreateManyEmpresaInput | EmpresaModuloCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type ModuloHistoricoCreateWithoutEmpresaInput = {
    id?: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
    modulo: ModuloCreateNestedOneWithoutModuloHistoricoInput
    usuario: UsuarioCreateNestedOneWithoutModuloHistoricoInput
  }

  export type ModuloHistoricoUncheckedCreateWithoutEmpresaInput = {
    id?: string
    moduloId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoCreateOrConnectWithoutEmpresaInput = {
    where: ModuloHistoricoWhereUniqueInput
    create: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput>
  }

  export type ModuloHistoricoCreateManyEmpresaInputEnvelope = {
    data: ModuloHistoricoCreateManyEmpresaInput | ModuloHistoricoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type FacturaCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacturaUncheckedCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacturaCreateOrConnectWithoutEmpresaInput = {
    where: FacturaWhereUniqueInput
    create: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput>
  }

  export type FacturaCreateManyEmpresaInputEnvelope = {
    data: FacturaCreateManyEmpresaInput | FacturaCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type MovimientoCajaCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovimientoCajaUncheckedCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovimientoCajaCreateOrConnectWithoutEmpresaInput = {
    where: MovimientoCajaWhereUniqueInput
    create: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput>
  }

  export type MovimientoCajaCreateManyEmpresaInputEnvelope = {
    data: MovimientoCajaCreateManyEmpresaInput | MovimientoCajaCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type ProductoCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductoUncheckedCreateWithoutEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductoCreateOrConnectWithoutEmpresaInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput>
  }

  export type ProductoCreateManyEmpresaInputEnvelope = {
    data: ProductoCreateManyEmpresaInput | ProductoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutEmpresaInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    rol: RolCreateNestedOneWithoutUsuariosInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEmpresaInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    rolId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEmpresaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput>
  }

  export type UsuarioCreateManyEmpresaInputEnvelope = {
    data: UsuarioCreateManyEmpresaInput | UsuarioCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type PlanCuentasCreateWithoutEmpresaInput = {
    id?: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type PlanCuentasUncheckedCreateWithoutEmpresaInput = {
    id?: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type PlanCuentasCreateOrConnectWithoutEmpresaInput = {
    where: PlanCuentasWhereUniqueInput
    create: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput>
  }

  export type PlanCuentasCreateManyEmpresaInputEnvelope = {
    data: PlanCuentasCreateManyEmpresaInput | PlanCuentasCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: ClienteWhereUniqueInput
    update: XOR<ClienteUpdateWithoutEmpresaInput, ClienteUncheckedUpdateWithoutEmpresaInput>
    create: XOR<ClienteCreateWithoutEmpresaInput, ClienteUncheckedCreateWithoutEmpresaInput>
  }

  export type ClienteUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: ClienteWhereUniqueInput
    data: XOR<ClienteUpdateWithoutEmpresaInput, ClienteUncheckedUpdateWithoutEmpresaInput>
  }

  export type ClienteUpdateManyWithWhereWithoutEmpresaInput = {
    where: ClienteScalarWhereInput
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type ClienteScalarWhereInput = {
    AND?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    OR?: ClienteScalarWhereInput[]
    NOT?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    id?: StringFilter<"Cliente"> | string
    empresaId?: StringFilter<"Cliente"> | string
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
  }

  export type EmpresaConfiguracionUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: EmpresaConfiguracionWhereUniqueInput
    update: XOR<EmpresaConfiguracionUpdateWithoutEmpresaInput, EmpresaConfiguracionUncheckedUpdateWithoutEmpresaInput>
    create: XOR<EmpresaConfiguracionCreateWithoutEmpresaInput, EmpresaConfiguracionUncheckedCreateWithoutEmpresaInput>
  }

  export type EmpresaConfiguracionUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: EmpresaConfiguracionWhereUniqueInput
    data: XOR<EmpresaConfiguracionUpdateWithoutEmpresaInput, EmpresaConfiguracionUncheckedUpdateWithoutEmpresaInput>
  }

  export type EmpresaConfiguracionUpdateManyWithWhereWithoutEmpresaInput = {
    where: EmpresaConfiguracionScalarWhereInput
    data: XOR<EmpresaConfiguracionUpdateManyMutationInput, EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type EmpresaConfiguracionScalarWhereInput = {
    AND?: EmpresaConfiguracionScalarWhereInput | EmpresaConfiguracionScalarWhereInput[]
    OR?: EmpresaConfiguracionScalarWhereInput[]
    NOT?: EmpresaConfiguracionScalarWhereInput | EmpresaConfiguracionScalarWhereInput[]
    id?: StringFilter<"EmpresaConfiguracion"> | string
    empresaId?: StringFilter<"EmpresaConfiguracion"> | string
    clave?: StringFilter<"EmpresaConfiguracion"> | string
    valor?: JsonFilter<"EmpresaConfiguracion">
    activo?: BoolFilter<"EmpresaConfiguracion"> | boolean
    createdAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
    updatedAt?: DateTimeFilter<"EmpresaConfiguracion"> | Date | string
  }

  export type EmpresaModuloUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: EmpresaModuloWhereUniqueInput
    update: XOR<EmpresaModuloUpdateWithoutEmpresaInput, EmpresaModuloUncheckedUpdateWithoutEmpresaInput>
    create: XOR<EmpresaModuloCreateWithoutEmpresaInput, EmpresaModuloUncheckedCreateWithoutEmpresaInput>
  }

  export type EmpresaModuloUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: EmpresaModuloWhereUniqueInput
    data: XOR<EmpresaModuloUpdateWithoutEmpresaInput, EmpresaModuloUncheckedUpdateWithoutEmpresaInput>
  }

  export type EmpresaModuloUpdateManyWithWhereWithoutEmpresaInput = {
    where: EmpresaModuloScalarWhereInput
    data: XOR<EmpresaModuloUpdateManyMutationInput, EmpresaModuloUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type EmpresaModuloScalarWhereInput = {
    AND?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
    OR?: EmpresaModuloScalarWhereInput[]
    NOT?: EmpresaModuloScalarWhereInput | EmpresaModuloScalarWhereInput[]
    id?: StringFilter<"EmpresaModulo"> | string
    empresaId?: StringFilter<"EmpresaModulo"> | string
    moduloId?: StringFilter<"EmpresaModulo"> | string
    activo?: BoolFilter<"EmpresaModulo"> | boolean
    configuracion?: JsonNullableFilter<"EmpresaModulo">
    fechaActivacion?: DateTimeFilter<"EmpresaModulo"> | Date | string
    fechaDesactivacion?: DateTimeNullableFilter<"EmpresaModulo"> | Date | string | null
  }

  export type ModuloHistoricoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: ModuloHistoricoWhereUniqueInput
    update: XOR<ModuloHistoricoUpdateWithoutEmpresaInput, ModuloHistoricoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<ModuloHistoricoCreateWithoutEmpresaInput, ModuloHistoricoUncheckedCreateWithoutEmpresaInput>
  }

  export type ModuloHistoricoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: ModuloHistoricoWhereUniqueInput
    data: XOR<ModuloHistoricoUpdateWithoutEmpresaInput, ModuloHistoricoUncheckedUpdateWithoutEmpresaInput>
  }

  export type ModuloHistoricoUpdateManyWithWhereWithoutEmpresaInput = {
    where: ModuloHistoricoScalarWhereInput
    data: XOR<ModuloHistoricoUpdateManyMutationInput, ModuloHistoricoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type ModuloHistoricoScalarWhereInput = {
    AND?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
    OR?: ModuloHistoricoScalarWhereInput[]
    NOT?: ModuloHistoricoScalarWhereInput | ModuloHistoricoScalarWhereInput[]
    id?: StringFilter<"ModuloHistorico"> | string
    empresaId?: StringFilter<"ModuloHistorico"> | string
    moduloId?: StringFilter<"ModuloHistorico"> | string
    accion?: StringFilter<"ModuloHistorico"> | string
    usuarioId?: StringFilter<"ModuloHistorico"> | string
    razon?: StringNullableFilter<"ModuloHistorico"> | string | null
    fechaCreacion?: DateTimeFilter<"ModuloHistorico"> | Date | string
  }

  export type FacturaUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: FacturaWhereUniqueInput
    update: XOR<FacturaUpdateWithoutEmpresaInput, FacturaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<FacturaCreateWithoutEmpresaInput, FacturaUncheckedCreateWithoutEmpresaInput>
  }

  export type FacturaUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: FacturaWhereUniqueInput
    data: XOR<FacturaUpdateWithoutEmpresaInput, FacturaUncheckedUpdateWithoutEmpresaInput>
  }

  export type FacturaUpdateManyWithWhereWithoutEmpresaInput = {
    where: FacturaScalarWhereInput
    data: XOR<FacturaUpdateManyMutationInput, FacturaUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type FacturaScalarWhereInput = {
    AND?: FacturaScalarWhereInput | FacturaScalarWhereInput[]
    OR?: FacturaScalarWhereInput[]
    NOT?: FacturaScalarWhereInput | FacturaScalarWhereInput[]
    id?: StringFilter<"Factura"> | string
    empresaId?: StringFilter<"Factura"> | string
    createdAt?: DateTimeFilter<"Factura"> | Date | string
    updatedAt?: DateTimeFilter<"Factura"> | Date | string
  }

  export type MovimientoCajaUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: MovimientoCajaWhereUniqueInput
    update: XOR<MovimientoCajaUpdateWithoutEmpresaInput, MovimientoCajaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<MovimientoCajaCreateWithoutEmpresaInput, MovimientoCajaUncheckedCreateWithoutEmpresaInput>
  }

  export type MovimientoCajaUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: MovimientoCajaWhereUniqueInput
    data: XOR<MovimientoCajaUpdateWithoutEmpresaInput, MovimientoCajaUncheckedUpdateWithoutEmpresaInput>
  }

  export type MovimientoCajaUpdateManyWithWhereWithoutEmpresaInput = {
    where: MovimientoCajaScalarWhereInput
    data: XOR<MovimientoCajaUpdateManyMutationInput, MovimientoCajaUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type MovimientoCajaScalarWhereInput = {
    AND?: MovimientoCajaScalarWhereInput | MovimientoCajaScalarWhereInput[]
    OR?: MovimientoCajaScalarWhereInput[]
    NOT?: MovimientoCajaScalarWhereInput | MovimientoCajaScalarWhereInput[]
    id?: StringFilter<"MovimientoCaja"> | string
    empresaId?: StringFilter<"MovimientoCaja"> | string
    createdAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
    updatedAt?: DateTimeFilter<"MovimientoCaja"> | Date | string
  }

  export type ProductoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutEmpresaInput, ProductoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<ProductoCreateWithoutEmpresaInput, ProductoUncheckedCreateWithoutEmpresaInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutEmpresaInput, ProductoUncheckedUpdateWithoutEmpresaInput>
  }

  export type ProductoUpdateManyWithWhereWithoutEmpresaInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id?: StringFilter<"Producto"> | string
    empresaId?: StringFilter<"Producto"> | string
    createdAt?: DateTimeFilter<"Producto"> | Date | string
    updatedAt?: DateTimeFilter<"Producto"> | Date | string
  }

  export type UsuarioUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutEmpresaInput, UsuarioUncheckedUpdateWithoutEmpresaInput>
    create: XOR<UsuarioCreateWithoutEmpresaInput, UsuarioUncheckedCreateWithoutEmpresaInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutEmpresaInput, UsuarioUncheckedUpdateWithoutEmpresaInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutEmpresaInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringNullableFilter<"Usuario"> | string | null
    password?: StringFilter<"Usuario"> | string
    empresaId?: StringFilter<"Usuario"> | string
    rolId?: StringFilter<"Usuario"> | string
    activo?: BoolFilter<"Usuario"> | boolean
    resetToken?: StringNullableFilter<"Usuario"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Usuario"> | Date | string | null
  }

  export type PlanCuentasUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: PlanCuentasWhereUniqueInput
    update: XOR<PlanCuentasUpdateWithoutEmpresaInput, PlanCuentasUncheckedUpdateWithoutEmpresaInput>
    create: XOR<PlanCuentasCreateWithoutEmpresaInput, PlanCuentasUncheckedCreateWithoutEmpresaInput>
  }

  export type PlanCuentasUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: PlanCuentasWhereUniqueInput
    data: XOR<PlanCuentasUpdateWithoutEmpresaInput, PlanCuentasUncheckedUpdateWithoutEmpresaInput>
  }

  export type PlanCuentasUpdateManyWithWhereWithoutEmpresaInput = {
    where: PlanCuentasScalarWhereInput
    data: XOR<PlanCuentasUpdateManyMutationInput, PlanCuentasUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type PlanCuentasScalarWhereInput = {
    AND?: PlanCuentasScalarWhereInput | PlanCuentasScalarWhereInput[]
    OR?: PlanCuentasScalarWhereInput[]
    NOT?: PlanCuentasScalarWhereInput | PlanCuentasScalarWhereInput[]
    id?: StringFilter<"PlanCuentas"> | string
    empresaId?: StringFilter<"PlanCuentas"> | string
    codigo?: StringFilter<"PlanCuentas"> | string
    codigoPadre?: StringNullableFilter<"PlanCuentas"> | string | null
    nivel?: IntFilter<"PlanCuentas"> | number
    nombre?: StringFilter<"PlanCuentas"> | string
    nombreCompleto?: StringNullableFilter<"PlanCuentas"> | string | null
    nombreCorto?: StringNullableFilter<"PlanCuentas"> | string | null
    tipoMayor?: StringFilter<"PlanCuentas"> | string
    tipoDetalle?: StringNullableFilter<"PlanCuentas"> | string | null
    naturaleza?: StringFilter<"PlanCuentas"> | string
    permiteMovimiento?: BoolFilter<"PlanCuentas"> | boolean
    esAuxiliar?: BoolFilter<"PlanCuentas"> | boolean
    nivelMaximo?: IntFilter<"PlanCuentas"> | number
    monedaPermitida?: StringFilter<"PlanCuentas"> | string
    centroCostoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    proyectoObligatorio?: BoolFilter<"PlanCuentas"> | boolean
    requiereReferencia?: BoolFilter<"PlanCuentas"> | boolean
    requiereCliente?: BoolFilter<"PlanCuentas"> | boolean
    requiereProveedor?: BoolFilter<"PlanCuentas"> | boolean
    activo?: BoolFilter<"PlanCuentas"> | boolean
    fechaCreacion?: DateTimeFilter<"PlanCuentas"> | Date | string
    fechaActualizacion?: DateTimeFilter<"PlanCuentas"> | Date | string
  }

  export type EmpresaCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutUsuariosInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutUsuariosInput, EmpresaUncheckedCreateWithoutUsuariosInput>
  }

  export type RolCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    permisos?: RolPermisoCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    permisos?: RolPermisoUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type ModuloHistoricoCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
    empresa: EmpresaCreateNestedOneWithoutModuloHistoricoInput
    modulo: ModuloCreateNestedOneWithoutModuloHistoricoInput
  }

  export type ModuloHistoricoUncheckedCreateWithoutUsuarioInput = {
    id?: string
    empresaId: string
    moduloId: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoCreateOrConnectWithoutUsuarioInput = {
    where: ModuloHistoricoWhereUniqueInput
    create: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput>
  }

  export type ModuloHistoricoCreateManyUsuarioInputEnvelope = {
    data: ModuloHistoricoCreateManyUsuarioInput | ModuloHistoricoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaUpsertWithoutUsuariosInput = {
    update: XOR<EmpresaUpdateWithoutUsuariosInput, EmpresaUncheckedUpdateWithoutUsuariosInput>
    create: XOR<EmpresaCreateWithoutUsuariosInput, EmpresaUncheckedCreateWithoutUsuariosInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutUsuariosInput, EmpresaUncheckedUpdateWithoutUsuariosInput>
  }

  export type EmpresaUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type RolUpsertWithoutUsuariosInput = {
    update: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    permisos?: RolPermisoUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    permisos?: RolPermisoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type ModuloHistoricoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ModuloHistoricoWhereUniqueInput
    update: XOR<ModuloHistoricoUpdateWithoutUsuarioInput, ModuloHistoricoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ModuloHistoricoCreateWithoutUsuarioInput, ModuloHistoricoUncheckedCreateWithoutUsuarioInput>
  }

  export type ModuloHistoricoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ModuloHistoricoWhereUniqueInput
    data: XOR<ModuloHistoricoUpdateWithoutUsuarioInput, ModuloHistoricoUncheckedUpdateWithoutUsuarioInput>
  }

  export type ModuloHistoricoUpdateManyWithWhereWithoutUsuarioInput = {
    where: ModuloHistoricoScalarWhereInput
    data: XOR<ModuloHistoricoUpdateManyMutationInput, ModuloHistoricoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EmpresaModuloCreateWithoutModuloInput = {
    id?: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
    empresa: EmpresaCreateNestedOneWithoutModulosActivosInput
  }

  export type EmpresaModuloUncheckedCreateWithoutModuloInput = {
    id?: string
    empresaId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type EmpresaModuloCreateOrConnectWithoutModuloInput = {
    where: EmpresaModuloWhereUniqueInput
    create: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput>
  }

  export type EmpresaModuloCreateManyModuloInputEnvelope = {
    data: EmpresaModuloCreateManyModuloInput | EmpresaModuloCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type ModuloHistoricoCreateWithoutModuloInput = {
    id?: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
    empresa: EmpresaCreateNestedOneWithoutModuloHistoricoInput
    usuario: UsuarioCreateNestedOneWithoutModuloHistoricoInput
  }

  export type ModuloHistoricoUncheckedCreateWithoutModuloInput = {
    id?: string
    empresaId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoCreateOrConnectWithoutModuloInput = {
    where: ModuloHistoricoWhereUniqueInput
    create: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput>
  }

  export type ModuloHistoricoCreateManyModuloInputEnvelope = {
    data: ModuloHistoricoCreateManyModuloInput | ModuloHistoricoCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type ModuloDependenciaCreateWithoutDependeDeInput = {
    id?: string
    requerido?: boolean
    modulo: ModuloCreateNestedOneWithoutDependeDeInput
  }

  export type ModuloDependenciaUncheckedCreateWithoutDependeDeInput = {
    id?: string
    moduloId: string
    requerido?: boolean
  }

  export type ModuloDependenciaCreateOrConnectWithoutDependeDeInput = {
    where: ModuloDependenciaWhereUniqueInput
    create: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput>
  }

  export type ModuloDependenciaCreateManyDependeDeInputEnvelope = {
    data: ModuloDependenciaCreateManyDependeDeInput | ModuloDependenciaCreateManyDependeDeInput[]
    skipDuplicates?: boolean
  }

  export type ModuloDependenciaCreateWithoutModuloInput = {
    id?: string
    requerido?: boolean
    dependeDe: ModuloCreateNestedOneWithoutEsDependenciaDeInput
  }

  export type ModuloDependenciaUncheckedCreateWithoutModuloInput = {
    id?: string
    dependeDeId: string
    requerido?: boolean
  }

  export type ModuloDependenciaCreateOrConnectWithoutModuloInput = {
    where: ModuloDependenciaWhereUniqueInput
    create: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput>
  }

  export type ModuloDependenciaCreateManyModuloInputEnvelope = {
    data: ModuloDependenciaCreateManyModuloInput | ModuloDependenciaCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type ModuloPermisoCreateWithoutModuloInput = {
    id?: string
    nombre: string
    codigo: string
    descripcion?: string | null
    roles?: RolPermisoCreateNestedManyWithoutPermisoInput
  }

  export type ModuloPermisoUncheckedCreateWithoutModuloInput = {
    id?: string
    nombre: string
    codigo: string
    descripcion?: string | null
    roles?: RolPermisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type ModuloPermisoCreateOrConnectWithoutModuloInput = {
    where: ModuloPermisoWhereUniqueInput
    create: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput>
  }

  export type ModuloPermisoCreateManyModuloInputEnvelope = {
    data: ModuloPermisoCreateManyModuloInput | ModuloPermisoCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type ModuloRutaCreateWithoutModuloInput = {
    id?: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
  }

  export type ModuloRutaUncheckedCreateWithoutModuloInput = {
    id?: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
  }

  export type ModuloRutaCreateOrConnectWithoutModuloInput = {
    where: ModuloRutaWhereUniqueInput
    create: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput>
  }

  export type ModuloRutaCreateManyModuloInputEnvelope = {
    data: ModuloRutaCreateManyModuloInput | ModuloRutaCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaModuloUpsertWithWhereUniqueWithoutModuloInput = {
    where: EmpresaModuloWhereUniqueInput
    update: XOR<EmpresaModuloUpdateWithoutModuloInput, EmpresaModuloUncheckedUpdateWithoutModuloInput>
    create: XOR<EmpresaModuloCreateWithoutModuloInput, EmpresaModuloUncheckedCreateWithoutModuloInput>
  }

  export type EmpresaModuloUpdateWithWhereUniqueWithoutModuloInput = {
    where: EmpresaModuloWhereUniqueInput
    data: XOR<EmpresaModuloUpdateWithoutModuloInput, EmpresaModuloUncheckedUpdateWithoutModuloInput>
  }

  export type EmpresaModuloUpdateManyWithWhereWithoutModuloInput = {
    where: EmpresaModuloScalarWhereInput
    data: XOR<EmpresaModuloUpdateManyMutationInput, EmpresaModuloUncheckedUpdateManyWithoutModuloInput>
  }

  export type ModuloHistoricoUpsertWithWhereUniqueWithoutModuloInput = {
    where: ModuloHistoricoWhereUniqueInput
    update: XOR<ModuloHistoricoUpdateWithoutModuloInput, ModuloHistoricoUncheckedUpdateWithoutModuloInput>
    create: XOR<ModuloHistoricoCreateWithoutModuloInput, ModuloHistoricoUncheckedCreateWithoutModuloInput>
  }

  export type ModuloHistoricoUpdateWithWhereUniqueWithoutModuloInput = {
    where: ModuloHistoricoWhereUniqueInput
    data: XOR<ModuloHistoricoUpdateWithoutModuloInput, ModuloHistoricoUncheckedUpdateWithoutModuloInput>
  }

  export type ModuloHistoricoUpdateManyWithWhereWithoutModuloInput = {
    where: ModuloHistoricoScalarWhereInput
    data: XOR<ModuloHistoricoUpdateManyMutationInput, ModuloHistoricoUncheckedUpdateManyWithoutModuloInput>
  }

  export type ModuloDependenciaUpsertWithWhereUniqueWithoutDependeDeInput = {
    where: ModuloDependenciaWhereUniqueInput
    update: XOR<ModuloDependenciaUpdateWithoutDependeDeInput, ModuloDependenciaUncheckedUpdateWithoutDependeDeInput>
    create: XOR<ModuloDependenciaCreateWithoutDependeDeInput, ModuloDependenciaUncheckedCreateWithoutDependeDeInput>
  }

  export type ModuloDependenciaUpdateWithWhereUniqueWithoutDependeDeInput = {
    where: ModuloDependenciaWhereUniqueInput
    data: XOR<ModuloDependenciaUpdateWithoutDependeDeInput, ModuloDependenciaUncheckedUpdateWithoutDependeDeInput>
  }

  export type ModuloDependenciaUpdateManyWithWhereWithoutDependeDeInput = {
    where: ModuloDependenciaScalarWhereInput
    data: XOR<ModuloDependenciaUpdateManyMutationInput, ModuloDependenciaUncheckedUpdateManyWithoutDependeDeInput>
  }

  export type ModuloDependenciaScalarWhereInput = {
    AND?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
    OR?: ModuloDependenciaScalarWhereInput[]
    NOT?: ModuloDependenciaScalarWhereInput | ModuloDependenciaScalarWhereInput[]
    id?: StringFilter<"ModuloDependencia"> | string
    moduloId?: StringFilter<"ModuloDependencia"> | string
    dependeDeId?: StringFilter<"ModuloDependencia"> | string
    requerido?: BoolFilter<"ModuloDependencia"> | boolean
  }

  export type ModuloDependenciaUpsertWithWhereUniqueWithoutModuloInput = {
    where: ModuloDependenciaWhereUniqueInput
    update: XOR<ModuloDependenciaUpdateWithoutModuloInput, ModuloDependenciaUncheckedUpdateWithoutModuloInput>
    create: XOR<ModuloDependenciaCreateWithoutModuloInput, ModuloDependenciaUncheckedCreateWithoutModuloInput>
  }

  export type ModuloDependenciaUpdateWithWhereUniqueWithoutModuloInput = {
    where: ModuloDependenciaWhereUniqueInput
    data: XOR<ModuloDependenciaUpdateWithoutModuloInput, ModuloDependenciaUncheckedUpdateWithoutModuloInput>
  }

  export type ModuloDependenciaUpdateManyWithWhereWithoutModuloInput = {
    where: ModuloDependenciaScalarWhereInput
    data: XOR<ModuloDependenciaUpdateManyMutationInput, ModuloDependenciaUncheckedUpdateManyWithoutModuloInput>
  }

  export type ModuloPermisoUpsertWithWhereUniqueWithoutModuloInput = {
    where: ModuloPermisoWhereUniqueInput
    update: XOR<ModuloPermisoUpdateWithoutModuloInput, ModuloPermisoUncheckedUpdateWithoutModuloInput>
    create: XOR<ModuloPermisoCreateWithoutModuloInput, ModuloPermisoUncheckedCreateWithoutModuloInput>
  }

  export type ModuloPermisoUpdateWithWhereUniqueWithoutModuloInput = {
    where: ModuloPermisoWhereUniqueInput
    data: XOR<ModuloPermisoUpdateWithoutModuloInput, ModuloPermisoUncheckedUpdateWithoutModuloInput>
  }

  export type ModuloPermisoUpdateManyWithWhereWithoutModuloInput = {
    where: ModuloPermisoScalarWhereInput
    data: XOR<ModuloPermisoUpdateManyMutationInput, ModuloPermisoUncheckedUpdateManyWithoutModuloInput>
  }

  export type ModuloPermisoScalarWhereInput = {
    AND?: ModuloPermisoScalarWhereInput | ModuloPermisoScalarWhereInput[]
    OR?: ModuloPermisoScalarWhereInput[]
    NOT?: ModuloPermisoScalarWhereInput | ModuloPermisoScalarWhereInput[]
    id?: StringFilter<"ModuloPermiso"> | string
    moduloId?: StringFilter<"ModuloPermiso"> | string
    nombre?: StringFilter<"ModuloPermiso"> | string
    codigo?: StringFilter<"ModuloPermiso"> | string
    descripcion?: StringNullableFilter<"ModuloPermiso"> | string | null
  }

  export type ModuloRutaUpsertWithWhereUniqueWithoutModuloInput = {
    where: ModuloRutaWhereUniqueInput
    update: XOR<ModuloRutaUpdateWithoutModuloInput, ModuloRutaUncheckedUpdateWithoutModuloInput>
    create: XOR<ModuloRutaCreateWithoutModuloInput, ModuloRutaUncheckedCreateWithoutModuloInput>
  }

  export type ModuloRutaUpdateWithWhereUniqueWithoutModuloInput = {
    where: ModuloRutaWhereUniqueInput
    data: XOR<ModuloRutaUpdateWithoutModuloInput, ModuloRutaUncheckedUpdateWithoutModuloInput>
  }

  export type ModuloRutaUpdateManyWithWhereWithoutModuloInput = {
    where: ModuloRutaScalarWhereInput
    data: XOR<ModuloRutaUpdateManyMutationInput, ModuloRutaUncheckedUpdateManyWithoutModuloInput>
  }

  export type ModuloRutaScalarWhereInput = {
    AND?: ModuloRutaScalarWhereInput | ModuloRutaScalarWhereInput[]
    OR?: ModuloRutaScalarWhereInput[]
    NOT?: ModuloRutaScalarWhereInput | ModuloRutaScalarWhereInput[]
    id?: StringFilter<"ModuloRuta"> | string
    moduloId?: StringFilter<"ModuloRuta"> | string
    ruta?: StringFilter<"ModuloRuta"> | string
    activo?: BoolFilter<"ModuloRuta"> | boolean
    descripcion?: StringNullableFilter<"ModuloRuta"> | string | null
    nombre?: StringFilter<"ModuloRuta"> | string
  }

  export type EmpresaCreateWithoutModulosActivosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutModulosActivosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutModulosActivosInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutModulosActivosInput, EmpresaUncheckedCreateWithoutModulosActivosInput>
  }

  export type ModuloCreateWithoutEmpresasConModuloInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutEmpresasConModuloInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutEmpresasConModuloInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutEmpresasConModuloInput, ModuloUncheckedCreateWithoutEmpresasConModuloInput>
  }

  export type EmpresaUpsertWithoutModulosActivosInput = {
    update: XOR<EmpresaUpdateWithoutModulosActivosInput, EmpresaUncheckedUpdateWithoutModulosActivosInput>
    create: XOR<EmpresaCreateWithoutModulosActivosInput, EmpresaUncheckedCreateWithoutModulosActivosInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutModulosActivosInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutModulosActivosInput, EmpresaUncheckedUpdateWithoutModulosActivosInput>
  }

  export type EmpresaUpdateWithoutModulosActivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutModulosActivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type ModuloUpsertWithoutEmpresasConModuloInput = {
    update: XOR<ModuloUpdateWithoutEmpresasConModuloInput, ModuloUncheckedUpdateWithoutEmpresasConModuloInput>
    create: XOR<ModuloCreateWithoutEmpresasConModuloInput, ModuloUncheckedCreateWithoutEmpresasConModuloInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutEmpresasConModuloInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutEmpresasConModuloInput, ModuloUncheckedUpdateWithoutEmpresasConModuloInput>
  }

  export type ModuloUpdateWithoutEmpresasConModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutEmpresasConModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type ModuloCreateWithoutEsDependenciaDeInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutEsDependenciaDeInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutEsDependenciaDeInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutEsDependenciaDeInput, ModuloUncheckedCreateWithoutEsDependenciaDeInput>
  }

  export type ModuloCreateWithoutDependeDeInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutDependeDeInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutDependeDeInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutDependeDeInput, ModuloUncheckedCreateWithoutDependeDeInput>
  }

  export type ModuloUpsertWithoutEsDependenciaDeInput = {
    update: XOR<ModuloUpdateWithoutEsDependenciaDeInput, ModuloUncheckedUpdateWithoutEsDependenciaDeInput>
    create: XOR<ModuloCreateWithoutEsDependenciaDeInput, ModuloUncheckedCreateWithoutEsDependenciaDeInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutEsDependenciaDeInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutEsDependenciaDeInput, ModuloUncheckedUpdateWithoutEsDependenciaDeInput>
  }

  export type ModuloUpdateWithoutEsDependenciaDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutEsDependenciaDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUpsertWithoutDependeDeInput = {
    update: XOR<ModuloUpdateWithoutDependeDeInput, ModuloUncheckedUpdateWithoutDependeDeInput>
    create: XOR<ModuloCreateWithoutDependeDeInput, ModuloUncheckedCreateWithoutDependeDeInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutDependeDeInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutDependeDeInput, ModuloUncheckedUpdateWithoutDependeDeInput>
  }

  export type ModuloUpdateWithoutDependeDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutDependeDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type ModuloCreateWithoutRutasInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutRutasInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutRutasInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutRutasInput, ModuloUncheckedCreateWithoutRutasInput>
  }

  export type ModuloUpsertWithoutRutasInput = {
    update: XOR<ModuloUpdateWithoutRutasInput, ModuloUncheckedUpdateWithoutRutasInput>
    create: XOR<ModuloCreateWithoutRutasInput, ModuloUncheckedCreateWithoutRutasInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutRutasInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutRutasInput, ModuloUncheckedUpdateWithoutRutasInput>
  }

  export type ModuloUpdateWithoutRutasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutRutasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type RolPermisoCreateWithoutRolInput = {
    id?: string
    permiso: ModuloPermisoCreateNestedOneWithoutRolesInput
  }

  export type RolPermisoUncheckedCreateWithoutRolInput = {
    id?: string
    permisoId: string
  }

  export type RolPermisoCreateOrConnectWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    create: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput>
  }

  export type RolPermisoCreateManyRolInputEnvelope = {
    data: RolPermisoCreateManyRolInput | RolPermisoCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutRolInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    empresa: EmpresaCreateNestedOneWithoutUsuariosInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRolInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    empresaId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRolInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput>
  }

  export type UsuarioCreateManyRolInputEnvelope = {
    data: UsuarioCreateManyRolInput | UsuarioCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type RolPermisoUpsertWithWhereUniqueWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    update: XOR<RolPermisoUpdateWithoutRolInput, RolPermisoUncheckedUpdateWithoutRolInput>
    create: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput>
  }

  export type RolPermisoUpdateWithWhereUniqueWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    data: XOR<RolPermisoUpdateWithoutRolInput, RolPermisoUncheckedUpdateWithoutRolInput>
  }

  export type RolPermisoUpdateManyWithWhereWithoutRolInput = {
    where: RolPermisoScalarWhereInput
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyWithoutRolInput>
  }

  export type RolPermisoScalarWhereInput = {
    AND?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
    OR?: RolPermisoScalarWhereInput[]
    NOT?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
    id?: StringFilter<"RolPermiso"> | string
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
  }

  export type UsuarioUpsertWithWhereUniqueWithoutRolInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutRolInput, UsuarioUncheckedUpdateWithoutRolInput>
    create: XOR<UsuarioCreateWithoutRolInput, UsuarioUncheckedCreateWithoutRolInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutRolInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutRolInput, UsuarioUncheckedUpdateWithoutRolInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutRolInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutRolInput>
  }

  export type ModuloCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutPermisosInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutPermisosInput, ModuloUncheckedCreateWithoutPermisosInput>
  }

  export type RolPermisoCreateWithoutPermisoInput = {
    id?: string
    rol: RolCreateNestedOneWithoutPermisosInput
  }

  export type RolPermisoUncheckedCreateWithoutPermisoInput = {
    id?: string
    rolId: string
  }

  export type RolPermisoCreateOrConnectWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    create: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput>
  }

  export type RolPermisoCreateManyPermisoInputEnvelope = {
    data: RolPermisoCreateManyPermisoInput | RolPermisoCreateManyPermisoInput[]
    skipDuplicates?: boolean
  }

  export type ModuloUpsertWithoutPermisosInput = {
    update: XOR<ModuloUpdateWithoutPermisosInput, ModuloUncheckedUpdateWithoutPermisosInput>
    create: XOR<ModuloCreateWithoutPermisosInput, ModuloUncheckedCreateWithoutPermisosInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutPermisosInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutPermisosInput, ModuloUncheckedUpdateWithoutPermisosInput>
  }

  export type ModuloUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type RolPermisoUpsertWithWhereUniqueWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    update: XOR<RolPermisoUpdateWithoutPermisoInput, RolPermisoUncheckedUpdateWithoutPermisoInput>
    create: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput>
  }

  export type RolPermisoUpdateWithWhereUniqueWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    data: XOR<RolPermisoUpdateWithoutPermisoInput, RolPermisoUncheckedUpdateWithoutPermisoInput>
  }

  export type RolPermisoUpdateManyWithWhereWithoutPermisoInput = {
    where: RolPermisoScalarWhereInput
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyWithoutPermisoInput>
  }

  export type ModuloPermisoCreateWithoutRolesInput = {
    id?: string
    nombre: string
    codigo: string
    descripcion?: string | null
    modulo: ModuloCreateNestedOneWithoutPermisosInput
  }

  export type ModuloPermisoUncheckedCreateWithoutRolesInput = {
    id?: string
    moduloId: string
    nombre: string
    codigo: string
    descripcion?: string | null
  }

  export type ModuloPermisoCreateOrConnectWithoutRolesInput = {
    where: ModuloPermisoWhereUniqueInput
    create: XOR<ModuloPermisoCreateWithoutRolesInput, ModuloPermisoUncheckedCreateWithoutRolesInput>
  }

  export type RolCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    usuarios?: UsuarioCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    activo?: boolean
    descripcion?: string | null
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutPermisosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
  }

  export type ModuloPermisoUpsertWithoutRolesInput = {
    update: XOR<ModuloPermisoUpdateWithoutRolesInput, ModuloPermisoUncheckedUpdateWithoutRolesInput>
    create: XOR<ModuloPermisoCreateWithoutRolesInput, ModuloPermisoUncheckedCreateWithoutRolesInput>
    where?: ModuloPermisoWhereInput
  }

  export type ModuloPermisoUpdateToOneWithWhereWithoutRolesInput = {
    where?: ModuloPermisoWhereInput
    data: XOR<ModuloPermisoUpdateWithoutRolesInput, ModuloPermisoUncheckedUpdateWithoutRolesInput>
  }

  export type ModuloPermisoUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: ModuloUpdateOneRequiredWithoutPermisosNestedInput
  }

  export type ModuloPermisoUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolUpsertWithoutPermisosInput = {
    update: XOR<RolUpdateWithoutPermisosInput, RolUncheckedUpdateWithoutPermisosInput>
    create: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutPermisosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutPermisosInput, RolUncheckedUpdateWithoutPermisosInput>
  }

  export type RolUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioUncheckedUpdateManyWithoutRolNestedInput
  }

  export type EmpresaCreateWithoutConfiguracionesInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutConfiguracionesInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutConfiguracionesInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutConfiguracionesInput, EmpresaUncheckedCreateWithoutConfiguracionesInput>
  }

  export type EmpresaUpsertWithoutConfiguracionesInput = {
    update: XOR<EmpresaUpdateWithoutConfiguracionesInput, EmpresaUncheckedUpdateWithoutConfiguracionesInput>
    create: XOR<EmpresaCreateWithoutConfiguracionesInput, EmpresaUncheckedCreateWithoutConfiguracionesInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutConfiguracionesInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutConfiguracionesInput, EmpresaUncheckedUpdateWithoutConfiguracionesInput>
  }

  export type EmpresaUpdateWithoutConfiguracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutConfiguracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateWithoutFacturasInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutFacturasInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutFacturasInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutFacturasInput, EmpresaUncheckedCreateWithoutFacturasInput>
  }

  export type EmpresaUpsertWithoutFacturasInput = {
    update: XOR<EmpresaUpdateWithoutFacturasInput, EmpresaUncheckedUpdateWithoutFacturasInput>
    create: XOR<EmpresaCreateWithoutFacturasInput, EmpresaUncheckedCreateWithoutFacturasInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutFacturasInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutFacturasInput, EmpresaUncheckedUpdateWithoutFacturasInput>
  }

  export type EmpresaUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateWithoutProductosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutProductosInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutProductosInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutProductosInput, EmpresaUncheckedCreateWithoutProductosInput>
  }

  export type EmpresaUpsertWithoutProductosInput = {
    update: XOR<EmpresaUpdateWithoutProductosInput, EmpresaUncheckedUpdateWithoutProductosInput>
    create: XOR<EmpresaCreateWithoutProductosInput, EmpresaUncheckedCreateWithoutProductosInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutProductosInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutProductosInput, EmpresaUncheckedUpdateWithoutProductosInput>
  }

  export type EmpresaUpdateWithoutProductosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutProductosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateWithoutClientesInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutClientesInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutClientesInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutClientesInput, EmpresaUncheckedCreateWithoutClientesInput>
  }

  export type EmpresaUpsertWithoutClientesInput = {
    update: XOR<EmpresaUpdateWithoutClientesInput, EmpresaUncheckedUpdateWithoutClientesInput>
    create: XOR<EmpresaCreateWithoutClientesInput, EmpresaUncheckedCreateWithoutClientesInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutClientesInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutClientesInput, EmpresaUncheckedUpdateWithoutClientesInput>
  }

  export type EmpresaUpdateWithoutClientesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutClientesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateWithoutMovimientosCajaInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutMovimientosCajaInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutMovimientosCajaInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutMovimientosCajaInput, EmpresaUncheckedCreateWithoutMovimientosCajaInput>
  }

  export type EmpresaUpsertWithoutMovimientosCajaInput = {
    update: XOR<EmpresaUpdateWithoutMovimientosCajaInput, EmpresaUncheckedUpdateWithoutMovimientosCajaInput>
    create: XOR<EmpresaCreateWithoutMovimientosCajaInput, EmpresaUncheckedCreateWithoutMovimientosCajaInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutMovimientosCajaInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutMovimientosCajaInput, EmpresaUncheckedUpdateWithoutMovimientosCajaInput>
  }

  export type EmpresaUpdateWithoutMovimientosCajaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutMovimientosCajaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateWithoutModuloHistoricoInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutModuloHistoricoInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
    planCuentas?: PlanCuentasUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutModuloHistoricoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutModuloHistoricoInput, EmpresaUncheckedCreateWithoutModuloHistoricoInput>
  }

  export type ModuloCreateWithoutModuloHistoricoInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateWithoutModuloHistoricoInput = {
    id?: string
    nombre: string
    displayName: string
    version?: string
    activo?: boolean
    color?: string | null
    descripcion?: string | null
    icono?: string | null
    orden?: number
    empresasConModulo?: EmpresaModuloUncheckedCreateNestedManyWithoutModuloInput
    esDependenciaDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutDependeDeInput
    dependeDe?: ModuloDependenciaUncheckedCreateNestedManyWithoutModuloInput
    permisos?: ModuloPermisoUncheckedCreateNestedManyWithoutModuloInput
    rutas?: ModuloRutaUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloCreateOrConnectWithoutModuloHistoricoInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutModuloHistoricoInput, ModuloUncheckedCreateWithoutModuloHistoricoInput>
  }

  export type UsuarioCreateWithoutModuloHistoricoInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    empresa: EmpresaCreateNestedOneWithoutUsuariosInput
    rol: RolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateWithoutModuloHistoricoInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    empresaId: string
    rolId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
  }

  export type UsuarioCreateOrConnectWithoutModuloHistoricoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutModuloHistoricoInput, UsuarioUncheckedCreateWithoutModuloHistoricoInput>
  }

  export type EmpresaUpsertWithoutModuloHistoricoInput = {
    update: XOR<EmpresaUpdateWithoutModuloHistoricoInput, EmpresaUncheckedUpdateWithoutModuloHistoricoInput>
    create: XOR<EmpresaCreateWithoutModuloHistoricoInput, EmpresaUncheckedCreateWithoutModuloHistoricoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutModuloHistoricoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutModuloHistoricoInput, EmpresaUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type EmpresaUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
    planCuentas?: PlanCuentasUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type ModuloUpsertWithoutModuloHistoricoInput = {
    update: XOR<ModuloUpdateWithoutModuloHistoricoInput, ModuloUncheckedUpdateWithoutModuloHistoricoInput>
    create: XOR<ModuloCreateWithoutModuloHistoricoInput, ModuloUncheckedCreateWithoutModuloHistoricoInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutModuloHistoricoInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutModuloHistoricoInput, ModuloUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type ModuloUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    empresasConModulo?: EmpresaModuloUncheckedUpdateManyWithoutModuloNestedInput
    esDependenciaDe?: ModuloDependenciaUncheckedUpdateManyWithoutDependeDeNestedInput
    dependeDe?: ModuloDependenciaUncheckedUpdateManyWithoutModuloNestedInput
    permisos?: ModuloPermisoUncheckedUpdateManyWithoutModuloNestedInput
    rutas?: ModuloRutaUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type UsuarioUpsertWithoutModuloHistoricoInput = {
    update: XOR<UsuarioUpdateWithoutModuloHistoricoInput, UsuarioUncheckedUpdateWithoutModuloHistoricoInput>
    create: XOR<UsuarioCreateWithoutModuloHistoricoInput, UsuarioUncheckedCreateWithoutModuloHistoricoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutModuloHistoricoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutModuloHistoricoInput, UsuarioUncheckedUpdateWithoutModuloHistoricoInput>
  }

  export type UsuarioUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutUsuariosNestedInput
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutModuloHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpresaCreateWithoutPlanCuentasInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaCreateNestedManyWithoutEmpresaInput
    productos?: ProductoCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutPlanCuentasInput = {
    id?: string
    nombre: string
    ruc: string
    activo?: boolean
    direccion?: string | null
    email?: string | null
    fechaActualizacion?: Date | string
    fechaCreacion?: Date | string
    telefono?: string | null
    plan?: $Enums.PlanType
    clientes?: ClienteUncheckedCreateNestedManyWithoutEmpresaInput
    configuraciones?: EmpresaConfiguracionUncheckedCreateNestedManyWithoutEmpresaInput
    modulosActivos?: EmpresaModuloUncheckedCreateNestedManyWithoutEmpresaInput
    moduloHistorico?: ModuloHistoricoUncheckedCreateNestedManyWithoutEmpresaInput
    facturas?: FacturaUncheckedCreateNestedManyWithoutEmpresaInput
    movimientosCaja?: MovimientoCajaUncheckedCreateNestedManyWithoutEmpresaInput
    productos?: ProductoUncheckedCreateNestedManyWithoutEmpresaInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutPlanCuentasInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutPlanCuentasInput, EmpresaUncheckedCreateWithoutPlanCuentasInput>
  }

  export type EmpresaUpsertWithoutPlanCuentasInput = {
    update: XOR<EmpresaUpdateWithoutPlanCuentasInput, EmpresaUncheckedUpdateWithoutPlanCuentasInput>
    create: XOR<EmpresaCreateWithoutPlanCuentasInput, EmpresaUncheckedCreateWithoutPlanCuentasInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutPlanCuentasInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutPlanCuentasInput, EmpresaUncheckedUpdateWithoutPlanCuentasInput>
  }

  export type EmpresaUpdateWithoutPlanCuentasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutPlanCuentasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ruc?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    clientes?: ClienteUncheckedUpdateManyWithoutEmpresaNestedInput
    configuraciones?: EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaNestedInput
    modulosActivos?: EmpresaModuloUncheckedUpdateManyWithoutEmpresaNestedInput
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutEmpresaNestedInput
    facturas?: FacturaUncheckedUpdateManyWithoutEmpresaNestedInput
    movimientosCaja?: MovimientoCajaUncheckedUpdateManyWithoutEmpresaNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutEmpresaNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type ClienteCreateManyEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaConfiguracionCreateManyEmpresaInput = {
    id?: string
    clave: string
    valor: JsonNullValueInput | InputJsonValue
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaModuloCreateManyEmpresaInput = {
    id?: string
    moduloId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type ModuloHistoricoCreateManyEmpresaInput = {
    id?: string
    moduloId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type FacturaCreateManyEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovimientoCajaCreateManyEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductoCreateManyEmpresaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioCreateManyEmpresaInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    rolId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
  }

  export type PlanCuentasCreateManyEmpresaInput = {
    id?: string
    codigo: string
    codigoPadre?: string | null
    nivel: number
    nombre: string
    nombreCompleto?: string | null
    nombreCorto?: string | null
    tipoMayor: string
    tipoDetalle?: string | null
    naturaleza: string
    permiteMovimiento?: boolean
    esAuxiliar?: boolean
    nivelMaximo?: number
    monedaPermitida?: string
    centroCostoObligatorio?: boolean
    proyectoObligatorio?: boolean
    requiereReferencia?: boolean
    requiereCliente?: boolean
    requiereProveedor?: boolean
    activo?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type ClienteUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaConfiguracionUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaConfiguracionUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaConfiguracionUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: JsonNullValueInput | InputJsonValue
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaModuloUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: ModuloUpdateOneRequiredWithoutEmpresasConModuloNestedInput
  }

  export type EmpresaModuloUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpresaModuloUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuloHistoricoUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    modulo?: ModuloUpdateOneRequiredWithoutModuloHistoricoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutModuloHistoricoNestedInput
  }

  export type ModuloHistoricoUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacturaUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovimientoCajaUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanCuentasUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCuentasUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCuentasUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    codigoPadre?: NullableStringFieldUpdateOperationsInput | string | null
    nivel?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: NullableStringFieldUpdateOperationsInput | string | null
    nombreCorto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoMayor?: StringFieldUpdateOperationsInput | string
    tipoDetalle?: NullableStringFieldUpdateOperationsInput | string | null
    naturaleza?: StringFieldUpdateOperationsInput | string
    permiteMovimiento?: BoolFieldUpdateOperationsInput | boolean
    esAuxiliar?: BoolFieldUpdateOperationsInput | boolean
    nivelMaximo?: IntFieldUpdateOperationsInput | number
    monedaPermitida?: StringFieldUpdateOperationsInput | string
    centroCostoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    proyectoObligatorio?: BoolFieldUpdateOperationsInput | boolean
    requiereReferencia?: BoolFieldUpdateOperationsInput | boolean
    requiereCliente?: BoolFieldUpdateOperationsInput | boolean
    requiereProveedor?: BoolFieldUpdateOperationsInput | boolean
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoCreateManyUsuarioInput = {
    id?: string
    empresaId: string
    moduloId: string
    accion: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloHistoricoUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutModuloHistoricoNestedInput
    modulo?: ModuloUpdateOneRequiredWithoutModuloHistoricoNestedInput
  }

  export type ModuloHistoricoUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaModuloCreateManyModuloInput = {
    id?: string
    empresaId: string
    activo?: boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: Date | string
    fechaDesactivacion?: Date | string | null
  }

  export type ModuloHistoricoCreateManyModuloInput = {
    id?: string
    empresaId: string
    accion: string
    usuarioId: string
    razon?: string | null
    fechaCreacion?: Date | string
  }

  export type ModuloDependenciaCreateManyDependeDeInput = {
    id?: string
    moduloId: string
    requerido?: boolean
  }

  export type ModuloDependenciaCreateManyModuloInput = {
    id?: string
    dependeDeId: string
    requerido?: boolean
  }

  export type ModuloPermisoCreateManyModuloInput = {
    id?: string
    nombre: string
    codigo: string
    descripcion?: string | null
  }

  export type ModuloRutaCreateManyModuloInput = {
    id?: string
    ruta: string
    activo?: boolean
    descripcion?: string | null
    nombre: string
  }

  export type EmpresaModuloUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutModulosActivosNestedInput
  }

  export type EmpresaModuloUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpresaModuloUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    configuracion?: NullableJsonNullValueInput | InputJsonValue
    fechaActivacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaDesactivacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuloHistoricoUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutModuloHistoricoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutModuloHistoricoNestedInput
  }

  export type ModuloHistoricoUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloHistoricoUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloDependenciaUpdateWithoutDependeDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
    modulo?: ModuloUpdateOneRequiredWithoutDependeDeNestedInput
  }

  export type ModuloDependenciaUncheckedUpdateWithoutDependeDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloDependenciaUncheckedUpdateManyWithoutDependeDeInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloDependenciaUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
    dependeDe?: ModuloUpdateOneRequiredWithoutEsDependenciaDeNestedInput
  }

  export type ModuloDependenciaUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependeDeId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloDependenciaUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependeDeId?: StringFieldUpdateOperationsInput | string
    requerido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloPermisoUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolPermisoUpdateManyWithoutPermisoNestedInput
  }

  export type ModuloPermisoUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type ModuloPermisoUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuloRutaUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ModuloRutaUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ModuloRutaUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruta?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoCreateManyRolInput = {
    id?: string
    permisoId: string
  }

  export type UsuarioCreateManyRolInput = {
    id?: string
    email: string
    nombre: string
    apellido?: string | null
    password: string
    empresaId: string
    activo?: boolean
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
  }

  export type RolPermisoUpdateWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    permiso?: ModuloPermisoUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolPermisoUncheckedUpdateWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoUncheckedUpdateManyWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUpdateWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutUsuariosNestedInput
    moduloHistorico?: ModuloHistoricoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moduloHistorico?: ModuloHistoricoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolPermisoCreateManyPermisoInput = {
    id?: string
    rolId: string
  }

  export type RolPermisoUpdateWithoutPermisoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: RolUpdateOneRequiredWithoutPermisosNestedInput
  }

  export type RolPermisoUncheckedUpdateWithoutPermisoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoUncheckedUpdateManyWithoutPermisoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloCountOutputTypeDefaultArgs instead
     */
    export type ModuloCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolCountOutputTypeDefaultArgs instead
     */
    export type RolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloPermisoCountOutputTypeDefaultArgs instead
     */
    export type ModuloPermisoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloPermisoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloDefaultArgs instead
     */
    export type ModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaModuloDefaultArgs instead
     */
    export type EmpresaModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaModuloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloDependenciaDefaultArgs instead
     */
    export type ModuloDependenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloDependenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloRutaDefaultArgs instead
     */
    export type ModuloRutaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloRutaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolDefaultArgs instead
     */
    export type RolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloPermisoDefaultArgs instead
     */
    export type ModuloPermisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloPermisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolPermisoDefaultArgs instead
     */
    export type RolPermisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolPermisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaConfiguracionDefaultArgs instead
     */
    export type EmpresaConfiguracionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaConfiguracionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacturaDefaultArgs instead
     */
    export type FacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoDefaultArgs instead
     */
    export type ProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovimientoCajaDefaultArgs instead
     */
    export type MovimientoCajaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovimientoCajaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloHistoricoDefaultArgs instead
     */
    export type ModuloHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloHistoricoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCuentasDefaultArgs instead
     */
    export type PlanCuentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCuentasDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}